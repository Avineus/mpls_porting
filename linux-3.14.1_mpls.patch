diff -Nur linux-3.14.1/include/linux/mpls.h linux-3.14.1_mpls/include/linux/mpls.h
--- linux-3.14.1/include/linux/mpls.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/include/linux/mpls.h	2014-04-22 16:19:26.138194557 +0530
@@ -0,0 +1,250 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ * include/linux/mpls.h
+ *      Data types and structs used by userspace programs to access MPLS
+ *      forwarding. Most interface with the MPLS subsystem is IOCTL based
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ ****************************************************************************/
+
+#ifndef _LINUX_MPLS_H_
+#define _LINUX_MPLS_H_
+
+#ifdef __KERNEL__
+#include <linux/socket.h>
+#include <linux/if.h>
+#else
+#include <sys/socket.h>
+#include <linux/types.h>
+#include <net/if.h>
+#endif
+
+#define MPLS_NUM_OPS		8
+
+#define MPLS_LINUX_VERSION	0x01090800
+
+#define	MPLS_GRP_ILM	1
+#define	MPLS_GRP_NHLFE	2
+#define	MPLS_GRP_XC	4
+#define	MPLS_GRP_LABELSPACE 8
+
+#define MPLS_IPV4_EXPLICIT_NULL	0       /* only valid as sole label stack entry
+					   Pop label and send to IPv4 stack */
+#define MPLS_ROUTER_ALERT	1       /* anywhere except bottom, packet it is
+					   forwared to a software module
+					   determined by the next label,
+					   if the packet is forwarded, push this
+					   label back on */
+#define MPLS_IPV6_EXPLICIT_NULL	2       /* only valid as sole label stack entry
+					   Pop label and send to IPv6 stack */
+#define MPLS_IMPLICIT_NULL	3       /* a LIB with this, signifies to pop
+					   the next label and use that */
+
+#define MPLS_CHANGE_MTU		0x01
+#define MPLS_CHANGE_PROP_TTL	0x02
+#define MPLS_CHANGE_INSTR	0x04
+#define MPLS_CHANGE_PROTO	0x10
+
+enum mpls_dir {
+	MPLS_IN = 0x10,
+	MPLS_OUT = 0x20
+};
+
+enum mpls_opcode_enum {
+	MPLS_OP_NOP = 0x00,
+	MPLS_OP_POP,
+	MPLS_OP_PEEK,
+	MPLS_OP_PUSH,
+	MPLS_OP_DLV,
+	MPLS_OP_FWD,
+	MPLS_OP_NF_FWD,
+	MPLS_OP_DS_FWD,
+	MPLS_OP_EXP_FWD,
+	MPLS_OP_SET,
+	MPLS_OP_SET_RX,
+	MPLS_OP_SET_TC,
+	MPLS_OP_SET_DS,
+	MPLS_OP_SET_EXP,
+	MPLS_OP_EXP2TC,
+	MPLS_OP_EXP2DS,
+	MPLS_OP_TC2EXP,
+	MPLS_OP_DS2EXP,
+	MPLS_OP_NF2EXP,
+	MPLS_OP_SET_NF,
+	MPLS_OP_MAX
+};
+
+enum mpls_label_type_enum {
+	MPLS_LABEL_GEN = 1,
+	MPLS_LABEL_ATM,
+	MPLS_LABEL_FR,
+	MPLS_LABEL_KEY
+};
+
+#define MPLS_SHIM_SIZE 4
+
+struct mpls_label_atm {
+	u_int16_t  mla_vpi;
+	u_int16_t  mla_vci;
+};
+
+struct mpls_label {
+	enum mpls_label_type_enum ml_type;
+	union {
+		u_int32_t ml_key;
+		u_int32_t ml_gen;
+		u_int32_t ml_fr;
+		struct mpls_label_atm ml_atm;
+	} u;
+	int ml_index;
+};
+
+struct mpls_in_label_req {
+	unsigned int      mil_proto;
+	struct mpls_label mil_label;
+	unsigned char     mil_change_flag;
+};
+
+#define MPLS_LABELSPACE_MAX	255
+
+struct mpls_labelspace_req {
+	int mls_ifindex;                  /* Index to the MPLS-enab. interface*/
+	int mls_labelspace;               /* Labelspace IN/SET -- OUT/GET     */
+};
+
+struct mpls_nexthop_info {
+	unsigned int    mni_if;
+	struct sockaddr mni_addr;
+};
+
+struct mpls_out_label_req {
+	struct mpls_label mol_label;
+	u_int32_t         mol_mtu;
+	int8_t            mol_propagate_ttl;
+	unsigned char     mol_change_flag;
+};
+
+struct mpls_xconnect_req {
+	struct mpls_label mx_in;
+	struct mpls_label mx_out;
+};
+
+struct mpls_tunnel_req {
+	char mt_ifname[IFNAMSIZ];
+	unsigned int mt_nhlfe_key;
+};
+
+#define MPLS_NFMARK_NUM 64
+
+struct mpls_nfmark_fwd {
+	unsigned int nf_key[MPLS_NFMARK_NUM];
+	unsigned short nf_mask;
+};
+
+#define MPLS_DSMARK_NUM 64
+
+struct mpls_dsmark_fwd {
+	unsigned int df_key[MPLS_DSMARK_NUM];
+	unsigned char df_mask;
+};
+
+#define MPLS_TCINDEX_NUM 64
+
+struct mpls_tcindex_fwd {
+	unsigned int tc_key[MPLS_TCINDEX_NUM];
+	unsigned short tc_mask;
+};
+
+#define MPLS_EXP_NUM 8
+
+struct mpls_exp_fwd {
+	unsigned int ef_key[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2tcindex {
+	unsigned short e2t[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2dsmark {
+	unsigned char e2d[MPLS_EXP_NUM];
+};
+
+struct mpls_tcindex2exp {
+	unsigned char t2e_mask;
+	unsigned char t2e[MPLS_TCINDEX_NUM];
+};
+
+struct mpls_dsmark2exp {
+	unsigned char d2e_mask;
+	unsigned char d2e[MPLS_DSMARK_NUM];
+};
+
+struct mpls_nfmark2exp {
+	unsigned char n2e_mask;
+	unsigned char n2e[MPLS_NFMARK_NUM];
+};
+
+struct mpls_instr_elem {
+	unsigned short mir_opcode;
+	unsigned char mir_direction;
+	union {
+		struct mpls_label        push;
+		struct mpls_label        fwd;
+		struct mpls_nfmark_fwd   nf_fwd;
+		struct mpls_dsmark_fwd   ds_fwd;
+		struct mpls_exp_fwd      exp_fwd;
+		struct mpls_nexthop_info set;
+		unsigned int             set_rx;
+		unsigned short           set_tc;
+		unsigned short           set_ds;
+		unsigned char            set_exp;
+		struct mpls_exp2tcindex  exp2tc;
+		struct mpls_exp2dsmark   exp2ds;
+		struct mpls_tcindex2exp  tc2exp;
+		struct mpls_dsmark2exp   ds2exp;
+		struct mpls_nfmark2exp   nf2exp;
+		unsigned long            set_nf;
+	} mir_data;
+};
+
+/* Standard shortcuts */
+#define mir_push       mir_data.push
+#define mir_fwd        mir_data.fwd
+#define mir_nf_fwd     mir_data.nf_fwd
+#define mir_ds_fwd     mir_data.ds_fwd
+#define mir_exp_fwd    mir_data.exp_fwd
+#define mir_set        mir_data.set
+#define mir_set_rx     mir_data.set_rx
+#define mir_set_tc     mir_data.set_tc
+#define mir_set_tx     mir_data.set_tx
+#define mir_set_ds     mir_data.set_ds
+#define mir_set_exp    mir_data.set_exp
+#define mir_set_nf     mir_data.set_nf
+#define mir_exp2tc     mir_data.exp2tc
+#define mir_exp2ds     mir_data.exp2ds
+#define mir_tc2exp     mir_data.tc2exp
+#define mir_ds2exp     mir_data.ds2exp
+#define mir_nf2exp     mir_data.nf2exp
+
+struct mpls_instr_req {
+	struct mpls_instr_elem       mir_instr[MPLS_NUM_OPS];
+	unsigned char                mir_instr_length;
+	unsigned char                mir_direction;
+	int                          mir_index;
+	struct mpls_label            mir_label;
+};
+
+#endif
diff -Nur linux-3.14.1/include/linux/netdevice.h linux-3.14.1_mpls/include/linux/netdevice.h
--- linux-3.14.1/include/linux/netdevice.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/linux/netdevice.h	2014-04-22 16:25:36.793534789 +0530
@@ -1312,6 +1312,7 @@
 	void			*ax25_ptr;	/* AX.25 specific data */
 	struct wireless_dev	*ieee80211_ptr;	/* IEEE 802.11 specific data,
 						   assign before registering */
+	void *mpls_ptr;	/* MPLS specific data */
 
 /*
  * Cache lines mostly used on receive path (including eth_type_trans())
diff -Nur linux-3.14.1/include/linux/netfilter/xt_mpls.h linux-3.14.1_mpls/include/linux/netfilter/xt_mpls.h
--- linux-3.14.1/include/linux/netfilter/xt_mpls.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/include/linux/netfilter/xt_mpls.h	2014-04-22 16:29:15.574784336 +0530
@@ -0,0 +1,12 @@
+#ifndef _XT_MPLS_H_target
+#define _XT_MPLS_H_target
+
+struct xt_mpls_target_info {
+	u_int32_t key;
+
+	/* only used by the netfilter kernel modules */
+	void *nhlfe;
+	void *proto;
+};
+
+#endif /*_XT_MPLS_H_target */
diff -Nur linux-3.14.1/include/linux/shim.h linux-3.14.1_mpls/include/linux/shim.h
--- linux-3.14.1/include/linux/shim.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/include/linux/shim.h	2014-04-22 16:44:18.259436053 +0530
@@ -0,0 +1,12 @@
+#ifndef LINUX_SHIM_H
+#define LINUX_SHIM_H
+
+#define SHIMNAMSIZ 16
+struct rtshim
+{
+	char name[SHIMNAMSIZ+1];
+	short datalen;
+	char data[0];
+};
+
+#endif
diff -Nur linux-3.14.1/include/linux/socket.h linux-3.14.1_mpls/include/linux/socket.h
--- linux-3.14.1/include/linux/socket.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/linux/socket.h	2014-04-22 16:47:15.793204151 +0530
@@ -168,6 +168,7 @@
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
 #define AF_LLC		26	/* Linux LLC			*/
 #define AF_IB		27	/* Native InfiniBand address	*/
+#define AF_MPLS		28	/* MPLS sockets			*/
 #define AF_CAN		29	/* Controller Area Network      */
 #define AF_TIPC		30	/* TIPC sockets			*/
 #define AF_BLUETOOTH	31	/* Bluetooth sockets 		*/
@@ -213,6 +214,7 @@
 #define PF_WANPIPE	AF_WANPIPE
 #define PF_LLC		AF_LLC
 #define PF_IB		AF_IB
+#define PF_MPLS		AF_MPLS
 #define PF_CAN		AF_CAN
 #define PF_TIPC		AF_TIPC
 #define PF_BLUETOOTH	AF_BLUETOOTH
diff -Nur linux-3.14.1/include/net/ip6_fib.h linux-3.14.1_mpls/include/net/ip6_fib.h
--- linux-3.14.1/include/net/ip6_fib.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/net/ip6_fib.h	2014-04-22 17:10:00.308049877 +0530
@@ -20,6 +20,7 @@
 #include <net/flow.h>
 #include <net/netlink.h>
 #include <net/inetpeer.h>
+#include <net/shim.h>
 
 #ifdef CONFIG_IPV6_MULTIPLE_TABLES
 #define FIB6_TABLE_HASHSZ 256
@@ -51,6 +52,7 @@
 	struct nlattr	*fc_mp;
 
 	struct nl_info	fc_nlinfo;
+	struct rtshim	fc_shim;
 };
 
 struct fib6_node {
@@ -125,6 +127,7 @@
 	unsigned short			rt6i_nfheader_len;
 
 	u8				rt6i_protocol;
+	struct shim_blk			*rt6i_shim;
 };
 
 static inline struct inet_peer *rt6_peer_ptr(struct rt6_info *rt)
diff -Nur linux-3.14.1/include/net/ip_fib.h linux-3.14.1_mpls/include/net/ip_fib.h
--- linux-3.14.1/include/net/ip_fib.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/net/ip_fib.h	2014-04-23 11:58:12.049628237 +0530
@@ -20,6 +20,7 @@
 #include <linux/seq_file.h>
 #include <linux/rcupdate.h>
 #include <net/fib_rules.h>
+#include <net/shim.h>
 #include <net/inetpeer.h>
 #include <linux/percpu.h>
 
@@ -44,6 +45,7 @@
 	u32			fc_flow;
 	u32			fc_nlflags;
 	struct nl_info		fc_nlinfo;
+	struct rtshim		fc_shim;
  };
 
 struct fib_info;
@@ -88,6 +90,7 @@
 	struct rtable __rcu * __percpu *nh_pcpu_rth_output;
 	struct rtable __rcu	*nh_rth_input;
 	struct fnhe_hash_bucket	*nh_exceptions;
+	struct shim_blk		*nh_shim;
 };
 
 /*
@@ -175,6 +178,7 @@
 #define FIB_RES_GW(res)			(FIB_RES_NH(res).nh_gw)
 #define FIB_RES_DEV(res)		(FIB_RES_NH(res).nh_dev)
 #define FIB_RES_OIF(res)		(FIB_RES_NH(res).nh_oif)
+#define FIB_RES_SHIM(res)		(FIB_RES_NH(res).nh_shim)
 
 #define FIB_RES_PREFSRC(net, res)	((res).fi->fib_prefsrc ? : \
 					 FIB_RES_SADDR(net, res))
diff -Nur linux-3.14.1/include/net/mpls.h linux-3.14.1_mpls/include/net/mpls.h
--- linux-3.14.1/include/net/mpls.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/include/net/mpls.h	2014-04-23 17:39:12.488405687 +0530
@@ -0,0 +1,703 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * File:  linux/include/net/mpls.h
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *   Changes:
+ *   20031126 RCAS:
+ *         - Rewrite the debugging macros.
+ *   20040319 JLEU:
+ *	   - switch to gen_stats
+ *   20041018 JLEU
+ *	   - added cache_flush to the prot driver
+ *****************************************************************************
+ */
+#ifndef __LINUX_NET_MPLS__H_
+#define __LINUX_NET_MPLS__H_
+
+#include <generated/autoconf.h>
+#include <net/shim.h>
+#include <net/dst.h>
+#include <asm/atomic.h>
+#include <linux/init.h>
+#include <linux/mpls.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include <linux/gen_stats.h>
+#include <linux/sysctl.h>
+
+/* 
+ * Forward declarations
+ */
+
+struct fib_result;
+struct rtable;
+
+extern int sysctl_mpls_debug;
+extern int sysctl_mpls_default_ttl;
+extern struct dst_ops mpls_dst_ops;
+
+#define MPLS_ERR KERN_ERR
+#define MPLS_INF KERN_ALERT
+#define MPLS_DBG KERN_DEBUG
+
+/* Comment this to suppress MPLS_DEBUG calls */
+#define MPLS_ENABLE_DEBUG 1
+
+/* Comment this to suppress TRACING enter/exit functions */
+#define MPLS_ENABLE_DEBUG_FUNC 1
+
+#ifdef  MPLS_ENABLE_DEBUG
+#define MPLS_DEBUG(f, a...) \
+{ \
+	if (sysctl_mpls_debug) {\
+		printk (MPLS_DBG "MPLS DEBUG %s:%d:%s: ", \
+			__FILE__, __LINE__, __FUNCTION__); \
+		printk (f, ##a); \
+	}\
+}
+
+#define MPLS_DEBUG_CALL(f) \
+{ \
+	if (sysctl_mpls_debug) {\
+		f; \
+	} \
+}
+#else
+#define MPLS_DEBUG(f, a...) /**/
+#define MPLS_DEBUG_CALL(f) /**/
+#endif /* MPLS_ENABLE_DEBUG */
+
+#ifdef MPLS_ENABLE_DEBUG_FUNC
+#define MPLS_ENTER MPLS_DEBUG("enter\n")
+#define MPLS_EXIT  MPLS_DEBUG("exit\n")
+#else
+#define MPLS_ENTER /**/
+#define MPLS_EXIT  /**/
+#endif
+
+#define MPLS_INFO(f, a...) printk (KERN_INFO "MPLS INFO " f, ##a);
+
+#ifdef MPLS_ENABLE_DEBUG 
+#define MPLS_ASSERT(expr) \
+if(unlikely(!(expr))) { \
+	printk(KERN_ERR "MPLS Assertion failed! %s,%s,%s,line=%d\n",#expr,\
+	__FILE__,__FUNCTION__,__LINE__);          \
+}
+#else
+#define MPLS_ASSERT(expr) /**/
+#endif /* MPLS_ENABLE_DEBUG */
+
+/****************************************************************************
+ * MPLS Interface "Extension" 
+ * In the current implementation the "all loved" net_device struct is 
+ * extended with one field struct mpls_interface (cast'd to void) called
+ * mpls_ptr; This holds basically the "per interface" labelspace.
+ ****************************************************************************/
+
+struct mpls_interface {
+	/*  
+	 * (any mif object)->list_out is a circular d-linked list. Each node
+	 * of this list is a NHLFE. NHLFE's are added to this list when adding a 
+	 * OP_SET opcode to a nhlfe instruction array.
+	 * 
+	 * list_add(&nhlfe->dev_entry, &mpls_if->list_out) : adds nhlfe to this 
+	 * list.
+	 *
+	 * "List of all NHLFEs that use this device (e.g. eth0) as output"
+	 * cf. mpls_init.c
+	 */
+	struct list_head list_out;
+	                         
+
+	/*  
+	 * (any mif object)->list_in is a circular d-linked list. Each node
+	 * of this list is a ILM. ILM's are added to this list when 
+	 */
+	struct list_head list_in;  
+
+	/* 
+	 * Label Space for this interface 
+	 */
+	int  labelspace;  
+};
+
+
+
+extern struct mpls_interface* mpls_create_if_info(void);
+extern void                   mpls_delete_if_info(struct net_device *);
+extern struct mpls_interface* mpls_get_if_info(unsigned int);
+
+/****************************************************************************
+ * Socket Buffer Mangement
+ ****************************************************************************/
+
+struct mpls_skb_parm {
+	struct mpls_prot_driver *prot;
+	unsigned int  gap;
+	unsigned int  label:20;
+	unsigned int  ttl:8;
+	unsigned int  exp:3;
+	unsigned int  bos:1;
+	unsigned char flag;
+	unsigned char popped_bos;
+	unsigned char *top_of_stack;
+};
+
+#define MPLSCB(skb) ((struct mpls_skb_parm*)((skb)->cb))
+
+
+/****************************************************************************
+ * Result codes for Input/Output Opcodes. 
+ * net/mpls/{mpls_opcode,mpls_opcode_all}.c
+ ****************************************************************************/
+
+#define MPLS_RESULT_SUCCESS	0
+#define MPLS_RESULT_RECURSE	1
+#define MPLS_RESULT_DROP	2
+#define MPLS_RESULT_DLV		3
+#define MPLS_RESULT_FWD		4
+
+
+/**
+ * mpls_instr - Struct to hold one instruction
+ * @mi_opcode: Opcode. MPLS_OP_POP,etc...       
+ * @mi_data:   Opcode data.
+ * @mi_next:   Next Instruction to execute. 
+ **/
+struct mpls_instr {
+	struct mpls_instr  *mi_next;
+	unsigned short      mi_opcode;
+	enum mpls_dir       mi_dir;
+	void               *mi_data; 
+	void *              mi_parent;
+};
+
+
+struct mpls_nfmark_fwd_info {
+	struct mpls_nhlfe *nfi_nhlfe[MPLS_NFMARK_NUM];
+	unsigned short        nfi_mask;
+};
+
+struct mpls_dsmark_fwd_info {
+	struct mpls_nhlfe *dfi_nhlfe[MPLS_DSMARK_NUM];
+	unsigned char         dfi_mask;
+};
+
+struct mpls_tcindex_fwd_info {
+	struct mpls_nhlfe *tfi_nhlfe[MPLS_TCINDEX_NUM];
+	unsigned short        tfi_mask;
+};
+
+struct mpls_exp_fwd_info {
+	struct mpls_nhlfe *efi_nhlfe[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2dsmark_info {
+	unsigned char e2d[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2tcindex_info {
+	unsigned short e2t[MPLS_EXP_NUM];
+};
+
+struct mpls_tcindex2exp_info {
+	unsigned char t2e_mask;
+	unsigned char t2e[MPLS_TCINDEX_NUM];
+};
+
+struct mpls_dsmark2exp_info {
+	unsigned char d2e_mask;
+	unsigned char d2e[MPLS_DSMARK_NUM];
+};
+
+struct mpls_nfmark2exp_info {
+	unsigned char n2e_mask;
+	unsigned char n2e[MPLS_NFMARK_NUM];
+};
+
+/****************************************************************************
+ * Instruction (OPCODEs) Management 
+ * net/mpls/mpls_instr.c
+ ****************************************************************************/
+
+void               mpls_instr_release(struct mpls_instr *mi);
+struct mpls_instr* mpls_instr_alloc(unsigned short opcode);
+void               mpls_instrs_free(struct mpls_instr *list);
+int                mpls_instrs_build(struct mpls_instr_elem *mie, 
+				struct mpls_instr **instr, int length, 
+				enum mpls_dir dir,void *parent);
+void		   mpls_instrs_unbuild(struct mpls_instr *instr,
+				struct mpls_instr_req *req);
+
+/****************************************************************************
+ * Layer 3 protocol driver
+ *
+ * most of this code is taken from DaveM&JHadi implementation
+ ****************************************************************************/
+#define MPLSPROTONAMSIZ 16
+struct mpls_prot_driver {
+	atomic_t	__refcnt;
+	struct list_head list;
+
+	unsigned short	family;
+	unsigned short	ethertype;
+	char		name[MPLSPROTONAMSIZ + 1];
+
+	void		(*cache_flush)(struct net *net);
+	void		(*set_ttl)(struct sk_buff *skb, int ttl);
+	int		(*get_ttl)(struct sk_buff *skb);
+	void		(*change_dsfield)(struct sk_buff *skb, int ds);
+	int		(*get_dsfield)(struct sk_buff *skb);
+	int		(*ttl_expired)(struct sk_buff **skb);
+	int		(*mtu_exceeded)(struct sk_buff **skb, int mtu);
+	int		(*local_deliver)(struct sk_buff *skb);
+
+	int		(*nexthop_resolve)(struct neighbour **,
+				struct sockaddr *, struct net_device *);
+
+	struct module	*owner;
+};
+
+/****************************************************************************
+ * Protocol driver Management 
+ * net/mpls/mpls_proto.c
+ ****************************************************************************/
+
+void                     mpls_proto_init(void);
+void                     mpls_proto_exit(void);
+int                      mpls_proto_add(struct mpls_prot_driver *);
+int                      mpls_proto_remove(struct mpls_prot_driver *);
+struct mpls_prot_driver *mpls_proto_find_by_family(unsigned short);
+struct mpls_prot_driver *mpls_proto_find_by_ethertype(unsigned short);
+struct mpls_prot_driver *mpls_proto_find_by_name(char *);
+void                     mpls_proto_cache_flush_all (struct net *);
+
+#define mpls_proto_release(V)   atomic_dec((&V->__refcnt));
+#define mpls_proto_hold(V)      atomic_inc((&V->__refcnt));
+
+/****************************************************************************
+ * MPLS INPUT INFO (ILM) OBJECT MANAGEMENT
+ * net/mpls/mpls_ilm.c
+ ****************************************************************************/
+
+struct mpls_ilm {
+
+	union {
+		struct dst_entry     dst;
+		struct mpls_ilm *next;
+	} u;
+
+	struct list_head             global;
+
+	/* To appear as an entry in the device ILM list                     */ 
+	struct list_head             dev_entry;
+	/* Generic stats						    */
+	struct gnet_stats_basic	     ilm_stats;
+	unsigned int		     ilm_drops;
+	/* List of NHLFE                                                    */ 
+	struct list_head             nhlfe_entry;
+	/* Instructions to execute for this ILM                             */ 
+	struct mpls_instr           *ilm_instr;
+	/* Incoming Label for this ILM                                      */
+	struct mpls_label            ilm_label;
+	/* Key used to lookup this object in a data structure               */
+	unsigned int                 ilm_key;
+	/* Jiffies                                                          */
+	unsigned int                 ilm_age;
+	/* L3 protocol driver for packets that use this ILM                 */
+	struct mpls_prot_driver     *ilm_proto;
+	/* Incoming Labelspace (see doc)                                    */
+	unsigned short               ilm_labelspace;
+	/* execute mpls_finish() before delivering locally		    */
+	unsigned short               ilm_fix_hh;
+};
+
+
+/****************************************************************************
+ * Input Radix Tree Management
+ ****************************************************************************/
+
+extern spinlock_t               mpls_ilm_lock;
+extern struct radix_tree_root   mpls_ilm_tree;
+
+int               mpls_ilm_init(void);
+void              mpls_ilm_exit(void);
+int               mpls_insert_ilm(unsigned int, struct mpls_ilm* ilm);
+struct mpls_ilm*  mpls_delete_ilm(unsigned int key);
+struct mpls_ilm*  mpls_get_ilm(unsigned int key);
+struct mpls_ilm*  mpls_get_ilm_by_label(struct mpls_label *label,
+				int labelspace, char bos);
+extern struct mpls_ilm* mpls_ilm_dst_alloc(unsigned int key,
+				struct mpls_label *ml, unsigned short family,
+				struct mpls_instr_elem *instr, int instr_len);
+
+
+
+/****************************************************************************
+ * MPLS OUTPUT INFO (NHLFE) OBJECT MANAGEMENT
+ * net/mpls/mpls_ilm.c
+ ****************************************************************************/
+
+struct mpls_nhlfe {
+	/* since most higher lay protocol operate on dst_entries, representing
+	 * a NHLFE as a dst_enttry make sense.  Higher layer protocols
+	 * may hold references to the dst_entry.  The result is that
+	 * a NHLFE may exist after the user deletes it from the RADIX tree.
+	 */
+	union {
+		struct dst_entry	dst;
+		struct mpls_nhlfe	*next;
+	} u;
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+#define nhlfe_mtu		u.dst.metrics[RTAX_MTU-1]
+#else
+#define nhlfe_mtu		u.dst._metrics
+#endif
+
+	/* user configured references as opposed to the references
+	 * created by protocol drivers (ie IPv4 route cache)
+	 */
+	atomic_t		__refcnt;
+
+	struct list_head	global;
+
+	/* Generic stats						    */
+	struct gnet_stats_basic	nhlfe_stats;
+	unsigned int		nhlfe_drops;
+	/* List of notif                                                    */
+	struct notifier_block*  nhlfe_notifier_list;
+	/* List of NHLFE that are linked to this NHLFE                      */
+	struct list_head        list_out;
+	/* List of ILM that are linked to this NHLFE                        */
+	struct list_head        list_in;
+	/* To be added into a device list_out if the NHLFE uses (SET) the dev */
+	struct list_head        dev_entry;
+	/* To be added into list_out if this nhlfe uses (FWD) another NHLFE */
+	struct list_head        nhlfe_entry;
+	/* Array of instructions for this NHLFE                             */ 
+	struct mpls_instr      *nhlfe_instr;
+	/* Key to used to store/lookup a given NHLFE in the tree            */
+	unsigned int            nhlfe_key;
+	/* Age in jiffies                                                   */
+	unsigned int            nhlfe_age;
+	/* MTU Limit (e.g. from device MTU + number of pushes               */
+	unsigned short          nhlfe_mtu_limit;
+	unsigned char           nhlfe_propagate_ttl;
+};
+
+
+struct mpls_fwd_block {
+	struct notifier_block notifier_block;
+	struct mpls_nhlfe *owner;
+	struct mpls_nhlfe *fwd;
+};
+
+/****************************************************************************
+ * Output Radix Tree Management
+ ****************************************************************************/
+
+extern struct radix_tree_root mpls_nhlfe_tree;
+extern spinlock_t             mpls_nhlfe_lock;
+
+int                 mpls_nhlfe_init(void);
+void                mpls_nhlfe_exit(void);
+int                 mpls_insert_nhlfe(unsigned int, struct mpls_nhlfe*);
+struct mpls_nhlfe*  mpls_delete_nhlfe(unsigned int);
+struct mpls_nhlfe*  mpls_get_nhlfe(unsigned int);
+
+
+/****************************************************************************
+ * Helper Functions
+ ****************************************************************************/
+
+void                mpls_skb_dump(struct sk_buff* sk);
+char                mpls_find_payload(struct sk_buff* skb);
+unsigned int        mpls_label2key(const int, const struct mpls_label*);
+
+
+/****************************************************************************
+ * INCOMING (INPUT) LABELLED PACKET MANAGEMENT
+ * net/mpls/mpls_input.c
+ ****************************************************************************/
+
+int  mpls_skb_recv    (struct sk_buff *skb, struct net_device *dev,
+                              struct packet_type* ptype, struct net_device *orig);
+int  mpls_skb_recv_mc (struct sk_buff *skb, struct net_device *dev,
+                              struct packet_type* ptype, struct net_device *orig);
+
+
+/****************************************************************************
+ * OUTGOING (OUTPUT) LABELLED PACKET MANAGEMENT
+ * net/mpls/mpls_output.c
+ ****************************************************************************/
+
+struct mpls_dst {
+	union {
+		struct dst_entry	dst;
+		struct mpls_dst		*next;
+        } u;
+
+	struct sockaddr			md_nh;
+};
+
+int  mpls_bogus_output(struct sk_buff *skb);
+int  mpls_set_nexthop(struct shim_blk* blk,struct dst_entry *dst);
+int  mpls_set_nexthop2(struct mpls_nhlfe *nhlfe, struct dst_entry *dst);
+int  mpls_output(struct sk_buff *skb); 
+int  mpls_switch(struct sk_buff *skb); 
+int  mpls_output_shim (struct sk_buff *skb, struct mpls_nhlfe *nhlfe);
+int  mpls_output2(struct sk_buff *skb,struct mpls_nhlfe *nhlfe);
+
+/****************************************************************************
+ * MPLS Destination (dst) Next hop (neighbour) cache management
+ * net/mpls/mpls_dst.c
+ ****************************************************************************/
+
+int              mpls_dst_init(void);
+void             mpls_dst_exit(void);
+struct mpls_dst *mpls_dst_alloc(struct net_device *dev, struct sockaddr *nh);
+void             mpls_dst_release(struct mpls_dst *);
+
+
+/****************************************************************************
+ * INPUT/OUTPUT INSTRUCTION OPCODES 
+ * net/mpls/{mpls_opcode,mpls_opcode_in,mpls_opcode_out}.c
+ *
+ ****************************************************************************/
+ 
+/*
+ * skb:       Socket buffer. May be modified [OUT] 
+ * ilm:       ILM entry object that owns this opcode. 
+ * nhlfe:       NHLF entry to apply. May be modified (e.g. MTU) [OUT] 
+ * data:      opcode dependant data. Cast to NHLFEs, DS marks, etc.
+ */
+#define MPLS_OPCODE_PROTOTYPE(NAME) \
+int (NAME) (struct sk_buff** skb,struct mpls_ilm *ilm, \
+	struct mpls_nhlfe **nhlfe, void *data) 
+
+/*
+ * instr:     Instruction array. 
+ * direction: MPLS_IN (ILM) or MPLS_OUT(NHLFE)
+ * parent:    ILM/NHLFE parent object for opcode.
+ * data:      opcode dependant data. [OUT]
+ * last_able: Nonzero if this can be the last opcode. [OUT]
+ * num_push:  Number of pushes for this opcode. [OUT] (Incr. by OP_PUSH
+ */
+#define MPLS_BUILD_OPCODE_PROTOTYPE(NAME) \
+int (NAME) (struct mpls_instr_elem *instr, \
+	enum mpls_dir direction, void *parent,\
+        void **data, int *last_able, int *num_push)
+
+/*
+ * instr:     Instruction array. 
+ * data:      opcode dependant data. [OUT]
+ */
+#define MPLS_UNBUILD_OPCODE_PROTOTYPE(NAME) \
+int (NAME) (struct mpls_instr_elem *instr, void *data)
+
+/*
+ * data:      opcode dependant data.
+ * parent:    ILM/NHLFE parent object for opcode.
+ * direction: MPLS_IN (ILM) or MPLS_OUT(NHLFE)
+ */
+#define MPLS_CLEAN_OPCODE_PROTOTYPE(NAME) \
+void (NAME) (void *data, void *parent, enum mpls_dir direction)
+
+/*
+ * seq:       seq_file output stream. 
+ * data:      opcode dependant data.
+ * direction: MPLS_IN (ILM) or MPLS_OUT(NHLFE)
+ */
+#define MPLS_PRINT_OPCODE_PROTOTYPE(NAME) \
+void (NAME) (struct seq_file *seq, void *data, enum mpls_dir direction)
+
+#define MPLS_IN_OPCODE_PROTOTYPE(NAME)  MPLS_OPCODE_PROTOTYPE(NAME) 
+#define MPLS_OUT_OPCODE_PROTOTYPE(NAME) MPLS_OPCODE_PROTOTYPE(NAME) 
+
+struct mpls_ops {
+	MPLS_IN_OPCODE_PROTOTYPE(*in);
+	MPLS_OUT_OPCODE_PROTOTYPE(*out);
+	MPLS_BUILD_OPCODE_PROTOTYPE(*build);
+	MPLS_UNBUILD_OPCODE_PROTOTYPE(*unbuild);
+	MPLS_CLEAN_OPCODE_PROTOTYPE(*cleanup);
+	MPLS_PRINT_OPCODE_PROTOTYPE(*print);
+	int  extra;
+	char *msg;
+};
+
+/* Array holding opcodes */
+extern struct mpls_ops mpls_ops[];
+
+struct sk_buff *mpls_finish(struct sk_buff *skb);
+int    mpls_opcode_peek(struct sk_buff *skb);
+int    mpls_push(struct sk_buff **skb, struct mpls_label *label);
+
+
+/* Query/Update Incoming Labels */
+int  mpls_add_in_label        (const struct mpls_in_label_req *in);
+int  mpls_get_in_label        (struct mpls_in_label_req *in);
+void __mpls_del_in_label      (struct mpls_ilm *ilm);
+int  mpls_del_in_label        (struct mpls_in_label_req *in);
+int  mpls_set_in_label_proto  (struct mpls_in_label_req *in);
+int  mpls_add_reserved_label  (int label, struct mpls_ilm* ilm);
+struct mpls_ilm* mpls_del_reserved_label (int label);
+
+/* Query/Update Outgoing Labels */
+extern int mpls_add_out_label     (struct mpls_out_label_req *out, int seq,
+				   int pid);
+int mpls_get_out_label     (struct mpls_out_label_req *out);
+int mpls_del_out_label     (struct mpls_out_label_req *out);
+int mpls_set_out_label_mtu (struct mpls_out_label_req *out);
+
+/* Query/Update Crossconnects */
+int mpls_attach_in2out       (struct mpls_xconnect_req *req);
+int mpls_detach_in2out       (struct mpls_xconnect_req *req);
+int mpls_get_in2out          (struct mpls_xconnect_req *req);
+
+/* Instruction Management */
+int  mpls_set_in_label_instrs   (struct mpls_instr_req *mir);
+int  mpls_set_out_label_instrs  (struct mpls_instr_req *mir);
+int  mpls_set_in_instrs         (struct mpls_instr_elem *mie, 
+	int length, struct mpls_ilm *ilm);
+int  mpls_set_out_instrs        (struct mpls_instr_elem *mie, 
+	int length, struct mpls_nhlfe *nhlfe);
+int mpls_set_out_label_propagate_ttl(struct mpls_out_label_req *mol);
+
+void mpls_destroy_out_instrs    (struct mpls_nhlfe *nhlfe);
+void mpls_destroy_in_instrs     (struct mpls_ilm  *ilm);
+
+/* Query/Update Labelspaces*/
+int mpls_get_labelspace             (struct mpls_labelspace_req *req);
+int mpls_get_labelspace_by_name     (const char *name);
+int mpls_get_labelspace_by_index    (int ifindex);
+int mpls_set_labelspace             (struct mpls_labelspace_req *req);
+int mpls_set_labelspace_by_name     (const char *name, int labelspace);
+int mpls_set_labelspace_by_index    (int ifindex, int labelspace);
+
+/* Netlink event notification */
+void mpls_ilm_event(int event, struct mpls_ilm *ilm);
+void mpls_nhlfe_event(int event, struct mpls_nhlfe *nhlfe, int seq, int pid);
+void mpls_labelspace_event(int event, struct net_device *dev);
+void mpls_xc_event(int event, struct mpls_ilm *ilm,
+	struct mpls_nhlfe *nhlfe);
+
+/****************************************************************************
+ * REFERENCE COUNT MANAGEMENT 
+ ****************************************************************************/
+
+/* Hold */
+static inline struct mpls_ilm* mpls_ilm_hold(struct mpls_ilm* ilm)
+{
+	BUG_ON(!ilm);
+	dst_hold (&ilm->u.dst);
+	return ilm;
+}
+
+
+/* Release */
+static inline void mpls_ilm_release(struct mpls_ilm* ilm)
+{
+	BUG_ON(!ilm);
+	dst_release(&ilm->u.dst);
+}
+
+
+/* Hold */
+static inline struct mpls_nhlfe* mpls_nhlfe_hold(struct mpls_nhlfe* nhlfe)
+{
+	BUG_ON(!nhlfe);
+	atomic_inc(&nhlfe->__refcnt);
+	return nhlfe;
+}
+
+/* Release */
+static inline void mpls_nhlfe_release(struct mpls_nhlfe* nhlfe)
+{
+	BUG_ON(!nhlfe);
+	atomic_dec(&nhlfe->__refcnt);
+}
+
+/****************************************************************************
+ * sysctl Implementation
+ * net/mpls/sysctl_net_mpls.c
+ ****************************************************************************/
+
+int   mpls_sysctl_init(void);
+void  mpls_sysctl_exit(void);
+
+/****************************************************************************
+ * ProcFS Implementation
+ * net/mpls/mpls_procfs.c
+ ****************************************************************************/
+
+int   mpls_procfs_init(void);
+void  mpls_procfs_exit(void);
+
+/****************************************************************************
+ * Shim Implementation
+ * net/mpls/mpls_shim.c
+ ****************************************************************************/
+
+void  mpls_shim_init(void);
+void  mpls_shim_exit(void);
+
+/****************************************************************************
+ * NetLink Implementation  
+ * net/mpls/mpls_netlink.c
+ ****************************************************************************/
+
+int  mpls_netlink_init (void);
+void mpls_netlink_exit (void);
+
+/****************************************************************************
+ * Virtual Intefaces (Tunnel) Management 
+ * (e.g. mpls0, mpls1, TXXethN, etc.)
+ * net/mpls/mpls_tunnel.c
+ ****************************************************************************/
+
+struct mpls_tunnel_private {
+	/* NHLFE Object to apply to this tunnel traffic */
+	struct mpls_nhlfe             *mtp_nhlfe;
+	/* Netdevice for this tunnel                  */
+	struct net_device             *mtp_dev;
+	/* Next tunnel in list                        */
+	struct mpls_tunnel_private    *next;
+	/* Netdevice (this tunnel) traffic stats      */
+	struct net_device_stats        stat;
+};
+
+
+struct net_device* mpls_tunnel_get_by_name (const char* name);
+struct net_device* mpls_tunnel_get         (struct mpls_tunnel_req *mt);
+void               mpls_tunnel_put         (struct net_device *dev); 
+struct net_device* mpls_tunnel_create      (struct mpls_tunnel_req *mt);
+void               mpls_tunnel_destroy     (struct mpls_tunnel_req *mt); 
+
+/* Casts */
+#define _mpls_as_if(PTR)    ((struct mpls_interface*)(PTR))
+#define _mpls_as_label(PTR) ((struct mpls_label*)(PTR))
+#define _mpls_as_ilm(PTR)   ((struct mpls_ilm*)(PTR))
+#define _mpls_as_nhlfe(PTR) ((struct mpls_nhlfe*)(PTR))
+#define _mpls_as_dfi(PTR)   ((struct mpls_dsmark_fwd_info*)(PTR))
+#define _mpls_as_nfi(PTR)   ((struct mpls_nfmark_fwd_info*)(PTR))
+#define _mpls_as_efi(PTR)   ((struct mpls_exp_fwd_info*)(PTR))
+#define _mpls_as_netdev(PTR)((struct net_device*)(PTR))
+#define _mpls_as_dst(PTR)   ((struct mpls_dst*)(PTR))
+
+#endif
diff -Nur linux-3.14.1/include/net/netfilter/xt_mpls.h linux-3.14.1_mpls/include/net/netfilter/xt_mpls.h
--- linux-3.14.1/include/net/netfilter/xt_mpls.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/include/net/netfilter/xt_mpls.h	2014-04-22 17:54:01.870840935 +0530
@@ -0,0 +1,12 @@
+#ifndef _XT_MPLS_H_target
+#define _XT_MPLS_H_target
+
+struct xt_mpls_target_info {
+	u_int32_t key;
+
+	/* only used by the netfilter kernel modules */
+	void *nhlfe;
+	void *proto;
+};
+
+#endif /*_XT_MPLS_H_target */
diff -Nur linux-3.14.1/include/net/shim.h linux-3.14.1_mpls/include/net/shim.h
--- linux-3.14.1/include/net/shim.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/include/net/shim.h	2014-04-22 17:57:15.536406229 +0530
@@ -0,0 +1,45 @@
+/*
+ *	Network shim interface for protocols that live below L3 but above L2
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *	Authors:	James R. Leu <jleu@mindspring.com>
+ */
+#ifndef _NET_SHIM_H
+#define _NET_SHIM_H
+
+#include <net/dst.h>
+#include <linux/list.h>
+#include <linux/shim.h>
+
+struct shim_blk;
+
+struct shim {
+	atomic_t		refcnt;
+	struct list_head	list;
+	int			(*build)(struct shim_blk *, struct dst_entry *);
+	char			name[SHIMNAMSIZ + 1];
+};
+
+struct shim_blk {
+	struct shim *shim;
+	short datalen;
+	char data[0];
+};
+
+extern void shim_proto_add(struct shim *spec);
+extern int shim_proto_remove(struct shim *spec);
+extern struct shim *shim_proto_find_by_name(const char* name);
+extern struct shim_blk *shim_build_blk(struct rtshim* data);
+extern  void shim_destroy_blk(struct shim_blk* sblk);
+extern int shim_blk_cmp(struct shim_blk* a, struct shim_blk* b);
+extern int shim_cfg_blk_cmp(struct rtshim* data, struct shim_blk* sblk);
+extern void shim_unbuild_blk(struct rtshim* data, struct shim_blk* sblk);
+
+#define shim_proto_release(V)	atomic_dec((&V->refcnt));
+#define shim_proto_hold(V)	atomic_inc((&V->refcnt));
+
+#endif
diff -Nur linux-3.14.1/include/uapi/linux/genetlink.h linux-3.14.1_mpls/include/uapi/linux/genetlink.h
--- linux-3.14.1/include/uapi/linux/genetlink.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/uapi/linux/genetlink.h	2014-04-22 15:58:13.938188277 +0530
@@ -82,5 +82,36 @@
 
 #define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)
 
+enum {
+	MPLS_CMD_UNSPEC,
+	MPLS_CMD_NEWILM,
+	MPLS_CMD_DELILM,
+	MPLS_CMD_GETILM,
+	MPLS_CMD_NEWNHLFE,
+	MPLS_CMD_DELNHLFE,
+	MPLS_CMD_GETNHLFE,
+	MPLS_CMD_NEWXC,
+	MPLS_CMD_DELXC,
+	MPLS_CMD_GETXC,
+	MPLS_CMD_SETLABELSPACE,
+	MPLS_CMD_GETLABELSPACE,
+	__MPLS_CMD_MAX,
+};
+
+#define MPLS_CMD_MAX (__MPLS_CMD_MAX - 1)
+
+enum {
+	MPLS_ATTR_UNSPEC,
+	MPLS_ATTR_ILM,
+	MPLS_ATTR_NHLFE,
+	MPLS_ATTR_XC,
+	MPLS_ATTR_LABELSPACE,
+	MPLS_ATTR_INSTR,
+	MPLS_ATTR_STATS,
+	__MPLS_ATTR_MAX,
+};
+
+#define MPLS_ATTR_MAX (__MPLS_ATTR_MAX - 1)
+
 
 #endif /* _UAPI__LINUX_GENERIC_NETLINK_H */
diff -Nur linux-3.14.1/include/uapi/linux/if_arp.h linux-3.14.1_mpls/include/uapi/linux/if_arp.h
--- linux-3.14.1/include/uapi/linux/if_arp.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/uapi/linux/if_arp.h	2014-04-22 16:11:41.120040627 +0530
@@ -95,7 +95,7 @@
 #define ARPHRD_IP6GRE	823		/* GRE over IPv6		*/
 #define ARPHRD_NETLINK	824		/* Netlink header		*/
 #define ARPHRD_6LOWPAN	825		/* IPv6 over LoWPAN             */
-
+#define ARPHRD_MPLS_TUNNEL 899		/* MPLS Tunnel Interface	*/
 #define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
 #define ARPHRD_NONE	  0xFFFE	/* zero header length */
 
diff -Nur linux-3.14.1/include/uapi/linux/ppp_defs.h linux-3.14.1_mpls/include/uapi/linux/ppp_defs.h
--- linux-3.14.1/include/uapi/linux/ppp_defs.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/uapi/linux/ppp_defs.h	2014-04-22 16:36:14.509517613 +0530
@@ -52,7 +52,7 @@
 #define PPP_IPV6CP	0x8057	/* IPv6 Control Protocol */
 #define PPP_CCPFRAG	0x80fb	/* CCP at link level (below MP bundle) */
 #define PPP_CCP		0x80fd	/* Compression Control Protocol */
-#define PPP_MPLSCP	0x80fd	/* MPLS Control Protocol */
+#define PPP_MPLSCP	0x8281	/* MPLS Control Protocol */
 #define PPP_LCP		0xc021	/* Link Control Protocol */
 #define PPP_PAP		0xc023	/* Password Authentication Protocol */
 #define PPP_LQR		0xc025	/* Link Quality Report protocol */
diff -Nur linux-3.14.1/include/uapi/linux/rtnetlink.h linux-3.14.1_mpls/include/uapi/linux/rtnetlink.h
--- linux-3.14.1/include/uapi/linux/rtnetlink.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/uapi/linux/rtnetlink.h	2014-04-22 16:41:02.089902238 +0530
@@ -297,6 +297,7 @@
 	RTA_TABLE,
 	RTA_MARK,
 	RTA_MFC_STATS,
+	RTA_SHIM = 30,
 	__RTA_MAX
 };
 
diff -Nur linux-3.14.1/include/uapi/linux/sysctl.h linux-3.14.1_mpls/include/uapi/linux/sysctl.h
--- linux-3.14.1/include/uapi/linux/sysctl.h	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/include/uapi/linux/sysctl.h	2014-04-22 17:04:05.248513580 +0530
@@ -221,6 +221,7 @@
 	NET_LLC=18,
 	NET_NETFILTER=19,
 	NET_DCCP=20,
+	NET_MPLS=21,
 	NET_IRDA=412,
 };
 
@@ -778,6 +779,14 @@
 	NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5,
 };
 
+
+/* /proc/sys/net/mpls */
+enum
+{
+	NET_MPLS_DEBUG=1,
+	NET_MPLS_DEFAULT_TTL=2,
+};
+
 /* proc/sys/net/irda */
 enum {
 	NET_IRDA_DISCOVERY=1,
diff -Nur linux-3.14.1/kernel/sysctl_binary.c linux-3.14.1_mpls/kernel/sysctl_binary.c
--- linux-3.14.1/kernel/sysctl_binary.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/kernel/sysctl_binary.c	2014-04-23 11:13:03.275682137 +0530
@@ -293,6 +293,8 @@
 static const struct bin_table bin_net_ipv4_netfilter_table[] = {
 	{ CTL_INT,	NET_IPV4_NF_CONNTRACK_MAX,		"ip_conntrack_max" },
 
+
+
 	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT "ip_conntrack_tcp_timeout_syn_sent" no longer used */
 	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV "ip_conntrack_tcp_timeout_syn_recv" no longer used */
 	/* NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED "ip_conntrack_tcp_timeout_established" no longer used */
@@ -327,6 +329,12 @@
 	{}
 };
 
+static const struct bin_table bin_net_mpls_table[] = {
+       { CTL_INT,       NET_MPLS_DEBUG,                 "debug" },
+       { CTL_INT,       NET_MPLS_DEFAULT_TTL,           "default_ttl" },
+       {}
+};
+
 static const struct bin_table bin_net_ipv4_table[] = {
 	{CTL_INT,	NET_IPV4_FORWARD,			"ip_forward" },
 
@@ -740,6 +748,7 @@
 	{ CTL_DIR,	NET_LLC,		"llc",		bin_net_llc_table },
 	{ CTL_DIR,	NET_NETFILTER,		"netfilter",	bin_net_netfilter_table },
 	/* NET_DCCP "dccp" no longer used */
+	{ CTL_DIR,      NET_MPLS,               "mpls",         bin_net_mpls_table },
 	{ CTL_DIR,	NET_IRDA,		"irda",		bin_net_irda_table },
 	{ CTL_INT,	2089,			"nf_conntrack_max" },
 	{}
diff -Nur linux-3.14.1/net/bridge/Kconfig linux-3.14.1_mpls/net/bridge/Kconfig
--- linux-3.14.1/net/bridge/Kconfig	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/bridge/Kconfig	2014-04-22 18:12:15.789088520 +0530
@@ -33,6 +33,15 @@
 
 	  If unsure, say N.
 
+config BRIDGE_MPLS
+	tristate "Bridge: MPLS support"
+	depends on BRIDGE && MPLS
+	---help---
+	  If you say Y here, the kernel will support being an egress for
+	  Ethernet over MPLS packets
+
+	  If unsure, say N.
+
 config BRIDGE_IGMP_SNOOPING
 	bool "IGMP/MLD snooping"
 	depends on BRIDGE
diff -Nur linux-3.14.1/net/bridge/Makefile linux-3.14.1_mpls/net/bridge/Makefile
--- linux-3.14.1/net/bridge/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/bridge/Makefile	2014-04-22 18:14:07.495684178 +0530
@@ -8,6 +8,7 @@
 			br_ioctl.o br_notify.o br_stp.o br_stp_bpdu.o \
 			br_stp_if.o br_stp_timer.o br_netlink.o
 
+obj-$(CONFIG_BRIDGE_MPLS) += mplsbr.o
 bridge-$(CONFIG_SYSFS) += br_sysfs_if.o br_sysfs_br.o
 
 bridge-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
diff -Nur linux-3.14.1/net/bridge/mplsbr.c linux-3.14.1_mpls/net/bridge/mplsbr.c
--- linux-3.14.1/net/bridge/mplsbr.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/bridge/mplsbr.c	2014-05-04 18:43:01.570099350 +0530
@@ -0,0 +1,593 @@
+/* mplsbr.c: ethernet over MPLS protocol driver.
+ *
+ * Copyright (C) 2005 James R. Leu (jleu@mindspring.com)
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <net/neighbour.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+
+MODULE_LICENSE("GPL");
+
+#if 0
+#ifdef CONFIG_PROC_FS
+static const struct file_operations mpls_neigh_stat_seq_fops;
+#endif
+
+#define MY_PNEIGH_HASHMASK		0xF
+
+static struct neigh_table *mpls_neigh_tables;
+static DEFINE_RWLOCK(mpls_neigh_tbl_lock);
+
+static void *mpls_neigh_stat_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct neigh_table *tbl = seq->private;
+	int cpu;
+
+	if (*pos == 0)
+		return SEQ_START_TOKEN;
+
+	for (cpu = *pos-1; cpu < nr_cpu_ids; ++cpu) {
+		if (!cpu_possible(cpu))
+			continue;
+		*pos = cpu+1;
+		return per_cpu_ptr(tbl->stats, cpu);
+	}
+	return NULL;
+}
+
+static void *mpls_neigh_stat_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct neigh_table *tbl = seq->private;
+	int cpu;
+
+	for (cpu = *pos; cpu < nr_cpu_ids; ++cpu) {
+		if (!cpu_possible(cpu))
+			continue;
+		*pos = cpu+1;
+		return per_cpu_ptr(tbl->stats, cpu);
+	}
+	return NULL;
+}
+
+static void mpls_neigh_stat_seq_stop(struct seq_file *seq, void *v)
+{
+
+}
+
+static int mpls_neigh_stat_seq_show(struct seq_file *seq, void *v)
+{
+	struct neigh_table *tbl = seq->private;
+	struct neigh_statistics *st = v;
+
+	if (v == SEQ_START_TOKEN) {
+		seq_printf(seq, "entries  allocs destroys hash_grows  lookups hits  res_failed  rcv_probes_mcast rcv_probes_ucast  periodic_gc_runs forced_gc_runs unresolved_discards\n");
+		return 0;
+	}
+
+	seq_printf(seq, "%08x  %08lx %08lx %08lx  %08lx %08lx  %08lx  "
+			"%08lx %08lx  %08lx %08lx %08lx\n",
+		   atomic_read(&tbl->entries),
+
+		   st->allocs,
+		   st->destroys,
+		   st->hash_grows,
+
+		   st->lookups,
+		   st->hits,
+
+		   st->res_failed,
+
+		   st->rcv_probes_mcast,
+		   st->rcv_probes_ucast,
+
+		   st->periodic_gc_runs,
+		   st->forced_gc_runs,
+		   st->unres_discards
+		   );
+
+	return 0;
+}
+
+static const struct seq_operations mpls_neigh_stat_seq_ops = {
+	.start	= mpls_neigh_stat_seq_start,
+	.next	= mpls_neigh_stat_seq_next,
+	.stop	= mpls_neigh_stat_seq_stop,
+	.show	= mpls_neigh_stat_seq_show,
+};
+static struct lock_class_key mpls_neigh_table_proxy_queue_class;
+
+static int mpls_neigh_stat_seq_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &mpls_neigh_stat_seq_ops);
+
+	if (!ret) {
+		struct seq_file *sf = file->private_data;
+		sf->private = PDE_DATA(inode);
+	}
+	return ret;
+};
+
+static const struct file_operations mpls_neigh_stat_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open 	 = mpls_neigh_stat_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = seq_release,
+};
+
+static int mpls_neigh_fill_info(struct sk_buff *skb, struct neighbour *neigh,
+			   u32 pid, u32 seq, int type, unsigned int flags)
+{
+	unsigned long now = jiffies;
+	struct nda_cacheinfo ci;
+	struct nlmsghdr *nlh;
+	struct ndmsg *ndm;
+
+	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndm), flags);
+	if (nlh == NULL)
+		return -EMSGSIZE;
+
+	ndm = nlmsg_data(nlh);
+	ndm->ndm_family	 = neigh->ops->family;
+	ndm->ndm_pad1    = 0;
+	ndm->ndm_pad2    = 0;
+	ndm->ndm_flags	 = neigh->flags;
+	ndm->ndm_type	 = neigh->type;
+	ndm->ndm_ifindex = neigh->dev->ifindex;
+
+	if (nla_put(skb, NDA_DST, neigh->tbl->key_len, neigh->primary_key))
+		goto nla_put_failure;
+
+	read_lock_bh(&neigh->lock);
+	ndm->ndm_state	 = neigh->nud_state;
+	if (neigh->nud_state & NUD_VALID) {
+		char haddr[MAX_ADDR_LEN];
+
+		neigh_ha_snapshot(haddr, neigh, neigh->dev);
+		if (nla_put(skb, NDA_LLADDR, neigh->dev->addr_len, haddr) < 0) {
+			read_unlock_bh(&neigh->lock);
+			goto nla_put_failure;
+		}
+	}
+
+	ci.ndm_used	 = jiffies_to_clock_t(now - neigh->used);
+	ci.ndm_confirmed = jiffies_to_clock_t(now - neigh->confirmed);
+	ci.ndm_updated	 = jiffies_to_clock_t(now - neigh->updated);
+	ci.ndm_refcnt	 = atomic_read(&neigh->refcnt) - 1;
+	read_unlock_bh(&neigh->lock);
+
+	if (nla_put_u32(skb, NDA_PROBES, atomic_read(&neigh->probes)) ||
+	    nla_put(skb, NDA_CACHEINFO, sizeof(ci), &ci))
+		goto nla_put_failure;
+
+	return nlmsg_end(skb, nlh);
+
+nla_put_failure:
+	nlmsg_cancel(skb, nlh);
+	return -EMSGSIZE;
+}
+
+static void mpls_neigh_proxy_process(unsigned long arg)
+{
+	struct neigh_table *tbl = (struct neigh_table *)arg;
+	long sched_next = 0;
+	unsigned long now = jiffies;
+	struct sk_buff *skb, *n;
+
+	spin_lock(&tbl->proxy_queue.lock);
+
+	skb_queue_walk_safe(&tbl->proxy_queue, skb, n) {
+		long tdif = NEIGH_CB(skb)->sched_next - now;
+
+		if (tdif <= 0) {
+			struct net_device *dev = skb->dev;
+
+			__skb_unlink(skb, &tbl->proxy_queue);
+			if (tbl->proxy_redo && netif_running(dev)) {
+				rcu_read_lock();
+				tbl->proxy_redo(skb);
+				rcu_read_unlock();
+			} else {
+				kfree_skb(skb);
+			}
+
+			dev_put(dev);
+		} else if (!sched_next || tdif < sched_next)
+			sched_next = tdif;
+	}
+	del_timer(&tbl->proxy_timer);
+	if (sched_next)
+		mod_timer(&tbl->proxy_timer, jiffies + sched_next);
+	spin_unlock(&tbl->proxy_queue.lock);
+}
+
+static inline size_t mpls_neigh_nlmsg_size(void)
+{
+	return NLMSG_ALIGN(sizeof(struct ndmsg))
+	       + nla_total_size(MAX_ADDR_LEN) /* NDA_DST */
+	       + nla_total_size(MAX_ADDR_LEN) /* NDA_LLADDR */
+	       + nla_total_size(sizeof(struct nda_cacheinfo))
+	       + nla_total_size(4); /* NDA_PROBES */
+}
+
+static void __mpls_neigh_notify(struct neighbour *n, int type, int flags)
+{
+	struct net *net = dev_net(n->dev);
+	struct sk_buff *skb;
+	int err = -ENOBUFS;
+
+	skb = nlmsg_new(mpls_neigh_nlmsg_size(), GFP_ATOMIC);
+	if (skb == NULL)
+		goto errout;
+
+	err = mpls_neigh_fill_info(skb, n, 0, 0, type, flags);
+	if (err < 0) {
+		/* -EMSGSIZE implies BUG in mpls_neigh_nlmsg_size() */
+		WARN_ON(err == -EMSGSIZE);
+		kfree_skb(skb);
+		goto errout;
+	}
+	rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
+	return;
+errout:
+	if (err < 0)
+		rtnl_set_sk_err(net, RTNLGRP_NEIGH, err);
+}
+
+static void mpls_neigh_cleanup_and_release(struct neighbour *neigh)
+{
+	if (neigh->parms->neigh_cleanup)
+		neigh->parms->neigh_cleanup(neigh);
+
+	__mpls_neigh_notify(neigh, RTM_DELNEIGH, 0);
+	neigh_release(neigh);
+}
+
+static void mpls_neigh_periodic_work(struct work_struct *work)
+{
+	struct neigh_table *tbl = container_of(work, struct neigh_table, gc_work.work);
+	struct neighbour *n;
+	struct neighbour __rcu **np;
+	unsigned int i;
+	struct neigh_hash_table *nht;
+
+	NEIGH_CACHE_STAT_INC(tbl, periodic_gc_runs);
+
+	write_lock_bh(&tbl->lock);
+	nht = rcu_dereference_protected(tbl->nht,
+					lockdep_is_held(&tbl->lock));
+
+	/*
+	 *	periodically recompute ReachableTime from random function
+	 */
+
+	if (time_after(jiffies, tbl->last_rand + 300 * HZ)) {
+		struct neigh_parms *p;
+		tbl->last_rand = jiffies;
+		for (p = &tbl->parms; p; p = p->next)
+			p->reachable_time =
+				neigh_rand_reach_time(NEIGH_VAR(p, BASE_REACHABLE_TIME));
+	}
+
+	if (atomic_read(&tbl->entries) < tbl->gc_thresh1)
+		goto out;
+
+	for (i = 0 ; i < (1 << nht->hash_shift); i++) {
+		np = &nht->hash_buckets[i];
+
+		while ((n = rcu_dereference_protected(*np,
+				lockdep_is_held(&tbl->lock))) != NULL) {
+			unsigned int state;
+
+			write_lock(&n->lock);
+
+			state = n->nud_state;
+			if (state & (NUD_PERMANENT | NUD_IN_TIMER)) {
+				write_unlock(&n->lock);
+				goto next_elt;
+			}
+
+			if (time_before(n->used, n->confirmed))
+				n->used = n->confirmed;
+
+			if (atomic_read(&n->refcnt) == 1 &&
+			    (state == NUD_FAILED ||
+			     time_after(jiffies, n->used + NEIGH_VAR(n->parms, GC_STALETIME)))) {
+				*np = n->next;
+				n->dead = 1;
+				write_unlock(&n->lock);
+				mpls_neigh_cleanup_and_release(n);
+				continue;
+			}
+			write_unlock(&n->lock);
+
+next_elt:
+			np = &n->next;
+		}
+		/*
+		 * It's fine to release lock here, even if hash table
+		 * grows while we are preempted.
+		 */
+		write_unlock_bh(&tbl->lock);
+		cond_resched();
+		write_lock_bh(&tbl->lock);
+		nht = rcu_dereference_protected(tbl->nht,
+						lockdep_is_held(&tbl->lock));
+	}
+out:
+	/* Cycle through all hash buckets every BASE_REACHABLE_TIME/2 ticks.
+	 * ARP entry timeouts range from 1/2 BASE_REACHABLE_TIME to 3/2
+	 * BASE_REACHABLE_TIME.
+	 */
+	queue_delayed_work(system_power_efficient_wq, &tbl->gc_work,
+			      NEIGH_VAR(&tbl->parms, BASE_REACHABLE_TIME) >> 1);
+	write_unlock_bh(&tbl->lock);
+}
+
+static void mpls_neigh_get_hash_rnd(u32 *x)
+{
+	get_random_bytes(x, sizeof(*x));
+	*x |= 1;
+}
+static struct neigh_hash_table *mpls_neigh_hash_alloc(unsigned int shift)
+{
+	size_t size = (1 << shift) * sizeof(struct neighbour *);
+	struct neigh_hash_table *ret;
+	struct neighbour __rcu **buckets;
+	int i;
+
+	ret = kmalloc(sizeof(*ret), GFP_ATOMIC);
+	if (!ret)
+		return NULL;
+	if (size <= PAGE_SIZE)
+		buckets = kzalloc(size, GFP_ATOMIC);
+	else
+		buckets = (struct neighbour __rcu **)
+			  __get_free_pages(GFP_ATOMIC | __GFP_ZERO,
+					   get_order(size));
+	if (!buckets) {
+		kfree(ret);
+		return NULL;
+	}
+	ret->hash_buckets = buckets;
+	ret->hash_shift = shift;
+	for (i = 0; i < NEIGH_NUM_HASH_RND; i++)
+		mpls_neigh_get_hash_rnd(&ret->hash_rnd[i]);
+	return ret;
+}
+#endif
+
+static void dumb_neigh_solicit(struct neighbour *neigh,struct sk_buff *skb)
+{
+}
+
+static void dumb_neigh_error(struct neighbour *neigh,struct sk_buff *skb)
+{
+	kfree_skb(skb);
+}
+
+static int dumb_neigh_dev_xmit(struct sk_buff *skb)
+{
+	skb->dev = skb_dst(skb)->dev;
+	skb->ip_summed = CHECKSUM_NONE;
+	dev_queue_xmit(skb);
+	return 0;
+}
+
+
+static struct neigh_ops dumb_neigh_ops = {
+	.family =               AF_PACKET,
+	.solicit =              dumb_neigh_solicit,
+	.error_report =         dumb_neigh_error,
+	.output =               dumb_neigh_dev_xmit,
+	.connected_output =     dumb_neigh_dev_xmit,
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+	.hh_output =            dumb_neigh_dev_xmit,
+	.queue_xmit =           dumb_neigh_dev_xmit,
+#endif
+};
+
+static u32 dumb_neigh_hash(const void *pkey, const struct net_device *dev)
+{
+	return dev->ifindex;
+}
+
+static int dumb_neigh_constructor(struct neighbour *neigh)
+{
+	neigh->ops = &dumb_neigh_ops;
+	neigh->output = neigh->ops->output;
+	return 0;
+}
+
+static struct neigh_table dumb_tbl = {
+	.family         = AF_PACKET,
+	.entry_size     = sizeof(struct neighbour),
+	.key_len        = 4,
+	.hash           = dumb_neigh_hash,
+	.constructor    = dumb_neigh_constructor,
+	.id             = "dumb_neigh",
+
+	/* parameters are copied from ARP ... */
+	.parms = {
+		.tbl                    = &dumb_tbl,
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+		.base_reachable_time    = 30 * HZ,
+		.retrans_time           = 1 * HZ,
+		.gc_staletime           = 60 * HZ,
+		.reachable_time         = 30 * HZ,
+		.delay_probe_time       = 5 * HZ,
+		.queue_len              = 3,
+		.ucast_probes           = 3,
+		.mcast_probes           = 3,
+		.anycast_delay          = 1 * HZ,
+		.proxy_delay            = (8 * HZ) / 10,
+		.proxy_qlen             = 64,
+		.locktime               = 1 * HZ,
+#endif
+	},
+	.gc_interval    = 30 * HZ,
+	.gc_thresh1     = 128,
+	.gc_thresh2     = 512,
+	.gc_thresh3     = 1024,
+};
+
+static void mplsbr_cache_flush(struct net *net)
+{
+}
+
+static void mplsbr_set_ttl(struct sk_buff *skb, int ttl)
+{
+}
+
+static int mplsbr_get_ttl(struct sk_buff *skb)
+{
+	return 255;
+}
+
+static void mplsbr_change_dsfield(struct sk_buff *skb, int ds)
+{
+	/* 802.1q? */
+}
+
+static int mplsbr_get_dsfield(struct sk_buff *skb)
+{
+	/* 802.1q? */
+	return 0;
+}
+
+static int mplsbr_ttl_expired(struct sk_buff **skb)
+{
+	return NET_RX_DROP;
+}
+
+static int mplsbr_mtu_exceeded(struct sk_buff **skb, int mtu)
+{
+	return MPLS_RESULT_DROP;
+}
+
+static int mplsbr_local_deliver(struct sk_buff *skb)
+{
+	return NET_RX_DROP;
+}
+
+static int mplsbr_nexthop_resolve(struct neighbour **np,
+	struct sockaddr *sock_addr, struct net_device *dev)
+{
+	struct neighbour *n;
+	u32 index = dev->ifindex;
+
+	n = __neigh_lookup_errno(&dumb_tbl, &index, dev);
+	if (IS_ERR(n))
+		return PTR_ERR(n);
+
+	*np = n;
+	return 0;
+}
+
+static struct mpls_prot_driver mplsbr_driver = {
+	.name			=	"bridge",
+	.family                 =       AF_PACKET,
+	.ethertype              =       __constant_htons(ETH_P_ALL),
+	.cache_flush            =       mplsbr_cache_flush,
+	.set_ttl                =       mplsbr_set_ttl,
+	.get_ttl                =       mplsbr_get_ttl,
+	.change_dsfield         =       mplsbr_change_dsfield,
+	.get_dsfield            =       mplsbr_get_dsfield,
+	.ttl_expired            =       mplsbr_ttl_expired,
+	.mtu_exceeded		=	mplsbr_mtu_exceeded,
+	.local_deliver		=	mplsbr_local_deliver,
+	.nexthop_resolve        =       mplsbr_nexthop_resolve,
+	.owner                  =       THIS_MODULE,
+};
+
+#if 0
+static void mpls_neigh_table_init_no_netlink(struct neigh_table *tbl)
+{
+	unsigned long now = jiffies;
+	unsigned long phsize;
+
+	write_pnet(&tbl->parms.net, &init_net);
+	atomic_set(&tbl->parms.refcnt, 1);
+	tbl->parms.reachable_time =
+			  neigh_rand_reach_time(NEIGH_VAR(&tbl->parms, BASE_REACHABLE_TIME));
+
+	tbl->stats = alloc_percpu(struct neigh_statistics);
+	if (!tbl->stats)
+		panic("cannot create neighbour cache statistics");
+
+#ifdef CONFIG_PROC_FS
+	if (!proc_create_data(tbl->id, 0, init_net.proc_net_stat,
+			      &mpls_neigh_stat_seq_fops, tbl))
+		panic("cannot create neighbour proc dir entry");
+#endif
+
+	RCU_INIT_POINTER(tbl->nht, mpls_neigh_hash_alloc(3));
+
+	phsize = (MY_PNEIGH_HASHMASK + 1) * sizeof(struct pneigh_entry *);
+	tbl->phash_buckets = kzalloc(phsize, GFP_KERNEL);
+
+	if (!tbl->nht || !tbl->phash_buckets)
+		panic("cannot allocate neighbour cache hashes");
+
+	if (!tbl->entry_size)
+		tbl->entry_size = ALIGN(offsetof(struct neighbour, primary_key) +
+					tbl->key_len, NEIGH_PRIV_ALIGN);
+	else
+		WARN_ON(tbl->entry_size % NEIGH_PRIV_ALIGN);
+
+	rwlock_init(&tbl->lock);
+	INIT_DEFERRABLE_WORK(&tbl->gc_work, mpls_neigh_periodic_work);
+#if 0 /* To fix hang during rmmod */
+	queue_delayed_work(system_power_efficient_wq, &tbl->gc_work,
+			tbl->parms.reachable_time);
+#endif
+	setup_timer(&tbl->proxy_timer, mpls_neigh_proxy_process, (unsigned long)tbl);
+	skb_queue_head_init_class(&tbl->proxy_queue,
+			&mpls_neigh_table_proxy_queue_class);
+
+	tbl->last_flush = now;
+	tbl->last_rand	= now + tbl->parms.reachable_time * 20;
+}
+
+void mpls_neigh_table_init(struct neigh_table *tbl)
+{
+	struct neigh_table *tmp;
+
+	mpls_neigh_table_init_no_netlink(tbl);
+	write_lock(&mpls_neigh_tbl_lock);
+	for (tmp = mpls_neigh_tables; tmp; tmp = tmp->next) {
+		if (tmp->family == tbl->family)
+			break;
+	}
+	tbl->next	= mpls_neigh_tables;
+	mpls_neigh_tables	= tbl;
+	write_unlock(&mpls_neigh_tbl_lock);
+
+	if (unlikely(tmp)) {
+		pr_err("Registering multiple tables for family %d\n",
+		       tbl->family);
+		dump_stack();
+	}
+}
+#endif
+
+static int __init mplsbr_init(void)
+{
+	printk(KERN_ALERT "MPLS: Ethernet over MPLS support\n");
+//	mpls_neigh_table_init(&dumb_tbl);
+	return mpls_proto_add(&mplsbr_driver);
+}
+
+static void __exit mplsbr_fini(void)
+{
+      mpls_proto_remove(&mplsbr_driver);
+      printk (KERN_ALERT "MPLS: mpls_br_fini ......");
+}
+
+module_init(mplsbr_init);
+module_exit(mplsbr_fini);
diff -Nur linux-3.14.1/net/bridge/netfilter/ebt_mpls.c linux-3.14.1_mpls/net/bridge/netfilter/ebt_mpls.c
--- linux-3.14.1/net/bridge/netfilter/ebt_mpls.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/bridge/netfilter/ebt_mpls.c	2014-04-22 18:26:47.670127491 +0530
@@ -0,0 +1,124 @@
+/* This is a module which is used for redirecting packets into MPLS land. */
+
+
+/* (C) 1999-2009 James R. Leu <jleu@mindspring.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <net/mpls.h>
+#include <net/sock.h>
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_mpls.h>
+#include <linux/netfilter_bridge/ebtables.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("James R. Leu <jle@mindspring.com>");
+MODULE_DESCRIPTION("ebtables mpls module");
+
+static unsigned int
+target(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	const struct xt_mpls_target_info *mplsinfo = par->targinfo;
+	struct mpls_nhlfe *nhlfe = mplsinfo->nhlfe;
+
+	if (!skb_make_writable(skb, 0))
+		return EBT_DROP;
+
+	/* until we can pass the proto driver via mpls_output_shim
+	 * we'll let it look it up for us based on skb->protocol */
+	skb->protocol = htons(ETH_P_ALL);
+
+	/* skb->mac_len is the size of the L2 header
+	 *
+	 * allocate more headroom (size of L2 header + shim)
+	 * push the SKB the size of the L2 header so skb->data
+	 * points to the begining of the L2 header
+	 *
+	 * then
+	 *     mac_header = will point to the new header area
+	 * and
+	 *     network_header = mac_header + mac_len
+	 *
+	 * network_header is where we put the MPLS shim
+	 */
+
+	if (pskb_expand_head(skb, SKB_DATA_ALIGN(skb->mac_len+4),0,GFP_ATOMIC))
+		return EBT_DROP;
+
+	skb_push(skb, skb->data - skb_mac_header(skb));
+	skb_reset_network_header(skb);
+
+	mpls_output_shim(skb, nhlfe);
+
+	/* don't let anyone else use this frame */
+	return EBT_DROP;
+}
+
+static int
+checkentry(const struct xt_tgchk_param *par)
+{
+	struct xt_mpls_target_info *mplsinfo = par->targinfo;
+
+	mplsinfo->nhlfe = mpls_get_nhlfe(mplsinfo->key);
+	if (!mplsinfo->nhlfe) {
+		printk(KERN_WARNING "mpls: unable to find NHLFE with key %x\n",
+			mplsinfo->key);
+		return -EINVAL;
+	}
+
+	mplsinfo->proto = mpls_proto_find_by_ethertype(htons(ETH_P_ALL));
+	if (!mplsinfo->proto) {
+		printk(KERN_WARNING "mpls: unable to find ETH_P_ALL driver\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void
+destroy(const struct xt_tgdtor_param *par)
+{
+	struct xt_mpls_target_info *mplsinfo = par->targinfo;
+	struct mpls_nhlfe *nhlfe = mplsinfo->nhlfe;
+	struct mpls_prot_driver *prot = mplsinfo->proto;
+
+	if (nhlfe) {
+		mpls_nhlfe_release(nhlfe);
+		mplsinfo->nhlfe = NULL;
+	}
+
+	if (prot) {
+		mpls_proto_release(prot);
+		mplsinfo->proto = NULL;
+	}
+}
+
+static struct xt_target ebt_mpls_target __read_mostly = {
+	.name		= "mpls",
+	.family		= NFPROTO_BRIDGE,
+	.revision	= 0,
+	.checkentry	= checkentry,
+	.target		= target,
+	.destroy	= destroy,
+	.targetsize	= XT_ALIGN(sizeof(struct xt_mpls_target_info)),
+	.me		= THIS_MODULE,
+};
+
+static int __init ebt_mpls_init(void)
+{
+	return xt_register_target(&ebt_mpls_target);
+}
+
+static void __exit ebt_mpls_fini(void)
+{
+	xt_unregister_target(&ebt_mpls_target);
+}
+
+module_init(ebt_mpls_init);
+module_exit(ebt_mpls_fini);
diff -Nur linux-3.14.1/net/bridge/netfilter/Kconfig linux-3.14.1_mpls/net/bridge/netfilter/Kconfig
--- linux-3.14.1/net/bridge/netfilter/Kconfig	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/bridge/netfilter/Kconfig	2014-04-22 18:20:42.802714496 +0530
@@ -166,6 +166,15 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config BRIDGE_EBT_MPLS
+	tristate "ebt: MPLS target support"
+	depends on BRIDGE_NF_EBTABLES && MPLS
+	help
+	  This option adds the ebtables MPLS target which allows for
+	  bridging ethernets frame onto a MPLS LSP
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config BRIDGE_EBT_REDIRECT
 	tristate "ebt: redirect target support"
 	help
diff -Nur linux-3.14.1/net/bridge/netfilter/Makefile linux-3.14.1_mpls/net/bridge/netfilter/Makefile
--- linux-3.14.1/net/bridge/netfilter/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/bridge/netfilter/Makefile	2014-04-22 18:24:23.327942118 +0530
@@ -27,6 +27,7 @@
 obj-$(CONFIG_BRIDGE_EBT_ARPREPLY) += ebt_arpreply.o
 obj-$(CONFIG_BRIDGE_EBT_MARK_T) += ebt_mark.o
 obj-$(CONFIG_BRIDGE_EBT_DNAT) += ebt_dnat.o
+obj-$(CONFIG_BRIDGE_EBT_MPLS) += ebt_mpls.o
 obj-$(CONFIG_BRIDGE_EBT_REDIRECT) += ebt_redirect.o
 obj-$(CONFIG_BRIDGE_EBT_SNAT) += ebt_snat.o
 
diff -Nur linux-3.14.1/net/core/dev.c linux-3.14.1_mpls/net/core/dev.c
--- linux-3.14.1/net/core/dev.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/core/dev.c	2014-04-22 18:37:42.485895342 +0530
@@ -116,6 +116,7 @@
 #include <linux/ctype.h>
 #include <linux/if_arp.h>
 #include <linux/if_vlan.h>
+#include <net/shim.h>
 #include <linux/ip.h>
 #include <net/ip.h>
 #include <linux/ipv6.h>
diff -Nur linux-3.14.1/net/core/dst.c linux-3.14.1_mpls/net/core/dst.c
--- linux-3.14.1/net/core/dst.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/core/dst.c	2014-04-25 19:25:33.332859581 +0530
@@ -162,7 +162,7 @@
 void *dst_alloc(struct dst_ops *ops, struct net_device *dev,
 		int initial_ref, int initial_obsolete, unsigned short flags)
 {
-	struct dst_entry *dst;
+	struct dst_entry *dst = NULL;
 
 	if (ops->gc && dst_entries_get_fast(ops) > ops->gc_thresh) {
 		if (ops->gc(ops))
diff -Nur linux-3.14.1/net/core/Makefile linux-3.14.1_mpls/net/core/Makefile
--- linux-3.14.1/net/core/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/core/Makefile	2014-04-22 18:30:22.491426822 +0530
@@ -9,7 +9,7 @@
 
 obj-y		     += dev.o ethtool.o dev_addr_lists.o dst.o netevent.o \
 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
-			sock_diag.o dev_ioctl.o
+			sock_diag.o dev_ioctl.o shim.o
 
 obj-$(CONFIG_XFRM) += flow.o
 obj-y += net-sysfs.o
diff -Nur linux-3.14.1/net/core/shim.c linux-3.14.1_mpls/net/core/shim.c
--- linux-3.14.1/net/core/shim.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/core/shim.c	2014-04-23 14:13:28.663588581 +0530
@@ -0,0 +1,344 @@
+/*
+ *      Network shim interface for protocols that live below L3 and above L2
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *	Heavily borrowed from dev_remove_pack/dev_add_pack
+ *
+ *	Authors:	James R. Leu <jleu@mindspring.com>
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+#include <linux/list.h>
+#include <net/shim.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+spinlock_t shim_proto_lock = SPIN_LOCK_UNLOCKED;
+#else
+spinlock_t shim_proto_lock = __SPIN_LOCK_UNLOCKED(shim_proto_lock);
+#endif
+struct list_head shim_proto_list;
+
+/**
+ *	shim_proto_add - add a shim protocol handler
+ *	@shim: shim declaration
+ *
+ * 	Add a shim protocol handler to the networking stack.  The
+ *	passed &shim is linked into the kernel list and may not be
+ *	freed until it has been removed from the kernel list.
+ *
+ *	This call does not sleep therefore is can not guarantee all
+ *	CPU's that are in middle of processing packets will see the
+ *	new shim handler (until they process another packet)
+ */
+
+void shim_proto_add(struct shim *shim)
+{
+	spin_lock_bh(&shim_proto_lock);
+
+	atomic_set(&shim->refcnt, 1);
+	list_add_rcu(&shim->list, &shim_proto_list);
+
+	spin_unlock_bh(&shim_proto_lock);
+}
+
+/**
+ *	shim_proto_remove - remove a shim protocol handler
+ *	@shim: shim declaration
+ *
+ *	Remove a shim handler that was previously added to the
+ *	kernels list of shim handlers by shim_proto_add().  The
+ *	pass &shim is removed from the kernels list and can be freed
+ *	or reused once this function returns.
+ *
+ *	This call sleeps to guarantee that no CPU is looking at the
+ *	special nexthop handler after return.
+ */
+
+int shim_proto_remove(struct shim *shim)
+{
+	struct shim *shim1;
+	int retval = -EPROTONOSUPPORT;
+
+	spin_lock_bh(&shim_proto_lock);
+
+	list_for_each_entry(shim1, &shim_proto_list, list) {
+		if (shim == shim1) {
+			if (atomic_read(&shim->refcnt) != 1) {
+				retval = -EADDRINUSE;
+			} else {
+				list_del_rcu(&shim->list);
+				retval = 0;
+			}
+			break;
+		}
+	}
+	spin_unlock_bh(&shim_proto_lock);
+
+	synchronize_net();
+	return retval;
+}
+
+/**
+ *	shim_proto_find_by_name - find a shim handler by it's registered name
+ *	@name: protocol name
+ *
+ *	Search the kernels list of shim handlers looking for
+ *	a handler with this specific name
+ */
+struct shim *shim_proto_find_by_name(const char *name)
+{
+	struct shim *shim;
+
+	spin_lock_bh(&shim_proto_lock);
+
+	list_for_each_entry(shim, &shim_proto_list, list) {
+		if (!strncmp(name, shim->name, SHIMNAMSIZ)) {
+			shim_proto_hold(shim);
+			goto out;
+		}
+	}
+	shim = NULL;
+out:
+	spin_unlock_bh(&shim_proto_lock);
+
+	return shim;
+}
+
+/*
+ * Shim block utilities
+ */
+
+/**
+ *	shim_build_blk - allocate memory for a shim blk and fill it with data
+ *			 from rta
+ *	@rta: data describing shim
+ *
+ *	Allocate a shim blk which links directly to the shim
+ *	proto for use by the forwarding plane
+ */
+struct shim_blk *shim_build_blk(struct rtshim* rta)
+{
+	struct shim_blk *sblk;
+
+	if (!rta)
+		return NULL;
+
+	sblk = kmalloc(sizeof(*sblk) + rta->datalen, GFP_ATOMIC);
+	if (sblk) {
+		sblk->shim = shim_proto_find_by_name(rta->name);
+		if (sblk->shim) {
+			sblk->datalen = rta->datalen;
+			memcpy(sblk->data, rta->data, rta->datalen);
+			return sblk;
+		}
+		kfree (sblk);
+	}
+	return NULL;
+}
+
+/**
+ *	shim_destroy_blk - free memory a refcnts used bt a shim blk
+ *	@sblk: shim blk
+ *
+ *	Release ref to shim proto and free memory
+ */
+void shim_destroy_blk(struct shim_blk *sblk)
+{
+	shim_proto_release(sblk->shim);
+	kfree(sblk);
+}
+
+/**
+ *	shim_unbuild_blk - copy data from various parts of a shim block
+ *			   into a form which can be used by netlink
+ *	@rta: contigous destination memory of size rtshim + datalen
+ *	@sblk: active shim blk
+ *
+ *	Search the kernels list of shim handlers looking for
+ *	a handler with this specific name
+ */
+void shim_unbuild_blk(struct rtshim* rta, struct shim_blk *sblk)
+{
+	rta->datalen = sblk->datalen;
+	memcpy(rta->data, sblk->data, sblk->datalen);
+	strncpy(rta->name, sblk->shim->name, SHIMNAMSIZ);
+}
+
+/**
+ *	shim_rta_blk_cmp - compare config info with an active shim blk
+ *	@rta: config data
+ *	@sblk: shim blk
+ *
+ *	Used for comparing new config data with existing shim blks
+ */
+int shim_cfg_blk_cmp(struct rtshim *a, struct shim_blk *b)
+{
+	int n = 0;
+	if (a && b) {
+		if (!(n = strncmp(a->name, b->shim->name, SHIMNAMSIZ)))
+		    n = memcmp(a->data, b->data, a->datalen);
+	} else {
+		if (a) n = 1;
+		if (b) n = -1;
+	}
+	return n;
+}
+
+/**
+ *	shim_blk_cmp - compare two active shim blks
+ *	@a: shim blk
+ *	@b: shim blk
+ *
+ *	Used for comparing two existing shim blks
+ */
+int shim_blk_cmp(struct shim_blk *a, struct shim_blk *b)
+{
+	int n = 0;
+	if (a && b) {
+		if (!(n = strncmp(a->shim->name, b->shim->name, SHIMNAMSIZ)))
+		    n = memcmp(a->data, b->data, a->datalen);
+	} else {
+		if (a) n = 1;
+		if (b) n = -1;
+	}
+	return n;
+}
+
+#ifdef CONFIG_PROC_FS
+static struct shim *shim_skip(struct shim *shim)
+{
+	struct shim *shim1;
+	int next = 0;
+
+	if (!shim)
+		next = 1;
+		
+	list_for_each_entry(shim1, &shim_proto_list, list) {
+		if (next)
+			return shim1;
+
+		if (shim1 == shim)
+			next = 1;
+	}
+
+	return NULL;
+}
+
+static void *shim_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct shim *shim;
+	loff_t i = 1;
+
+	spin_lock_bh(&shim_proto_lock);
+
+	if (*pos == 0)
+		return SEQ_START_TOKEN;
+
+	for (shim = shim_skip(NULL); shim && i < *pos;
+		shim = shim_skip(shim), ++i);
+										
+	return (i == *pos) ? shim : NULL;
+}
+
+static void *shim_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	++*pos;
+										
+	return shim_skip((v == SEQ_START_TOKEN)
+			    ? NULL
+			    : (struct shim *)v);
+}
+										
+static void shim_seq_stop(struct seq_file *seq, void *v)
+{
+	spin_unlock_bh(&shim_proto_lock);
+}
+
+static int shim_seq_show(struct seq_file *seq, void *v)
+{
+	struct shim* shim = (struct shim*)v;
+	if (v != SEQ_START_TOKEN)
+		seq_printf(seq, "%s\t%d\n",
+		    shim->name ? shim->name : "(none)",
+		    atomic_read(&shim->refcnt));
+	return 0;
+}
+
+static struct seq_operations shim_seq_ops = {
+	.start = shim_seq_start,
+	.next = shim_seq_next,
+	.stop = shim_seq_stop,
+	.show = shim_seq_show,
+};
+										
+static int shim_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &shim_seq_ops);
+}
+										
+static struct file_operations shim_seq_fops = {
+	.owner   = THIS_MODULE,
+	.open    = shim_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+
+static int __net_init shim_proc_net_init(struct net *net)
+{
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+	if (!proc_net_fops_create(net, "shim",  S_IRUGO, &shim_seq_fops))
+#else
+	if (!proc_create("shim", S_IRUGO, NULL, &shim_seq_fops))
+#endif
+	    return -ENOMEM;
+	return 0;
+}
+
+static void __net_exit shim_proc_net_exit(struct net *net)
+{
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+	proc_net_remove(net, "shim");
+#else
+	remove_proc_entry("shim", NULL);
+#endif
+}
+
+static struct pernet_operations __net_initdata shim_proc_ops = {
+	.init = shim_proc_net_init,
+	.exit = shim_proc_net_exit,
+};
+
+static int __init shim_proc_init(void)
+{
+	return register_pernet_subsys(&shim_proc_ops);
+}
+#else
+#define shim_proc_init() 0
+#endif
+
+static int __init shim_init(void)
+{
+	printk("NET: shim interface - <jleu@mindspring.com>\n");
+	INIT_LIST_HEAD(&shim_proto_list);
+	if (shim_proc_init())
+	    return -ENOMEM;
+	return 0;
+}
+
+subsys_initcall(shim_init);
+
+EXPORT_SYMBOL(shim_proto_add);
+EXPORT_SYMBOL(shim_proto_remove);
+EXPORT_SYMBOL(shim_build_blk);
+EXPORT_SYMBOL(shim_destroy_blk);
diff -Nur linux-3.14.1/net/ipv4/fib_frontend.c linux-3.14.1_mpls/net/ipv4/fib_frontend.c
--- linux-3.14.1/net/ipv4/fib_frontend.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/fib_frontend.c	2014-04-22 19:39:09.411544410 +0530
@@ -531,6 +531,7 @@
 	[RTA_METRICS]		= { .type = NLA_NESTED },
 	[RTA_MULTIPATH]		= { .len = sizeof(struct rtnexthop) },
 	[RTA_FLOW]		= { .type = NLA_U32 },
+	[RTA_SHIM]		= { .len = sizeof(struct rtshim) },
 };
 
 static int rtm_to_fib_config(struct net *net, struct sk_buff *skb,
@@ -596,6 +597,9 @@
 		case RTA_TABLE:
 			cfg->fc_table = nla_get_u32(attr);
 			break;
+		case RTA_SHIM:
+			memcpy(&cfg->fc_shim, nla_data(attr), nla_len(attr));
+			break;
 		}
 	}
 
diff -Nur linux-3.14.1/net/ipv4/fib_semantics.c linux-3.14.1_mpls/net/ipv4/fib_semantics.c
--- linux-3.14.1/net/ipv4/fib_semantics.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/fib_semantics.c	2014-04-22 20:32:58.174953357 +0530
@@ -42,6 +42,7 @@
 #include <net/ip_fib.h>
 #include <net/netlink.h>
 #include <net/nexthop.h>
+#include <net/shim.h>
 
 #include "fib_lookup.h"
 
@@ -203,8 +204,13 @@
 	struct fib_info *fi = container_of(head, struct fib_info, rcu);
 
 	change_nexthops(fi) {
+		if (nexthop_nh->nh_shim)
+			shim_destroy_blk(nexthop_nh->nh_shim);
 		if (nexthop_nh->nh_dev)
 			dev_put(nexthop_nh->nh_dev);
+#if 0 /* Need to check if required */
+		nexthop_nh->nh_shim = NULL;
+#endif
 		if (nexthop_nh->nh_exceptions)
 			free_nh_exceptions(nexthop_nh);
 		rt_fibinfo_free_cpus(nexthop_nh->nh_pcpu_rth_output);
@@ -265,6 +271,7 @@
 #ifdef CONFIG_IP_ROUTE_CLASSID
 		    nh->nh_tclassid != onh->nh_tclassid ||
 #endif
+		    shim_blk_cmp(nh->nh_shim, onh->nh_shim) ||
 		    ((nh->nh_flags ^ onh->nh_flags) & ~RTNH_F_DEAD))
 			return -1;
 		onh++;
@@ -491,6 +498,8 @@
 			if (nexthop_nh->nh_tclassid)
 				fi->fib_net->ipv4.fib_num_tclassid_users++;
 #endif
+			nla = nla_find(attrs, attrlen, RTA_SHIM);
+			nexthop_nh->nh_shim = nla ? shim_build_blk(nla_data(nla)):NULL;
 		}
 
 		rtnh = rtnh_next(rtnh, &remaining);
@@ -513,6 +522,7 @@
 
 	if (cfg->fc_oif || cfg->fc_gw) {
 		if ((!cfg->fc_oif || cfg->fc_oif == fi->fib_nh->nh_oif) &&
+		    (!cfg->fc_shim.datalen || shim_cfg_blk_cmp(&cfg->fc_shim, fi->fib_nh->nh_shim) == 0) &&
 		    (!cfg->fc_gw  || cfg->fc_gw == fi->fib_nh->nh_gw))
 			return 0;
 		return 1;
@@ -546,6 +556,9 @@
 			if (nla && nla_get_u32(nla) != nh->nh_tclassid)
 				return 1;
 #endif
+			nla = nla_find(attrs, attrlen, RTA_SHIM);
+			if (nla && shim_cfg_blk_cmp(nla_data(nla), nh->nh_shim))
+				return 1;
 		}
 
 		rtnh = rtnh_next(rtnh, &remaining);
@@ -875,6 +888,8 @@
 			goto err_inval;
 		if (cfg->fc_gw && fi->fib_nh->nh_gw != cfg->fc_gw)
 			goto err_inval;
+		if (cfg->fc_shim.datalen && shim_cfg_blk_cmp(&cfg->fc_shim, fi->fib_nh->nh_shim))
+			goto err_inval;
 #ifdef CONFIG_IP_ROUTE_CLASSID
 		if (cfg->fc_flow && fi->fib_nh->nh_tclassid != cfg->fc_flow)
 			goto err_inval;
@@ -896,10 +911,15 @@
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 		nh->nh_weight = 1;
 #endif
+		if (cfg->fc_shim.datalen) {
+			nh->nh_shim = shim_build_blk(&cfg->fc_shim);
+			if (!nh->nh_shim)
+				goto err_inval;
+		}
 	}
 
 	if (fib_props[cfg->fc_type].error) {
-		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp)
+		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp || cfg->fc_shim.datalen)
 			goto err_inval;
 		goto link_it;
 	} else {
@@ -1044,6 +1064,16 @@
 		    nla_put_u32(skb, RTA_FLOW, fi->fib_nh[0].nh_tclassid))
 			goto nla_put_failure;
 #endif
+		if (fi->fib_nh->nh_shim) {
+			struct nlattr *nla = nla_reserve(skb, RTA_SHIM,
+				sizeof(struct rtshim) +
+				fi->fib_nh->nh_shim->datalen);
+			struct rtshim *shim = nla_data(nla);
+			if (nla == NULL)
+				goto nla_put_failure;
+
+			shim_unbuild_blk(shim, fi->fib_nh->nh_shim);
+		}
 	}
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 	if (fi->fib_nhs > 1) {
@@ -1071,6 +1101,16 @@
 			    nla_put_u32(skb, RTA_FLOW, nh->nh_tclassid))
 				goto nla_put_failure;
 #endif
+			if (nh->nh_shim) {
+				struct nlattr *nla = nla_reserve(skb, RTA_SHIM,
+					sizeof(struct rtshim) +
+					nh->nh_shim->datalen);
+				struct rtshim *shim = nla_data(nla);
+				if (nla == NULL)
+					goto nla_put_failure;
+
+				shim_unbuild_blk(shim, nh->nh_shim);
+			}
 			/* length of rtnetlink header + attributes */
 			rtnh->rtnh_len = nlmsg_get_pos(skb) - (void *) rtnh;
 		} endfor_nexthops(fi);
diff -Nur linux-3.14.1/net/ipv4/ip_input.c linux-3.14.1_mpls/net/ipv4/ip_input.c
--- linux-3.14.1/net/ipv4/ip_input.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/ip_input.c	2014-04-23 10:51:10.496186011 +0530
@@ -462,3 +462,4 @@
 out:
 	return NET_RX_DROP;
 }
+EXPORT_SYMBOL(ip_rcv);
diff -Nur linux-3.14.1/net/ipv4/ip_output.c linux-3.14.1_mpls/net/ipv4/ip_output.c
--- linux-3.14.1/net/ipv4/ip_output.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/ip_output.c	2014-04-22 20:36:16.604458760 +0530
@@ -177,6 +177,11 @@
 	} else if (rt->rt_type == RTN_BROADCAST)
 		IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUTBCAST, skb->len);
 
+	if (dst->child) {
+		skb_dst_set(skb, skb_dst_pop(skb));
+		return dst_output(skb);
+	}
+
 	/* Be paranoid, rather than too clever. */
 	if (unlikely(skb_headroom(skb) < hh_len && dev->header_ops)) {
 		struct sk_buff *skb2;
diff -Nur linux-3.14.1/net/ipv4/Kconfig linux-3.14.1_mpls/net/ipv4/Kconfig
--- linux-3.14.1/net/ipv4/Kconfig	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/Kconfig	2014-04-22 19:13:49.518652051 +0530
@@ -160,6 +160,15 @@
 	  operating on your network. Read
 	  <file:Documentation/filesystems/nfs/nfsroot.txt> for details.
 
+config IP_MPLS
+	tristate "IP: MPLS support"
+	depends on INET && MPLS
+	---help---
+	  If you say Y here, the kernel will support being an ingress and
+	  egress LER for IPv4 packets
+
+	  If unsure, say N.
+
 config NET_IPIP
 	tristate "IP: tunneling"
 	select INET_TUNNEL
diff -Nur linux-3.14.1/net/ipv4/Makefile linux-3.14.1_mpls/net/ipv4/Makefile
--- linux-3.14.1/net/ipv4/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/Makefile	2014-04-22 19:16:26.932673089 +0530
@@ -34,6 +34,7 @@
 obj-$(CONFIG_INET_XFRM_MODE_TRANSPORT) += xfrm4_mode_transport.o
 obj-$(CONFIG_INET_XFRM_MODE_TUNNEL) += xfrm4_mode_tunnel.o
 obj-$(CONFIG_IP_PNP) += ipconfig.o
+obj-$(CONFIG_IP_MPLS) += mpls4.o
 obj-$(CONFIG_NETFILTER)	+= netfilter.o netfilter/
 obj-$(CONFIG_INET_DIAG) += inet_diag.o 
 obj-$(CONFIG_INET_TCP_DIAG) += tcp_diag.o
diff -Nur linux-3.14.1/net/ipv4/mpls4.c linux-3.14.1_mpls/net/ipv4/mpls4.c
--- linux-3.14.1/net/ipv4/mpls4.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/mpls4.c	2014-05-05 16:03:55.075182407 +0530
@@ -0,0 +1,424 @@
+/* mpls4.c: IPv4 MPLS protocol driver.
+ *
+ * Copyright (C) 2003 David S. Miller (davem@redhat.com)
+ *
+ * Changes:
+ *	JLEU: 	Add ICMP handling
+ *		Add nexthop printing
+ *		Change nexthop resolve signature
+ *	JLEU:	Added mpls4_cache_flush()
+ *	JLEU:	un/register reserved labels in fini/init
+ *	JLEU:	removed sysfs print routin
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <net/dsfield.h>
+#include <net/neighbour.h>
+#include <net/route.h>
+#include <net/ip.h>
+#include <net/mpls.h>
+#include <net/icmp.h>
+#include <net/checksum.h>
+#include <net/arp.h>
+
+MODULE_LICENSE("GPL");
+
+
+static void mpls4_cache_flush(struct net *net)
+{
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+	rt_cache_flush(net, 0);
+#else
+/* Commented for linking issue */
+	rt_cache_flush(net);
+#endif
+}
+
+static void mpls4_set_ttl(struct sk_buff *skb, int ttl)
+{
+	ip_hdr(skb)->ttl = ttl;
+	ip_send_check(ip_hdr(skb));
+}
+
+static int mpls4_get_ttl(struct sk_buff *skb)
+{
+	return ip_hdr(skb)->ttl;
+}
+
+static void mpls4_change_dsfield(struct sk_buff *skb, int ds)
+{
+	ipv4_change_dsfield(ip_hdr(skb), 0x3, ds << 2);
+}
+
+static int mpls4_get_dsfield(struct sk_buff *skb)
+{
+	return ipv4_get_dsfield(ip_hdr(skb)) >> 2;
+}
+
+struct mpls_icmp_common {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8    res1:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8    version:4,
+		res1:4;
+#else
+#error  "Please fix <asm/byteorder.h>"
+#endif
+	__u8	res2;
+	__u16	check;
+};
+
+struct mpls_icmp_object {
+	__u16	length;
+	__u8	class;
+	__u8	type;
+};
+
+/* we can probably used a modified ip_append_data to build this */
+static struct sk_buff*
+mpls4_build_icmp(struct sk_buff *skb, int type, unsigned int icmp_data,
+	int mpls)
+{
+	unsigned char buf[576];
+
+	struct icmphdr *icmph;
+	struct sk_buff *nskb;
+	unsigned char *data;
+	struct rtable *rt;
+	struct iphdr *iph;
+
+	unsigned int icmp_start = 0;
+	unsigned int len = 0;
+	unsigned int real;
+	unsigned int max;
+	unsigned int height;
+	int pull;
+
+	/* find the distance to the bottom of the MPLS stack */
+	pull = mpls_find_payload(skb);
+	if (pull < 0)
+		goto error_0;
+
+	if (!skb_pull(skb, pull))
+		goto error_0;
+
+	height = skb->data - MPLSCB(skb)->top_of_stack;
+
+	/* now where at the payload, for now we're
+	 * assuming this is IPv4
+	 */
+	skb_reset_network_header(skb);
+
+	/* buid a new skb, that will be big enough to hold
+	 * a maximum of 576 bytes (RFC792)
+	 */
+	if ((skb->len + skb_tailroom(skb)) < 576) {
+		nskb = skb_copy_expand(skb, skb_headroom(skb),
+			(576 + 16) - skb->len, GFP_ATOMIC);
+	} else {
+		nskb = skb_copy(skb, GFP_ATOMIC);
+	}
+
+	if (!nskb)
+		goto error_0;
+
+	/* I don't handle IP options */
+	if (ip_hdr(nskb)->ihl > 5) {
+		printk("Options!!!!\n");
+		goto error_1;
+	}
+
+	memset(buf, 0, sizeof(buf));
+
+	/* point to the buf, we'll build our ICMP message there
+	 * then copy to nskb when we're done
+	 */
+	iph = (struct iphdr*)&buf[len];
+	iph->version = 4;
+	iph->ihl = 5;
+	iph->tos = ip_hdr(nskb)->tos;
+	iph->tot_len = 0;
+	iph->id = 0;
+	iph->frag_off = 0;
+	iph->ttl = sysctl_mpls_default_ttl;
+	iph->protocol = IPPROTO_ICMP;
+	iph->check = 0;
+	iph->saddr = ip_hdr(nskb)->daddr;
+	iph->daddr = ip_hdr(nskb)->saddr;
+	len += sizeof(struct iphdr);
+
+	icmp_start = len;
+ 	icmph = (struct icmphdr*)&buf[len];
+	icmph->checksum = 0;
+	icmph->un.gateway = icmp_data;
+
+	switch (type) {
+		case ICMP_TIME_EXCEEDED:
+			icmph->type = ICMP_TIME_EXCEEDED;
+			icmph->code = ICMP_EXC_TTL;
+			break;
+		case ICMP_DEST_UNREACH:
+			icmph->type = ICMP_DEST_UNREACH;
+			icmph->code = ICMP_FRAG_NEEDED;
+			break;
+		default:
+			BUG_ON(1);
+			break;
+	}
+	len += sizeof(struct icmphdr);
+
+ 	data = &buf[len];
+	if (mpls) {
+		max = 128;
+	} else {
+		max = 576 - len;
+	}
+	real = (nskb->len > max) ? max : skb->len;
+	memcpy(data, nskb->data, real);
+
+	if (!mpls) {
+		len += real;
+	} else {
+		struct mpls_icmp_common *common;
+		struct mpls_icmp_object *object;
+		unsigned char *mpls_data = NULL;
+		unsigned int obj_start = 0;
+		unsigned int mpls_start = 0;
+
+		len += 128;
+
+		mpls_start = len;
+		common = (struct mpls_icmp_common*)&buf[len];
+		common->version = 2;
+		common->res1 = 0;
+		common->res2 = 0;
+		common->check = 0;
+		len += sizeof(struct mpls_icmp_common);
+
+		obj_start = len;
+		object = (struct mpls_icmp_object*)&buf[len];
+		object->length = 0;
+		object->class = 1;
+		object->type = 1;
+		len += sizeof(struct mpls_icmp_object);
+
+		mpls_data = &buf[len];
+		memcpy(mpls_data, MPLSCB(skb)->top_of_stack, height);
+		len += height;
+
+		object->length = htons(len - obj_start);
+		common->check = csum_fold (csum_partial ((char*)common,
+			len - mpls_start, 0));
+	}
+
+	iph->tot_len = htons(len);
+	ip_send_check(iph);
+	icmph->checksum = csum_fold (csum_partial ((char*)icmph,
+		len - icmp_start, 0));
+
+	nskb->len = len;
+	memcpy(nskb->data, buf, nskb->len);
+	nskb->tail = nskb->data + nskb->len;
+
+	nskb->ip_summed = CHECKSUM_NONE;
+	nskb->csum = 0;
+
+	{
+		struct flowi fl = {
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+			.nl_u = { .ip4_u = {
+					.daddr = iph->daddr,
+					.saddr = iph->saddr,
+					.tos = RT_TOS(iph->tos) } },
+			.proto = IPPROTO_ICMP };
+#else
+			.u = { .ip4 = {
+					.daddr = iph->daddr,
+					.saddr = iph->saddr,
+					.flowi4_tos = RT_TOS(iph->tos) } },
+			.flowi_proto = IPPROTO_ICMP };
+#endif
+
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+		if (ip_route_output_key(&init_net, &rt, &fl))
+#else
+		if (ip_route_output_key(&init_net, &fl))
+#endif
+			goto error_1;
+	}
+
+	if (skb_dst(nskb))
+		dst_release(skb_dst(nskb));
+
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+	skb_dst_set(nskb, &rt->u.dst);
+#else
+	skb_dst_set(nskb, &rt->dst);
+#endif
+
+	return nskb;
+
+error_1:
+	kfree_skb(nskb);
+error_0:
+	return NULL;
+}
+
+/* Policy decision, several options:
+ *
+ * 1) Silently discard
+ * 2) Pops all MPLS headers, use resulting upper-layer
+ *    protocol packet to generate ICMP.
+ * 3) Walk down MPLS headers to upper-layer header,
+ *    generate ICMP using that and then prepend
+ *    IDENTICAL MPLS header stack to ICMP packet.
+ *
+ * Problem with #2 is that there may be no route to
+ * upper-level packet source for us to use.  (f.e. we
+ * are switching VPN packets that we have no routes to).
+ *
+ * Option #3 should work even in those cases, because it
+ * is more likely that egress of this MPLS path knows how
+ * to route such packets back to source.  It should also
+ * not be susceptible to loops in MPLS fabric, since one
+ * never responds to ICMP with ICMP.  It is deliberate
+ * assumption made about upper-layer protocol.
+ */
+static int mpls4_ttl_expired(struct sk_buff **skb)
+{
+	struct sk_buff *nskb;
+
+	if ((nskb = mpls4_build_icmp(*skb, ICMP_TIME_EXCEEDED, 0, 1)))
+		if (dst_output(nskb))
+			kfree_skb(nskb);
+
+	/* make sure the MPLS stack frees the original skb! */
+	return NET_RX_DROP;
+}
+
+static int mpls4_mtu_exceeded(struct sk_buff **skb, int mtu)
+{
+	struct sk_buff *nskb;
+
+	if ((nskb = mpls4_build_icmp(*skb, ICMP_DEST_UNREACH, htonl(mtu), 0)))
+		if (dst_output(nskb))
+			kfree_skb(nskb);
+
+	/* make sure the MPLS stack frees the original skb! */
+	return MPLS_RESULT_DROP;
+}
+
+static int mpls4_local_deliver(struct sk_buff *skb)
+{
+	skb->protocol = htons(ETH_P_IP);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	dst_release(skb_dst(skb));
+	skb_dst_set(skb, NULL);
+	return ip_rcv(skb, skb->dev, NULL, skb->dev);
+}
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+#if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
+extern struct neigh_table *clip_tbl_hook;
+#endif
+#else
+#endif
+
+static int mpls4_nexthop_resolve(struct neighbour **np, struct sockaddr *sock_addr, struct net_device *dev)
+{
+	struct sockaddr_in *addr = (struct sockaddr_in *) sock_addr;
+	struct neighbour *n;
+	u32 nexthop;
+
+	if (addr->sin_family == AF_INET) {
+		nexthop = addr->sin_addr.s_addr;
+	} else if (!addr->sin_family) {
+		nexthop = 0;
+	} else {
+	        return -EINVAL;
+	}
+
+	n = __neigh_lookup_errno(
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+#if defined(CONFIG_ATM_CLIP) || defined(CONFIG_ATM_CLIP_MODULE)
+		dev->type == ARPHRD_ATM ? clip_tbl_hook :
+#endif
+#else
+#endif
+		&arp_tbl, &nexthop, dev);
+
+	if (IS_ERR(n))
+	    return PTR_ERR(n);
+
+	*np = n;
+	return 0;
+}
+
+static struct mpls_prot_driver mpls4_driver = {
+	.name			=	"ipv4",
+	.family                 =       AF_INET,
+	.ethertype              =       __constant_htons(ETH_P_IP),
+	.cache_flush            =       mpls4_cache_flush,
+	.set_ttl                =       mpls4_set_ttl,
+	.get_ttl                =       mpls4_get_ttl,
+	.change_dsfield         =       mpls4_change_dsfield,
+	.get_dsfield            =       mpls4_get_dsfield,
+	.ttl_expired            =       mpls4_ttl_expired,
+	.mtu_exceeded		=	mpls4_mtu_exceeded,
+	.local_deliver		=	mpls4_local_deliver,
+	.nexthop_resolve        =       mpls4_nexthop_resolve,
+	.owner                  =       THIS_MODULE,
+};
+
+static int __init mpls4_init(void)
+{
+	struct mpls_instr_elem instr[2];
+	struct mpls_label ml;
+	struct mpls_ilm *ilm;
+	int result = mpls_proto_add(&mpls4_driver);
+
+	printk("MPLS: IPv4 over MPLS support\n");
+
+	if (result)
+		return result;
+
+	ml.ml_type = MPLS_LABEL_GEN;
+	ml.u.ml_gen = MPLS_IPV4_EXPLICIT_NULL;
+
+	instr[0].mir_direction = MPLS_IN;
+	instr[0].mir_opcode    = MPLS_OP_POP;
+	instr[1].mir_direction = MPLS_IN;
+	instr[1].mir_opcode    = MPLS_OP_DLV;
+
+	ilm = mpls_ilm_dst_alloc(0, &ml, AF_INET, instr, 2);
+	if (!ilm)
+	{
+		return -ENOMEM;
+	}
+
+	result = mpls_add_reserved_label(MPLS_IPV4_EXPLICIT_NULL, ilm);
+	if (result) {
+		ilm->u.dst.obsolete = 1;
+		dst_free(&ilm->u.dst);
+		return result;
+	}
+
+	return 0;
+}
+
+static void __exit mpls4_fini(void)
+{
+	struct mpls_ilm *ilm = mpls_del_reserved_label(MPLS_IPV4_EXPLICIT_NULL);
+        if (ilm) {
+                __mpls_del_in_label(ilm);
+        }
+	mpls_proto_remove(&mpls4_driver);
+}
+
+module_init(mpls4_init);
+module_exit(mpls4_fini);
diff -Nur linux-3.14.1/net/ipv4/route.c linux-3.14.1_mpls/net/ipv4/route.c
--- linux-3.14.1/net/ipv4/route.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv4/route.c	2014-05-05 16:03:14.659690498 +0530
@@ -440,6 +440,7 @@
 {
 	rt_genid_bump_ipv4(net);
 }
+EXPORT_SYMBOL(rt_cache_flush);
 
 static struct neighbour *ipv4_neigh_lookup(const struct dst_entry *dst,
 					   struct sk_buff *skb,
@@ -1369,6 +1370,7 @@
 			   struct fib_info *fi, u16 type, u32 itag)
 {
 	bool cached = false;
+        struct shim_blk *sblk;
 
 	if (fi) {
 		struct fib_nh *nh = &FIB_RES_NH(*res);
@@ -1377,6 +1379,14 @@
 			rt->rt_gateway = nh->nh_gw;
 			rt->rt_uses_gateway = 1;
 		}
+   
+		if ((sblk = FIB_RES_SHIM(*res)))
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+			sblk->shim->build(sblk, &rt->u.dst);
+#else
+			sblk->shim->build(sblk, &rt->dst);
+#endif
+
 		dst_init_metrics(&rt->dst, fi->fib_metrics, true);
 #ifdef CONFIG_IP_ROUTE_CLASSID
 		rt->dst.tclassid = nh->nh_tclassid;
diff -Nur linux-3.14.1/net/ipv6/ip6_fib.c linux-3.14.1_mpls/net/ipv6/ip6_fib.c
--- linux-3.14.1/net/ipv6/ip6_fib.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv6/ip6_fib.c	2014-04-22 21:42:54.546197826 +0530
@@ -1648,6 +1648,7 @@
 		del_timer(&net->ipv6.ip6_fib_timer);
 	spin_unlock_bh(&fib6_gc_lock);
 }
+EXPORT_SYMBOL(fib6_run_gc);
 
 static void fib6_gc_timer_cb(unsigned long arg)
 {
diff -Nur linux-3.14.1/net/ipv6/ip6_input.c linux-3.14.1_mpls/net/ipv6/ip6_input.c
--- linux-3.14.1/net/ipv6/ip6_input.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv6/ip6_input.c	2014-04-22 21:46:12.967703330 +0530
@@ -193,6 +193,8 @@
 	return NET_RX_DROP;
 }
 
+EXPORT_SYMBOL(ipv6_rcv);
+
 /*
  *	Deliver the packet to the host
  */
diff -Nur linux-3.14.1/net/ipv6/ip6_output.c linux-3.14.1_mpls/net/ipv6/ip6_output.c
--- linux-3.14.1/net/ipv6/ip6_output.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv6/ip6_output.c	2014-04-22 21:51:03.928045463 +0530
@@ -67,6 +67,12 @@
 	skb->protocol = htons(ETH_P_IPV6);
 	skb->dev = dev;
 
+	if (dst->child) {
+		skb_dst_set(skb, skb_dst_pop(skb));
+		return dst_output(skb);
+	}
+
+
 	if (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr)) {
 		struct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));
 
diff -Nur linux-3.14.1/net/ipv6/Kconfig linux-3.14.1_mpls/net/ipv6/Kconfig
--- linux-3.14.1/net/ipv6/Kconfig	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv6/Kconfig	2014-04-22 21:35:27.415819016 +0530
@@ -21,6 +21,15 @@
 
 if IPV6
 
+config INET6_MPLS
+	tristate "IPv6: MPLS support"
+	depends on IPV6 && MPLS
+	---help---
+	  If you say Y here, the kernel will support being an ingress
+	  and egress LER for IPv6 packets.
+
+	  If unsure, say N.
+
 config IPV6_ROUTER_PREF
 	bool "IPv6: Router Preference (RFC 4191) support"
 	---help---
diff -Nur linux-3.14.1/net/ipv6/Makefile linux-3.14.1_mpls/net/ipv6/Makefile
--- linux-3.14.1/net/ipv6/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv6/Makefile	2014-04-22 21:39:03.713099791 +0530
@@ -34,6 +34,7 @@
 obj-$(CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION) += xfrm6_mode_ro.o
 obj-$(CONFIG_INET6_XFRM_MODE_BEET) += xfrm6_mode_beet.o
 obj-$(CONFIG_IPV6_MIP6) += mip6.o
+obj-$(CONFIG_INET6_MPLS) += mpls6.o ipv6.o
 obj-$(CONFIG_NETFILTER)	+= netfilter/
 
 obj-$(CONFIG_IPV6_VTI) += ip6_vti.o
diff -Nur linux-3.14.1/net/ipv6/mpls6.c linux-3.14.1_mpls/net/ipv6/mpls6.c
--- linux-3.14.1/net/ipv6/mpls6.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv6/mpls6.c	2014-04-28 20:22:44.014923750 +0530
@@ -0,0 +1,209 @@
+/* mpls6.c: IPv6 MPLS protocol driver.
+ *
+ * Copyright (C) 2003 David S. Miller (davem@redhat.com)
+ *
+ * Changes:
+ *	JLEU:	Add ICMP handling stubs
+ *		Add nexthop printing
+ *		Change nexthop resolve signature
+ *	JLEU:	Added mpls6_cache_flush()
+ *	JLEU:	un/register reserved labels in fini/init
+ *	JLEU:	remove sysfs print routin
+ */
+
+#include <linux/module.h>
+#include <linux/socket.h>
+#include <linux/skbuff.h>
+#include <linux/in6.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <net/dsfield.h>
+#include <net/neighbour.h>
+#include <net/ipv6.h>
+#include <net/ip6_route.h>
+#include <net/ip6_fib.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+
+MODULE_LICENSE("GPL");
+
+extern int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev);
+
+static void mpls6_cache_flush(struct net *net)
+{
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+	fib6_run_gc((unsigned long)0, net);
+#else
+	fib6_run_gc((unsigned long)0, net, 0);
+#endif
+}
+
+static void mpls6_set_ttl(struct sk_buff *skb, int ttl)
+{
+	/*ipv6_hdr(skb)->hop_limit; RCAS*/
+	ipv6_hdr(skb)->hop_limit = ttl;
+}
+
+static int mpls6_get_ttl(struct sk_buff *skb)
+{
+	return ipv6_hdr(skb)->hop_limit;
+}
+
+static void mpls6_change_dsfield(struct sk_buff *skb, int ds)
+{
+	ipv6_change_dsfield(ipv6_hdr(skb), 0x3, ds);
+}
+
+static int mpls6_get_dsfield(struct sk_buff *skb)
+{
+	return ipv6_get_dsfield(ipv6_hdr(skb));
+}
+
+/* Policy decision, several options:
+ *
+ * 1) Silently discard
+ * 2) Pops all MPLS headers, use resulting upper-layer
+ *    protocol packet to generate ICMP.
+ * 3) Walk down MPLS headers to upper-layer header,
+ *    generate ICMP using that and then prepend
+ *    IDENTICAL MPLS header stack to ICMP packet.
+ *
+ * Problem with #2 is that there may be no route to
+ * upper-level packet source for us to use.  (f.e. we
+ * are switching VPN packets that we have no routes to).
+ *
+ * Option #3 should work even in those cases, because it
+ * is more likely that egress of this MPLS path knows how
+ * to route such packets back to source.  It should also
+ * not be susceptible to loops in MPLS fabric, since one
+ * never responds to ICMP with ICMP.  It is deliberate
+ * assumption made about upper-layer protocol.
+ */
+static int mpls6_ttl_expired(struct sk_buff **skb)
+{
+	return NET_RX_DROP;
+}
+
+static int mpls6_mtu_exceeded(struct sk_buff **skb, int mtu)
+{
+	return MPLS_RESULT_DROP;
+}
+
+static int mpls6_local_deliver(struct sk_buff *skb)
+{
+	skb->protocol = htons(ETH_P_IPV6);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	dst_release(skb_dst(skb));
+	skb_dst_set(skb, NULL);
+	return ipv6_rcv(skb, skb->dev, NULL, skb->dev);
+}
+
+static int mpls6_nexthop_resolve(struct neighbour **np, struct sockaddr *sock_addr, struct net_device *dev)
+{
+	struct sockaddr_in6 *addr = (struct sockaddr_in6 *) sock_addr;
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+	struct flowi fl = { .oif = dev->ifindex,
+	                    .nl_u = { .ip6_u = {.daddr = addr->sin6_addr } } };
+#else
+        struct neighbour *neigh = NULL;
+	struct flowi6 fl = { .flowi6_oif = dev->ifindex,
+	                    .daddr = addr->sin6_addr };
+#endif
+	struct dst_entry *dst;
+	int err;
+
+	if (addr->sin6_family != AF_INET6)
+	        return -EINVAL;
+
+	dst = ip6_route_output(&init_net, NULL, &fl);
+
+	err = 0;
+	if (dst->error)
+		err = -EINVAL;
+                                                                                
+	if (!err)
+#if 0 /* Not required since it is removed in kernel 3.14.1 */
+		*np = neigh_clone(dst->neighbour);
+#else
+                neigh = dst_neigh_lookup(dst, addr);
+		*np = neigh_clone(neigh);
+#endif
+
+	dst_release(dst);
+
+	return err;
+}
+
+static struct mpls_prot_driver mpls6_driver = {
+	.name			=	"ipv6",
+	.family                 =       AF_INET6,
+	.ethertype              =       __constant_htons(ETH_P_IPV6),
+	.cache_flush            =       mpls6_cache_flush,
+	.set_ttl                =       mpls6_set_ttl,
+	.get_ttl                =       mpls6_get_ttl,
+	.change_dsfield         =       mpls6_change_dsfield,
+	.get_dsfield            =       mpls6_get_dsfield,
+	.ttl_expired            =       mpls6_ttl_expired,
+	.mtu_exceeded		=	mpls6_mtu_exceeded,
+	.local_deliver		=	mpls6_local_deliver,
+	.nexthop_resolve        =       mpls6_nexthop_resolve,
+	.owner                  =       THIS_MODULE,
+};
+
+static int __init mpls6_init(void)
+{
+	struct mpls_instr_elem instr[2];
+	struct mpls_label ml;
+	struct mpls_ilm *ilm;
+	int result = mpls_proto_add(&mpls6_driver);
+
+	printk("MPLS: IPv6 over MPLS support\n");
+
+	if (result)
+		return result;
+
+	ml.ml_type = MPLS_LABEL_GEN;
+	ml.u.ml_gen = MPLS_IPV6_EXPLICIT_NULL;
+
+	instr[0].mir_direction = MPLS_IN;
+	instr[0].mir_opcode    = MPLS_OP_POP;
+	instr[1].mir_direction = MPLS_IN;
+	instr[1].mir_opcode    = MPLS_OP_DLV;
+
+	ilm = mpls_ilm_dst_alloc(0, &ml, AF_INET6, instr, 2);
+	if (!ilm)
+		return -ENOMEM;
+
+	result = mpls_add_reserved_label(MPLS_IPV6_EXPLICIT_NULL, ilm);
+	if (result) {
+		ilm->u.dst.obsolete = 1;
+		dst_free(&ilm->u.dst);
+		return result;
+	}
+
+	return 0;
+}
+
+static void __exit mpls6_fini(void)
+{
+	struct mpls_ilm *ilm = mpls_del_reserved_label(MPLS_IPV6_EXPLICIT_NULL);
+
+#if 0
+	if (ilm) {
+		mpls_ilm_release(ilm);
+		ilm->u.dst.obsolete = 1;
+		call_rcu(&ilm->u.dst.rcu_head, dst_rcu_free);
+	}
+#else
+#if 0
+      if (ilm) {
+                 __mpls_del_in_label (ilm); 
+      }
+#endif
+#endif
+
+	mpls_proto_remove(&mpls6_driver);
+}
+
+module_init(mpls6_init);
+module_exit(mpls6_fini);
diff -Nur linux-3.14.1/net/ipv6/route.c linux-3.14.1_mpls/net/ipv6/route.c
--- linux-3.14.1/net/ipv6/route.c	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/ipv6/route.c	2014-04-23 15:12:39.802944713 +0530
@@ -40,6 +40,7 @@
 #include <linux/mroute6.h>
 #include <linux/init.h>
 #include <linux/if_arp.h>
+#include <net/shim.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/nsproxy.h>
@@ -325,6 +326,9 @@
 	struct inet6_dev *idev = rt->rt6i_idev;
 	struct dst_entry *from = dst->from;
 
+	if (rt->rt6i_shim)
+		shim_destroy_blk(rt->rt6i_shim);
+
 	if (!(rt->dst.flags & DST_HOST))
 		dst_destroy_metrics_generic(dst);
 
@@ -1690,6 +1694,15 @@
 		}
 	}
 
+	if (cfg->fc_shim.datalen) {
+		rt->rt6i_shim = shim_build_blk(&cfg->fc_shim);
+		if (!rt->rt6i_shim) {
+			err = -EINVAL;
+			goto out;
+		}
+		rt->rt6i_shim->shim->build(rt->rt6i_shim, &rt->dst);
+	}
+
 	rt->dst.dev = dev;
 	rt->rt6i_idev = idev;
 	rt->rt6i_table = table;
@@ -2348,6 +2361,7 @@
 	[RTA_PRIORITY]          = { .type = NLA_U32 },
 	[RTA_METRICS]           = { .type = NLA_NESTED },
 	[RTA_MULTIPATH]		= { .len = sizeof(struct rtnexthop) },
+	[RTA_SHIM]              = { .len = sizeof(struct rtshim) },
 };
 
 static int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,
@@ -2425,6 +2439,10 @@
 	if (tb[RTA_TABLE])
 		cfg->fc_table = nla_get_u32(tb[RTA_TABLE]);
 
+	if (tb[RTA_SHIM])
+		memcpy(&cfg->fc_shim, nla_data(tb[RTA_SHIM]),
+			nla_len(tb[RTA_SHIM]));
+
 	if (tb[RTA_MULTIPATH]) {
 		cfg->fc_mp = nla_data(tb[RTA_MULTIPATH]);
 		cfg->fc_mp_len = nla_len(tb[RTA_MULTIPATH]);
diff -Nur linux-3.14.1/net/Kconfig linux-3.14.1_mpls/net/Kconfig
--- linux-3.14.1/net/Kconfig	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/Kconfig	2014-04-22 18:07:39.196565759 +0530
@@ -22,6 +22,49 @@
 	  recommended to read the NET-HOWTO, available from
 	  <http://www.tldp.org/docs.html#howto>.
 
+config MPLS
+	tristate "Multiprotocol Label Switching"
+	depends on INET
+	---help---
+	  In conventional IP forwarding, a particular router will typically
+  	  consider two packets to be in the same FEC if there is some address
+  	  prefix X in that router's routing tables such that X is the "longest
+	  match" for each packet's destination address.  As the packet
+	  traverses the network, each hop in turn reexamines the packet and
+	  assigns it to a FEC.
+  
+	  In MPLS, the assignment of a particular packet to a particular FEC is
+	  done just once, as the packet enters the network.  The FEC to which
+	  the packet is assigned is encoded as a short fixed length value known
+	  as a "label".  When a packet is forwarded to its next hop, the label
+	  is sent along with it; that is, the packets are "labeled" before they
+	  are forwarded.
+  
+	  At subsequent hops, there is no further analysis of the packets
+	  network layer header.  Rather, the label is used as an index into a
+	  table which specifies the next hop, and a new label.  The old label
+	  is replaced with the new label, and the packet is forwarded to its
+	  next hop.
+  
+	  In the MPLS forwarding paradigm, once a packet is assigned to a FEC,
+	  no further header analysis is done by subsequent routers; all
+	  forwarding is driven by the labels.
+
+	  If unsure, say N.
+
+config MPLS_TUNNEL
+	tristate "MPLS: Virtual tunnel interface"
+	depends on MPLS
+	---help---
+	  Allow Label Switched Paths to be represented by a virtual interface.
+	  Some find this a more comfortable paradym for mapping traffic to LSPs.
+
+	  If compiled as a module, each instantiation creates a new virtual
+	  interface.  If linked into the monolithic kernel, one and only
+	  one virtual interface is automagically created.
+
+	  If unsure, say N.
+
 if NET
 
 config WANT_COMPAT_NETLINK_MESSAGES
diff -Nur linux-3.14.1/net/Makefile linux-3.14.1_mpls/net/Makefile
--- linux-3.14.1/net/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/Makefile	2014-04-22 18:09:46.050970983 +0530
@@ -16,6 +16,7 @@
 obj-$(CONFIG_LLC)		+= llc/
 obj-$(CONFIG_NET)		+= ethernet/ 802/ sched/ netlink/
 obj-$(CONFIG_NETFILTER)		+= netfilter/
+obj-$(CONFIG_MPLS)		+= mpls/
 obj-$(CONFIG_INET)		+= ipv4/
 obj-$(CONFIG_XFRM)		+= xfrm/
 obj-$(CONFIG_UNIX)		+= unix/
diff -Nur linux-3.14.1/net/mpls/af_mpls.c linux-3.14.1_mpls/net/mpls/af_mpls.c
--- linux-3.14.1/net/mpls/af_mpls.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/af_mpls.c	2014-04-29 20:49:43.969966297 +0530
@@ -0,0 +1,136 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * af_mpls.c
+ *	 * PF_MPLS 
+ *
+ * $Id$
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *
+ *   (c) 2003	James Leu	<jleu@mindspring.com>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * $ChangeLog$
+ *****************************************************************************
+ */
+
+#if 0
+#include <generated/autoconf.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <net/sock.h>
+#include <net/net_namespace.h>
+#include <linux/net.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+
+static int mpls_release(struct socket *sock) {
+	return 0;
+}
+
+static struct proto mpls_proto = {
+	.name =		"MPLS",
+	.owner =	 THIS_MODULE,
+	.obj_size =	 sizeof(struct sock),
+};
+
+struct proto_ops mpls_sk_ops = {
+	.family =	PF_MPLS,
+	.owner =	THIS_MODULE,
+	.release =	mpls_release,
+	.bind =		sock_no_bind,
+	.connect =	sock_no_connect,
+	.socketpair =	sock_no_socketpair,
+	.accept =	sock_no_accept,
+	.getname =	sock_no_getname,
+	.poll =		sock_no_poll,
+	.ioctl =	sock_no_ioctl,
+	.listen =       sock_no_listen,
+	.shutdown =	sock_no_shutdown,
+	.setsockopt =	sock_no_setsockopt,
+	.getsockopt =	sock_no_getsockopt,
+	.sendmsg =	sock_no_sendmsg,
+	.recvmsg =	sock_no_recvmsg,
+	.mmap =		sock_no_mmap,
+	.sendpage =	sock_no_sendpage,
+};
+
+/* destruction routine */
+                                                                                
+static void mpls_sock_destruct(struct sock *sk)
+{
+        __skb_queue_purge(&sk->sk_receive_queue);
+        __skb_queue_purge(&sk->sk_error_queue);
+
+        WARN_ON(atomic_read(&sk->sk_rmem_alloc));
+        WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+        WARN_ON(sk->sk_wmem_queued);
+        WARN_ON(sk->sk_forward_alloc);
+
+        dst_release(sk->sk_dst_cache);
+}
+
+/*
+ *      Create an mpls socket.
+ */
+                                                                                
+static int mpls_create(struct net *net, struct socket *sock, int protocol,
+                       int kern)
+{
+	struct sock *sk;
+
+        if (net != &init_net)
+		return -EAFNOSUPPORT;
+
+	sock->state = SS_UNCONNECTED;
+	sock->ops = &mpls_sk_ops;
+
+	sk = sk_alloc(net, PF_INET, GFP_KERNEL, &mpls_proto);
+        if (!sk)
+                return -1;
+
+	sock_init_data(sock, sk);
+
+	sk->sk_destruct    = mpls_sock_destruct;
+	sk->sk_family      = PF_MPLS;
+	sk->sk_protocol    = 0;
+	sk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;
+
+	sock_reset_flag(sk, SOCK_ZAPPED);
+
+	return 0;
+}
+
+struct net_proto_family mpls_family_ops = {
+	.family = PF_MPLS,
+	.create = mpls_create,
+	.owner  = THIS_MODULE,
+};
+
+int __init mpls_sock_init(void)
+{
+	int rc;
+	if ((rc = proto_register(&mpls_proto, 0)))
+		return rc;
+
+        sock_register(&mpls_family_ops);
+
+	return 0;
+}
+
+void __exit mpls_sock_exit(void)
+{
+	sock_unregister(AF_MPLS);
+	proto_unregister(&mpls_proto);
+}
+#endif
diff -Nur linux-3.14.1/net/mpls/Makefile linux-3.14.1_mpls/net/mpls/Makefile
--- linux-3.14.1/net/mpls/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/Makefile	2014-04-23 09:16:07.067887814 +0530
@@ -2,3 +2,18 @@
 # Makefile for MPLS.
 #
 obj-y += mpls_gso.o
+
+#
+# Ported from linux 2.6.35
+# Makefile for the Linux MPLS layer.
+#
+
+mpls-y := af_mpls.o mpls_if.o mpls_ilm.o mpls_init.o mpls_input.o \
+	mpls_opcode.o mpls_nhlfe.o mpls_output.o \
+	mpls_utils.o mpls_dst.o mpls_netlink.o mpls_proto.o \
+	mpls_instr.o mpls_shim.o
+mpls-$(CONFIG_SYSCTL) += mpls_sysctl.o
+mpls-$(CONFIG_PROC_FS) += mpls_procfs.o
+
+obj-$(CONFIG_MPLS) += mpls.o
+obj-$(CONFIG_MPLS_TUNNEL) += mpls_tunnel.o
diff -Nur linux-3.14.1/net/mpls/mpls_dst.c linux-3.14.1_mpls/net/mpls/mpls_dst.c
--- linux-3.14.1/net/mpls/mpls_dst.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_dst.c	2014-04-29 19:31:37.208644420 +0530
@@ -0,0 +1,308 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	      It implements:
+ *	      -the MPLS dst_entry life cycle.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *	IMPORTANT: We manage "mpls_dst" cache objects, which live in 
+ *	AF_MPLS, for either ETH_P_MPLS_UC/ETH_P_MPLS_MC. Nevertheless
+ *	these mpls_dst objects hold references to neighbours that live
+ *	in the AF_INET and/or AF_INET6 neighbour tables.
+ *
+ *	20040206 - RCAS: Note that the DST parent is the MOI object.
+ *
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <net/mpls.h>
+
+/* forward declarations */
+static struct dst_entry *mpls_dst_check(struct dst_entry *dst, u32 cookie);
+static void		 mpls_dst_destroy(struct dst_entry *dst);
+static struct dst_entry *mpls_negative_advice(struct dst_entry *dst);
+static void		 mpls_link_failure(struct sk_buff *skb);
+static void		 mpls_dst_update_pmtu(struct dst_entry *dst, u32 mtu);
+static int		 mpls_dst_gc(struct dst_ops *ops);
+
+struct dst_ops mpls_dst_ops = {
+	.family          =  AF_MPLS,
+	.protocol        = __constant_htons(ETH_P_MPLS_UC),
+	.gc              = mpls_dst_gc,
+	.check           = mpls_dst_check,
+	.destroy         = mpls_dst_destroy,
+	.negative_advice = mpls_negative_advice,
+	.link_failure    = mpls_link_failure,
+	.update_pmtu     = mpls_dst_update_pmtu,
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	.entries	 = ATOMIC_INIT(0)
+#else
+#endif
+};
+
+
+static struct dst_entry *
+mpls_dst_check (struct dst_entry *dst, u32 cookie)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+
+
+/** 
+ *	mpls_dst_destroy - cleanup for a MPLS dst_entry
+ *	@dst: 'this', object that is being destroyed.
+ *
+ *	The object ends life here. Perform the necessary
+ *	clean up, but do not call dst_free(..) etc. 
+ **/
+ 
+static void 
+mpls_dst_destroy (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+
+
+static struct dst_entry *
+mpls_negative_advice (struct dst_entry *dst)
+{
+	struct mpls_dst *md = (struct mpls_dst*)dst;
+	struct dst_entry *ret = dst;
+										
+	MPLS_ENTER;
+	if (md) {
+		if (dst->obsolete || md->u.dst.expires) {
+			dst_release((struct dst_entry*)md);
+			ret = NULL;
+		}
+	}
+	MPLS_EXIT;
+	return ret;
+}
+
+static void 
+mpls_link_failure (struct sk_buff *skb)
+{
+	struct mpls_dst *md;
+
+	MPLS_ENTER;
+//	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0);
+
+	if ((md = (struct mpls_dst *)skb_dst(skb)));
+		dst_set_expires(&md->u.dst, 0);
+	MPLS_EXIT;
+}
+
+int mpls_dst_mtu_expires	= 10 * 60 * HZ;
+int mpls_dst_min_pmtu		= 512 + 20 + 20 + 4;
+
+static void 
+mpls_dst_update_pmtu (struct dst_entry *dst, u32 mtu)
+{
+	MPLS_ENTER;
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	if (dst->metrics[RTAX_MTU-1] > mtu && mtu >= 68 &&
+#else
+	if (dst->_metrics > mtu && mtu >= 68 &&
+#endif
+	    !(dst_metric_locked (dst, RTAX_MTU)) ) {
+		if (mtu < mpls_dst_min_pmtu) {
+			mtu = mpls_dst_min_pmtu;
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+			dst->metrics[RTAX_LOCK-1] |= (1 << RTAX_MTU);
+#else
+			dst->_metrics |= (1 << RTAX_MTU);
+#endif
+		}
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+		dst->metrics[RTAX_MTU-1] = mtu;
+#else
+		dst->_metrics = mtu;
+#endif
+		dst_set_expires (dst, mpls_dst_mtu_expires);
+	}
+	MPLS_EXIT;
+}
+
+
+/**
+ *	mpls_dst_gc - MPLS destination cache GC policies.
+ *
+ *	Actually a NOOP. Return nonzero to veto allocation of a new DST entry.
+ **/
+static int 
+mpls_dst_gc (struct dst_ops *ops)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_dst_alloc - construct a mpls_dst entry.
+ *	@dev: output device.
+ *	@nh: address of the next hop (IPv4 or IPv6)
+ *
+ *	Allocate a new mpls_dst cache object (which basically adds a next hop
+ *	attribute to base dst) using dst_alloc () and the dst_ops above. Lookup
+ *	(or set up) a neighbour in the AF_INET/AF_INET6 families and hold it.
+ *	The hh_type when building the neighbour will be set to ETH_P_MPLS_UC
+ *	Called when building the SET opcode, the returned object will be 
+ *	stored as the opcode data. Process context only.
+ **/
+ 
+struct mpls_dst* 
+mpls_dst_alloc ( struct net_device *dev, struct sockaddr *nh)
+{
+	struct mpls_dst		*md = NULL;
+	struct mpls_prot_driver *prot;
+	struct mpls_interface	*mif;
+#if 0 /* Added new for this kernel alone */ 
+#else
+       struct neighbour *neighbour; 
+       struct sockaddr_in *daddr = (struct sockaddr_in *) nh;
+#endif
+
+	MPLS_ENTER;
+	BUG_ON(!nh);
+	BUG_ON(!dev);
+	mif = mpls_get_if_info(dev->ifindex);
+	MPLS_ASSERT(mif);
+
+	if (!nh->sa_family) {
+		memset(nh, 0, sizeof(struct sockaddr));
+		nh->sa_family = AF_INET;
+	}
+	prot = mpls_proto_find_by_family(nh->sa_family);
+	if (unlikely(!prot))
+		goto mpls_dst_alloc_2;
+
+	/* Allocate a MPLS dst entry */
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	md = dst_alloc (&mpls_dst_ops);
+#else
+	md = dst_alloc (&mpls_dst_ops, dev, 0, 0, 0);
+#endif
+	if (unlikely(!md)) 
+		goto mpls_dst_alloc_1;
+
+	/* Hold it */
+	dst_hold(&md->u.dst);
+
+	dev_hold(dev);
+	md->u.dst.dev   = dev;
+	md->u.dst.flags = DST_HOST;
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	md->u.dst.hh    = NULL;
+	/* Set next hop MPLS attr */
+	memcpy(&md->md_nh,nh,sizeof(struct sockaddr));
+#else
+#endif
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest*/
+	/* use the protocol driver to resolve the neighbour */
+	if (prot->nexthop_resolve(&md->u.dst.neighbour, nh, dev))
+#else
+        neighbour = dst_neigh_lookup(&md->u.dst, &daddr->sin_addr.s_addr);  
+	/* use the protocol driver to resolve the neighbour */
+	if (prot->nexthop_resolve(&neighbour, nh, dev))
+#endif
+		goto mpls_dst_alloc_0;
+
+	mpls_proto_release(prot);
+
+	MPLS_DEBUG("exit(%p)\n",md);
+	return md;
+
+mpls_dst_alloc_0:
+	/* dst_release releases dev and neighbour */
+	dst_release(&md->u.dst);
+	dst_free(&md->u.dst);
+
+mpls_dst_alloc_1:
+	mpls_proto_release(prot);
+
+mpls_dst_alloc_2:
+	MPLS_DEBUG("exit(%p)\n",md);
+	return NULL;
+}
+
+
+
+/**
+ *	mpls_dst_release - cleanup and release the DST. 
+ *
+ *	Call base dst_release and call_rcu.
+ *
+ *	RCAS: _NOTE_ do not release the neighbour
+ *	mdst->u.dst.neighbour. when the dst frmwk calls dst_destroy
+ *	it will be released.
+ **/
+
+void
+mpls_dst_release (struct mpls_dst* mdst)
+{
+	dst_release (&mdst->u.dst);
+	call_rcu (&mdst->u.dst.rcu_head, dst_rcu_free);
+}
+
+
+
+/** 
+ * mpls_dst_init - Create mpls DST entries slab allocator
+ *
+ **/
+ 
+int __init mpls_dst_init(void)
+{
+	mpls_dst_ops.kmem_cachep = kmem_cache_create("mpls_dst_cache",
+		sizeof(struct mpls_dst), 0, SLAB_HWCACHE_ALIGN, NULL);
+
+	if (!mpls_dst_ops.kmem_cachep) {
+		printk(MPLS_ERR "MPLS: failed to alloc mpls_dst_cache\n");
+		return -ENOMEM;
+	}
+        printk("MPLS_DST_INIT PASS ...............");
+
+	return 0;
+}
+
+
+/** 
+ * mpls_dst_exit - Destroy mpls DST entries slab allocator
+ *
+ **/ 
+
+void __exit mpls_dst_exit(void)
+{
+	if (mpls_dst_ops.kmem_cachep)
+	{
+		kmem_cache_destroy(mpls_dst_ops.kmem_cachep);
+		printk("MPLS_DST_EXIT PASS ...............");
+	}
+}
diff -Nur linux-3.14.1/net/mpls/mpls_if.c linux-3.14.1_mpls/net/mpls/mpls_if.c
--- linux-3.14.1/net/mpls/mpls_if.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_if.c	2014-04-23 09:30:18.801180077 +0530
@@ -0,0 +1,282 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * mpls_if.c
+ *         * Allocation/Deallocation of per netdevice MPLS data (labelspace)
+ *         * Query/Update MPLS labelspace functions.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2010   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *****************************************************************************
+ */
+
+#include <generated/autoconf.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/in.h>           /* must be before route.h */
+#include <linux/ip.h>           /* must be before route.h */
+#include <linux/inetdevice.h>   /* must be before route.h */
+#include <net/route.h>
+#include <net/mpls.h>
+#include <linux/genetlink.h>
+#include <net/net_namespace.h>
+
+/*
+ * MPLS info radix tree and corresponding lock
+ */
+RADIX_TREE(mpls_if_tree, GFP_ATOMIC);
+
+DEFINE_SPINLOCK(mpls_if_lock);
+
+
+/**
+ *	mpls_create_if_info - allocate memory for the MPLS net_device extension
+ *
+ *	Returns a pointer to the allocated struct.
+ *	RCAS: From process context only. May sleep.
+ **/
+
+struct mpls_interface *
+mpls_create_if_info (void)
+{
+	struct mpls_interface *mif =
+	    kmalloc(sizeof(struct mpls_interface), GFP_KERNEL);
+	if (unlikely(!mif)) 
+		return NULL;
+
+	memset(mif, 0, sizeof(struct mpls_interface));
+	mif->labelspace = -1;
+	INIT_LIST_HEAD(&mif->list_out);
+	INIT_LIST_HEAD(&mif->list_in);
+	return mif;
+}
+
+
+/**
+ *	mpls_delete_if_info - free memory stored for per netdevice MPLS data
+ *	@dev: netdevice
+ *	
+ *	Deallocation of MPLS netdevice data
+ **/
+
+inline void 
+mpls_delete_if_info (struct net_device *dev)
+{
+	struct mpls_interface *mif;
+	spin_lock_bh (&mpls_if_lock);
+	mif = radix_tree_delete (&mpls_if_tree, dev->ifindex);
+	spin_unlock_bh (&mpls_if_lock);
+
+	if (mif)
+		kfree (mif);
+}
+
+struct mpls_interface *
+mpls_get_if_info (unsigned int key)
+{
+	struct mpls_interface *mif;
+	spin_lock_bh (&mpls_if_lock);
+	mif = radix_tree_lookup (&mpls_if_tree,key);
+	spin_unlock_bh (&mpls_if_lock);
+	return mif;
+}
+
+/**
+ *	__mpls_get_labelspace - Get the interface  label space
+ *	@dev: device 
+ *
+ *	See mpls_get_labelspace for comments.
+ *	Returns the labelspace
+ **/
+
+static inline int 
+__mpls_get_labelspace (struct net_device *dev)
+{
+	struct mpls_interface *mif = mpls_get_if_info(dev->ifindex);
+	return (mif) ? mif->labelspace : -1;
+}
+
+
+/**
+ *	mpls_get_labelspace_by_name - Get the interface  label space
+ *	@name: name of the interface
+ *
+ *	See mpls_get_labelspace for comments.
+ *	Returns the labelspace
+ **/
+
+int 
+mpls_get_labelspace_by_name (const char* name)
+{
+	int result = -1;
+	struct net_device *dev = dev_get_by_name (&init_net, name);
+	if (dev) {
+		result = __mpls_get_labelspace (dev);
+		dev_put (dev);
+	}
+	return result;
+}
+
+/**
+ *	mpls_set_labelspace_by_index - Get the interface  label space
+ *	@ifindex:  interface index 
+ *
+ *	See mpls_get_labelspace for comments.
+ *	Returns the labelspace
+ **/
+
+int 
+mpls_get_labelspace_by_index (int ifindex)
+{
+	struct mpls_interface *mif = mpls_get_if_info(ifindex);
+	return (mif) ? mif->labelspace : -1;
+}
+
+/**
+ *	mpls_get_labelspace - Get the label space for the interface
+ *	@req: mpls_labelspace_req struct with the query data. In particular,
+ *	     contains the interface index in req->mls_ifindex.
+ *
+ *	Returns 0 on sucess and sets the label space for the netdevice in
+ *	req->mls_ifindex. The labelspace in req->mls_ifindex may be -1 if MPLS
+ *	was not active on the interface.
+ **/
+
+inline int 
+mpls_get_labelspace(struct mpls_labelspace_req *req)
+{
+	return mpls_get_labelspace_by_index (req->mls_ifindex);
+}
+
+/**
+ *	__mpls_set_labelspace - Set a label space for the interface.
+ *	@dev: device 
+ *	@labelspace: new labelspace
+ *
+ *	See mpls_set_labelspace for comments.
+ *	Returns 0 on success.
+ **/
+
+static int 
+__mpls_set_labelspace (struct net_device *dev, int labelspace)
+{
+	struct mpls_interface *mif = mpls_get_if_info(dev->ifindex);
+	int err;
+
+	MPLS_ENTER;
+	if (!mif && labelspace != -1) {
+		mif = mpls_create_if_info ();
+		if (unlikely(!mif)) {
+			MPLS_DEBUG("Err: Set labelspace for %s to %d\n",
+				dev->name, labelspace);
+			MPLS_EXIT;
+			return -ENOMEM;
+		}
+		/* Actual assignment happens here */
+		mif->labelspace = labelspace;
+
+		spin_lock_bh (&mpls_if_lock);
+		err = radix_tree_insert(&mpls_if_tree, dev->ifindex, mif);
+		spin_unlock_bh (&mpls_if_lock);
+		if (unlikely(err)) {
+			MPLS_DEBUG("Error adding if index %u to radix tree\n",dev->ifindex);
+			MPLS_EXIT;
+			return -ENOMEM;
+		} else {
+			MPLS_DEBUG("Set labelspace for %s to %d\n",
+				dev->name, labelspace);
+		}
+	} else {
+		if (labelspace == -1) {
+			MPLS_DEBUG("Resetting labelspace for %s to %d\n",
+				dev->name,-1);
+			mpls_delete_if_info (dev);
+		} else {
+			mif->labelspace = labelspace;
+		}
+			
+	}
+	mpls_labelspace_event(MPLS_CMD_SETLABELSPACE, dev);
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ *	mpls_set_labelspace_by_name - Set a label space for the interface.
+ *	@name: name of the interface
+ *	@labelspace: new labelspace
+ *
+ *	See mpls_set_labelspace for comments.
+ *	Returns 0 on success.
+ **/
+
+int 
+mpls_set_labelspace_by_name (const char* name, int labelspace)
+{
+	int result = -1;
+	struct net_device *dev = dev_get_by_name (&init_net, name);
+	if (dev) {
+		result = __mpls_set_labelspace (dev, labelspace);
+		dev_put (dev);
+	}
+	return result;
+}
+
+/**
+ *	mpls_set_labelspace_by_index - Set a label space for the interface.
+ *	@ifindex:  interface index 
+ *	@labelspace: new labelspace
+ *
+ *	See mpls_set_labelspace for comments.
+ *	Returns 0 on success.
+ **/
+
+int 
+mpls_set_labelspace_by_index (int ifindex, int labelspace)
+{
+	int result = -1;
+	struct net_device *dev = dev_get_by_index (&init_net, ifindex);
+	if (dev) {
+		result = __mpls_set_labelspace (dev, labelspace);
+		dev_put (dev);
+	}
+	return result;
+}
+
+/**
+ *	mpls_set_labelspace - Set a label space for the interface.
+ *	@req: mpls_labelspace_req struct with the update data. In particular,
+ *	     contains the interface index in req->mls_ifindex, and the new
+ *	     labelspace in req->mls_labelspace.
+ *
+ *	This function assigns a label space to a particular net device. In
+ *	the current implementation, the mif is store in a radix trie by the
+ *	netdevice ifindex.  The mif is dynamically allocated here,
+ *	using mpls_create_if_info().
+ *	Returns 0 on success.
+ **/
+
+int 
+mpls_set_labelspace (struct mpls_labelspace_req *req)
+{
+	int result = -1; 
+	struct net_device *dev = dev_get_by_index (&init_net, req->mls_ifindex);
+	if (dev) {
+		result = __mpls_set_labelspace (dev, req->mls_labelspace);
+		dev_put (dev);
+	}
+	return result;
+}
diff -Nur linux-3.14.1/net/mpls/mpls_ilm.c linux-3.14.1_mpls/net/mpls/mpls_ilm.c
--- linux-3.14.1/net/mpls/mpls_ilm.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_ilm.c	2014-04-29 20:28:26.836270557 +0530
@@ -0,0 +1,996 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes
+ * 20040117 RCAS
+ *      - Changed RADIX_TREE(mpls_ilm_tree, GFP_ATOMIC) (since it's locked).
+ * 20040115 RCAS
+ *	- Removed old legacy ioctl code.
+ * 20040127 RCAS
+ *	- Dynamic allocation of instructions.
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <linux/netdevice.h>	
+#include <linux/in.h>		/* must be before route.h */
+#include <linux/ip.h>		/* must be before route.h */
+#include <linux/inetdevice.h>	/* must be before route.h */
+#include <net/route.h>
+#include <net/mpls.h>
+#include <linux/genetlink.h>
+#include <net/net_namespace.h>
+#include <net/dst.h>
+
+LIST_HEAD(mpls_ilm_list);
+
+/* forward declarations */
+static struct dst_entry *ilm_dst_check(struct dst_entry *dst, u32 cookie);
+static void              ilm_dst_destroy(struct dst_entry *dst);
+static struct dst_entry *ilm_dst_negative_advice(struct dst_entry *dst);
+static void              ilm_dst_link_failure(struct sk_buff *skb);
+static void              ilm_dst_update_pmtu(struct dst_entry *dst, u32 mtu);
+static int               ilm_dst_gc(struct dst_ops *ops);
+
+struct dst_ops ilm_dst_ops = {
+	.family		 =  AF_MPLS,
+	.protocol	 = __constant_htons(ETH_P_MPLS_UC),
+	.gc		 = ilm_dst_gc,
+	.check		 = ilm_dst_check,
+	.destroy	 = ilm_dst_destroy,
+	.negative_advice = ilm_dst_negative_advice,
+	.link_failure	 = ilm_dst_link_failure,
+	.update_pmtu	 = ilm_dst_update_pmtu,
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	.entries	 = ATOMIC_INIT(0)
+#else
+#endif
+};
+
+static struct dst_entry *
+ilm_dst_check (struct dst_entry *dst, u32 cookie)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+/**
+ *      ilm_dst_destroy - cleanup for a MPLS dst_entry
+ *      @dst: 'this', object that is being destroyed.
+ *
+ *      The object ends life here. Perform the necessary
+ *      clean up, but do not call dst_free(..) etc.
+ **/
+
+static void
+ilm_dst_destroy (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static struct dst_entry *
+ilm_dst_negative_advice (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+static void
+ilm_dst_link_failure (struct sk_buff *skb)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static void
+ilm_dst_update_pmtu (struct dst_entry *dst, u32 mtu)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static int
+ilm_dst_gc (struct dst_ops *ops)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+	return 0;
+}
+
+const u32 my_dst_default_metrics[RTAX_MAX + 1] = {
+    [RTAX_MAX] = 0xdeadbeef,
+};
+
+void *my_dst_alloc(struct dst_ops *ops, struct net_device *dev,
+		int initial_ref, int initial_obsolete, unsigned short flags)
+{
+	struct dst_entry *dst = NULL;
+
+	if (ops->gc && dst_entries_get_fast(ops) > ops->gc_thresh) {
+		if (ops->gc(ops))
+			return NULL;
+	}
+	dst = kmem_cache_alloc(ops->kmem_cachep, GFP_ATOMIC);
+	if (!dst)
+		return NULL;
+	dst->child = NULL;
+	dst->dev = dev;
+	if (dev)
+		dev_hold(dev);
+	dst->ops = ops;
+	dst_init_metrics(dst, my_dst_default_metrics, true);
+	dst->expires = 0UL;
+	dst->path = dst;
+	dst->from = NULL;
+#ifdef CONFIG_XFRM
+	dst->xfrm = NULL;
+#endif
+	dst->input = dst_discard;
+	dst->output = dst_discard;
+	dst->error = 0;
+	dst->obsolete = initial_obsolete;
+	dst->header_len = 0;
+	dst->trailer_len = 0;
+#ifdef CONFIG_IP_ROUTE_CLASSID
+	dst->tclassid = 0;
+#endif
+	atomic_set(&dst->__refcnt, initial_ref);
+	dst->__use = 0;
+	dst->lastuse = jiffies;
+	dst->flags = flags;
+	dst->pending_confirm = 0;
+	dst->next = NULL;
+	if (!(flags & DST_NOCOUNT))
+		dst_entries_add(ops, 1);
+	return dst;
+}
+
+/**
+ *      mpls_ilm_dst_alloc - construct a mpls_ilm entry.
+ *
+ **/
+
+struct mpls_ilm*
+mpls_ilm_dst_alloc(unsigned int key, struct mpls_label *ml,
+	unsigned short family, struct mpls_instr_elem *instr, int instr_len)
+{
+	struct mpls_ilm *ilm = NULL;
+	int result;
+
+	MPLS_ENTER;
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	ilm = dst_alloc (&ilm_dst_ops);
+#else
+/* HANGED with init_net.loopback_dev 
+	ilm = dst_alloc (&ilm_dst_ops, init_net.loopback_dev, 0, 0, 0);*/
+	//ilm = my_dst_alloc (&ilm_dst_ops, NULL, 0, 0, DST_NOCOUNT);
+	ilm = dst_alloc (&ilm_dst_ops, NULL, 0, 0, 0);
+#endif
+	if (unlikely(!ilm))
+	{
+		goto ilm_dst_alloc_0;
+	}
+
+	memcpy(&(ilm->ilm_label),ml,sizeof(struct mpls_label));
+	INIT_LIST_HEAD(&ilm->dev_entry);
+	INIT_LIST_HEAD(&ilm->nhlfe_entry);
+	INIT_LIST_HEAD(&ilm->global);
+
+	ilm->ilm_instr      = NULL;
+	ilm->ilm_key        = key;
+	ilm->ilm_labelspace = ml->ml_index;
+	ilm->ilm_age        = jiffies;
+	ilm->ilm_proto      = mpls_proto_find_by_family(family);
+	ilm->ilm_fix_hh     = 0;
+	if (unlikely(!ilm->ilm_proto)) {
+		MPLS_DEBUG("Unable to find protocol driver for '0x%04x'\n",
+			family);
+		goto ilm_dst_alloc_1;
+	} else {
+		ilm->u.dst.input = ilm->ilm_proto->local_deliver;
+	}
+	ilm->u.dst.dev	    = init_net.loopback_dev;
+
+	result = mpls_set_in_instrs(instr, instr_len, ilm);
+
+	if (result)
+		goto ilm_dst_alloc_2;
+
+	MPLS_EXIT;
+	return ilm;
+
+/* Error Path */
+ilm_dst_alloc_2:
+	mpls_proto_release(ilm->ilm_proto);
+ilm_dst_alloc_1:
+	ilm->u.dst.obsolete = 1;
+	dst_free(&ilm->u.dst);
+
+ilm_dst_alloc_0:
+	MPLS_EXIT;
+	return NULL;
+}
+
+
+/*
+ * MPLS info radix tree and corresponding lock
+ */
+RADIX_TREE(mpls_ilm_tree, GFP_ATOMIC);
+
+DEFINE_SPINLOCK(mpls_ilm_lock);
+
+/*
+ * Some label values are reserved. 
+ * For incoming label values of "IPv4 EXPLICIT NULL" and "IPv6 EXPLICIT NULL",
+ * the instructions to execute are well defined. 
+ */
+
+/** 
+ * ILM objects associated to reserved labels
+ * RCAS: _IMPORTANT_ reserved labels *ARE NOT* in tree!
+ **/
+
+static struct mpls_reserved_labels {
+	struct mpls_ilm *ilm;  /* Pointer to the ILM object              */ 
+	char *msg;		   /* Description of the Label               */
+	int bos;		   /* 1 -> it MUST be at the bottom of stack */
+} mpls_reserved[16] = {
+	{ NULL,                "IPv4 EXPLICIT NULL", 1 },
+	{ NULL,                "ROUTER ALERT",       0 },
+	{ NULL,                "IPv6 EXPLICIT NULL", 1 },
+	{ NULL,                "IMPLICIT NULL",      1 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 },
+	{ NULL,                "RESERVED",           0 }
+};
+
+/**
+ *	mpls_insert_ilm - Inserts the given ILM object in the MPLS Input 
+ *	Information Radix Tree using the given key.
+ *	@key: key to use 
+ *	@ilm: ilm object. 
+ *	
+ *	Returns 0 on success, or:
+ *		-ENOMEM : unable to allocate node in the radix tree.
+ **/
+
+int 
+mpls_insert_ilm (unsigned int key, struct mpls_ilm *ilm) 
+{
+	int retval = 0;
+
+	mpls_ilm_hold (ilm);
+	retval = radix_tree_insert (&mpls_ilm_tree, key, ilm);
+	if (unlikely(retval)) {
+		MPLS_DEBUG("Error create node with key %u in radix tree\n",key);
+		retval = -ENOMEM;
+	}
+	list_add_rcu(&ilm->global, &mpls_ilm_list);
+	return retval;
+}
+
+/**
+ *	mpls_remove_ilm - Remove the node given the key from the MPLS Input 
+ *	Information Radix Tree.
+ *	@key : key to use 
+ *
+ *	This function deletes the ILM object from the Radix Tree, but please
+ *	also note that the object is not freed, and that the caller is
+ *	responsible for	decreasing the refcount if necessary.
+ *
+ *	Returns the node removed from the tree (which still needs to be
+ *	released) or NULL if no such key/element exists in the tree.
+ *	Caller must hold write lock
+ *
+ **/
+
+struct mpls_ilm* 
+mpls_remove_ilm (unsigned int key)
+{
+	struct mpls_ilm *ilm = NULL;
+
+	MPLS_ENTER;
+	ilm = radix_tree_delete (&mpls_ilm_tree, key);
+	if (!ilm) {
+		MPLS_DEBUG("node key %u not found.\n",key);
+		return NULL;
+	}
+
+	list_del_rcu(&ilm->global);
+	mpls_ilm_release (ilm);
+
+	MPLS_EXIT;
+	return ilm;
+}
+
+/**
+ *	mpls_get_ilm - Get a reference to a ILM object. 
+ *	@key : key to look for in the ILM Radix Tree. 
+ *
+ *	This function can be used to get a reference to a ILM object given a
+ *	key.  *	Returns a pointer to the ILM object, NULL on error. 
+ *
+ *	Remark: this function increases the refcount of the ILM object,
+ *	since it calls to mpls_ilm_hold. Caller is responsible to
+ *	release the object when it is no longer needed (by using
+ *	"mpls_ilm_release").
+ **/
+
+struct mpls_ilm* 
+mpls_get_ilm (unsigned int key) 
+{
+	struct mpls_ilm *ilm = NULL;
+
+	rcu_read_lock();
+	ilm = radix_tree_lookup (&mpls_ilm_tree,key);
+	smp_read_barrier_depends();
+	if (likely(ilm))
+		mpls_ilm_hold(ilm);
+
+	rcu_read_unlock();
+	return ilm;
+}
+
+/**
+ *	mpls_get_ilm_by_label - Get a reference to a ILM given an incoming
+ *	   label/labelspace.
+ *	@label:      Incoming label from network core.
+ *	@labelspace: Labelspace of the incoming interface.
+ *	@bos:        Status of BOS for the current label being processed
+ *
+ *	Allows the caller to get a reference to the ILM object given the
+ *	label value, and incoming interface/labelspace.
+ *	Returns a pointer to the ILM object, NULL on error. 
+ *	Remark1: This function increases the refcount of the ILM object, since 
+ *		it calls "mpls_ilm_hold". Caller must release the object
+ *		when it is no longer needed.
+ *	Remark2: uses the function above.
+ **/
+
+struct mpls_ilm* 
+mpls_get_ilm_by_label (struct mpls_label *label, int labelspace, char bos) 
+{
+	struct mpls_ilm *ilm = NULL;
+
+	/* handle the reserved label range */
+	if (label->ml_type == MPLS_LABEL_GEN && label->u.ml_gen < 16) {
+		int want_bos = mpls_reserved[label->u.ml_gen].bos;
+		MPLS_DEBUG("%s\n",mpls_reserved[label->u.ml_gen].msg);
+		ilm = mpls_reserved[label->u.ml_gen].ilm;
+		if (unlikely(!ilm)) {
+			MPLS_DEBUG("invalid incoming label, dropping\n");
+			return NULL;
+		}
+		mpls_ilm_hold(ilm);
+		if ((want_bos && !bos) || (!want_bos && bos)) {
+			mpls_ilm_release (ilm);
+			MPLS_DEBUG("invalid incoming labelstack, dropping\n");
+			return NULL;
+		}
+	} else {
+		/* not reserved label */
+		ilm = mpls_get_ilm (mpls_label2key(labelspace,label));
+		if (unlikely(!ilm)) {
+			MPLS_DEBUG("unknown incoming label, dropping\n");
+			return NULL;
+		}
+	}
+	return ilm;
+}
+
+/**
+ *	mpls_destroy_in_instrs - Destroy ILM opcodes. 
+ *	@ilm:	ILM object
+ *
+ *	This function completely destroys the instruction list for this 
+ *	ILM object: it unregisters the opcodes from sysfs. When the 
+ *      refcnt of the instr reaches zero (a file may be opened) they 
+ *      will be freed.
+ *
+ *	ilm_instr is set to NULL.
+ **/
+
+void
+mpls_destroy_in_instrs (struct mpls_ilm *ilm) 
+{
+	MPLS_ENTER;
+	mpls_instrs_free (ilm->ilm_instr);
+	ilm->ilm_instr = NULL;
+	MPLS_EXIT;
+}
+
+/**
+ * 	mpls_set_in_instrs - Set Instruction list for this ILM. 
+ *	@mie:   Array of instruction elements set by user 
+ *	@lenth: Array lenght. Number of valid entries
+ *	@ilm:	The ILM object ('this')
+ *
+ *	Return 0 on success. Called in process context only and m
+ *	ay sleep
+ **/
+int
+mpls_set_in_instrs ( struct mpls_instr_elem *mie, int length,
+	struct mpls_ilm *ilm) 
+{
+	/* To store (tmp) the linked list of instr. */
+	struct mpls_instr *instr_list = NULL;
+	
+	/* Build temporary opcode set from mie */
+	if (!mpls_instrs_build(mie, &instr_list, length, MPLS_IN, ilm))
+		return -1;
+
+	/* Commit the new ones */
+	if (ilm->ilm_instr)
+		mpls_instrs_free(ilm->ilm_instr);
+	ilm->ilm_instr = instr_list;
+
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_set_in_label_instrs - define the incoming opcode set. 
+ *	@mir: request.
+ *
+ *	Updates the ILM object corresponding to the label/labelspace
+ *	in the request, by changing the instrs as given.
+ *
+ *	Returns 0 on success, or
+ *	   -ENXIO
+ *	   -ESRCH
+ *	   -EEXIST
+ *	   -1
+ **/
+
+int 
+mpls_set_in_label_instrs (struct mpls_instr_req *mir) 
+{
+	int labelspace           =  mir->mir_index;
+	struct mpls_label *ml    = &mir->mir_label;
+	unsigned int key         = mpls_label2key (labelspace,ml);
+	struct mpls_ilm *ilm = mpls_get_ilm(key);
+	int ret;
+
+	if (unlikely(!ilm))
+		return -ESRCH;
+
+	ret = mpls_set_in_instrs (mir->mir_instr,mir->mir_instr_length, ilm); 
+	mpls_ilm_release(ilm);
+	return ret;
+}
+
+/**
+ *	mpls_set_in_label_proto - change the proto driver on a ilm
+ *	@mil: request.
+ *
+ *	Updates the ILM object corresponding to the label/labelspace
+ *	in the request, by changing the proto driver as given.
+ *
+ *	Returns 0 on success or no change, or
+ *	   -ESRCH
+ *	   -EINVAL
+ */
+int 
+mpls_set_in_label_proto (struct mpls_in_label_req *mil)
+{
+	unsigned int key = mpls_label2key(mil->mil_label.ml_index,
+		&mil->mil_label);
+	struct mpls_ilm *ilm = mpls_get_ilm(key);
+	int retval = 0;
+	if (!ilm) {
+		retval = -ESRCH;
+		goto err_no_ilm;
+	}
+
+	if (ilm->ilm_proto->family != mil->mil_proto) {
+		struct mpls_prot_driver *prot =
+			mpls_proto_find_by_family(mil->mil_proto);
+		if (!prot) {
+			retval = -EINVAL;
+			goto err_no_prot;
+		}
+		if (ilm->ilm_proto)
+			mpls_proto_release(ilm->ilm_proto);
+		ilm->ilm_proto = prot;
+		ilm->u.dst.input = prot->local_deliver;
+	}
+
+err_no_prot:
+	mpls_ilm_release (ilm);
+err_no_ilm:
+	return retval;
+}
+
+/**
+ *	mpls_is_reserved_label - return 1 if label is reserved.
+ *	@label - label to check.
+ **/
+
+static inline int 
+mpls_is_reserved_label (const struct mpls_label *label)
+{
+	BUG_ON(!label);
+	if (unlikely((label->ml_type == MPLS_LABEL_GEN) &&
+		     (label->u.ml_gen > MPLS_IPV6_EXPLICIT_NULL) &&
+		     (label->u.ml_gen < 16))) {
+		return 1;
+	}
+	return 0;
+}
+
+
+
+
+/**
+ *	mpls_add_in_label - Add a label to the incoming tree.
+ *	@in : mpls_in_label_req
+ *
+ *	Process context entry point to add an entry (ILM) in the incoming label 
+ *	map database. It adds new corresponding node to the Incoming Radix Tree.
+ *	It sets the ILM object reference count to 1, the ilm age to jiffies, the
+ *	protocol to IPv4, the default instruction set (POP,PEEK) and initializes
+ *	both the dev_entry and nhlfe_entry lists. The node's key is set to the 
+ *	mapped	key from the label/labelspace in the request.
+ *
+ *	Returns 0 on success, or else.
+ *
+ *	Changes 
+ *	20031125 : RCAS 
+ *		o Verify that no node exists for the tree before alloc'ing 
+ *		  the ILM, so we can get out earlier in case we fail.
+ *	20041020 : JLEU
+ *		o Removed mpls_set_default_in_instrs()
+ **/
+
+int 
+mpls_add_in_label (const struct mpls_in_label_req *in) 
+{
+	struct mpls_ilm *ilm     = NULL; /* New ILM to insert */
+	struct mpls_label *ml    = NULL; /* Requested Label */
+	unsigned int key         = 0;    /* Key to use */
+	int retval               = 0;
+	struct mpls_instr_elem instr[2];
+
+	MPLS_ENTER;
+
+	BUG_ON(!in);
+	ml = (struct mpls_label *)&in->mil_label;
+
+	if (mpls_is_reserved_label(ml)) {
+		MPLS_DEBUG("Unable to add reserved label to ILM\n");
+		retval = -EINVAL;
+		goto error;
+	}
+
+	/* Obtain key */
+	key = mpls_label2key(/* labelspace*/ ml->ml_index, ml);
+
+	/* Check if the node already exists */ 
+	ilm = mpls_get_ilm(key);
+	if (unlikely(ilm)) {
+		printk (MPLS_ERR "MPLS: node %u already exists\n",key);
+		mpls_ilm_release(ilm);  
+		retval = -EEXIST;
+		goto error;
+	} 
+
+	/*
+	 * Allocate a new input Information/Label,
+	 */
+
+	instr[0].mir_direction = MPLS_IN;
+	instr[0].mir_opcode    = MPLS_OP_POP;
+	instr[1].mir_direction = MPLS_IN;
+	instr[1].mir_opcode    = MPLS_OP_PEEK;
+
+	ilm = mpls_ilm_dst_alloc (key, ml, in->mil_proto, instr, 2);
+	if (unlikely(!ilm)) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	/* Insert into ILM tree */
+	spin_lock_bh (&mpls_ilm_lock);
+	if (unlikely(mpls_insert_ilm(key,ilm))) {
+		mpls_ilm_release (ilm);
+		spin_unlock_bh (&mpls_ilm_lock);
+
+		ilm->u.dst.obsolete = 1;
+		dst_free (&ilm->u.dst);
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	mpls_ilm_hold(ilm);
+	spin_unlock_bh (&mpls_ilm_lock);
+
+	/* we have hold a refcnt to the ilm across mpls_ilm_event()
+	 * to make sure it can't disappear
+	 */
+	mpls_ilm_event(MPLS_CMD_NEWILM, ilm);
+	mpls_ilm_release(ilm);
+
+error:
+	MPLS_EXIT;
+	return retval;
+}
+
+/**
+ *	__mpls_del_in_label - send delete event and schedule ILM for freeing
+ *	@in : mpls_ilm
+ *
+ *	This function does the work of actually 'free'ing a ILM datastructure.
+ *	It first send a event notifing userland that the ILM is going a way,
+ *	then delete the instructions removed reference to the proto driver,
+ *	then finally schedules the ILM for freeing.
+ *
+ *	This functions much be called holding a reference to the ILM,
+ *	At this point it is the ONLY reference to the ILM (it should have
+ *	been removed from the tree or the array) When this functions exits
+ *	ilm is nolonger valid ...
+ **/
+void __mpls_del_in_label(struct mpls_ilm *ilm) {
+	/* we're still holding a ref to the ilm, so it is safe to
+	 * call mpls_ilm_event
+	 */
+	mpls_ilm_event(MPLS_CMD_DELILM, ilm);
+
+	/* remove the instructions from the ILM, so ass to release
+	 * our references to NHLFEs
+	 */
+	mpls_destroy_in_instrs (ilm);
+        mpls_proto_release(ilm->ilm_proto);
+	ilm->ilm_proto = NULL;
+
+	/* release the refcnt we aquired in mpls_get_ilm() */
+	mpls_ilm_release (ilm);
+
+	/* tell the dst system this one is ready for removal */
+	ilm->u.dst.obsolete = 1;
+	call_rcu(&ilm->u.dst.rcu_head, dst_rcu_free);
+}
+
+/**
+ *	mpls_del_in_label - Del a label from the incoming tree (ILM)
+ *	@in : mpls_in_label_req
+ *
+ *	User context entry point, this function removes an incoming label
+ *	from the incoming radix tree (that is, from the ILM). It constructs
+ *	the associated key from the label/labelspace in the request, and 
+ *	updates the passed struct with the ILM information. 
+ **/
+
+int 
+mpls_del_in_label(struct mpls_in_label_req *in) 
+{
+	struct mpls_ilm *ilm = NULL;
+	struct mpls_label   *ml  = NULL; 
+	unsigned int key         = 0;
+
+	MPLS_ENTER;
+	BUG_ON(!in);
+	ml  = &in->mil_label;
+	key = mpls_label2key(/* labelspace*/ ml->ml_index, ml);
+
+	ilm = mpls_get_ilm(key);
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("Node %u was not in tree\n",key);
+		MPLS_EXIT;
+		return  -ESRCH;
+	}
+
+	spin_lock_bh (&mpls_ilm_lock);
+
+	if (atomic_read(&ilm->u.dst.__refcnt) != 2) {
+		/* someone else is hold a refcnt, we can't delete */
+
+		/* release the refcnt we aquired in mpls_get_ilm() */
+		mpls_ilm_release (ilm);
+		spin_unlock_bh (&mpls_ilm_lock);
+
+		MPLS_DEBUG("Node %u is being used\n",key);
+		MPLS_EXIT;
+		return -EBUSY;
+        }
+
+	/*
+	 * Remove a ILM from the tree
+	 */
+	ilm = mpls_remove_ilm(key);
+
+	spin_unlock_bh (&mpls_ilm_lock);
+
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("Node %u was not in tree\n",key);
+		MPLS_EXIT;
+		return  -ESRCH;
+	}
+
+	__mpls_del_in_label(ilm);
+
+	MPLS_EXIT;
+	return 0; 
+}
+
+/**
+ *	mpls_attach_in2out - Establish a xconnect between a ILM and a NHLFE.
+ *	@req : crossconnect request. 
+ *
+ *	Establishes a "cross-connect", a forwarding entry. The incoming label
+ *	is swapped to the outgoing one. Given the incoming label and label
+ *	space 
+ *
+ *	(req), this function updates the ILM object so we change the last instr 
+ *	from DLV/PEEK to FWD, whose opcode data is a held ref. to the new NHLFE 
+ *	(as given by the key in req).
+ *	Returns 0 on success. Process context only.
+ *
+ *	Remarks:
+ *	    o Be careful when  detroying the NHLFE  object (you should dettach
+ *	      the xconnect in order to release the NHLFE)
+ *
+ *	Changes:
+ *	o 20040120 RCAS: Removed kfree((unsigned short*)mi->mi_data);
+ *	               for DLV (data in DLV opcode is NULL).
+ *	o 20040127 RCAS: Instruction Linked list.	
+ **/
+
+int 
+mpls_attach_in2out(struct mpls_xconnect_req *req) 
+{
+	struct mpls_instr       *mi  = NULL; 
+	struct mpls_nhlfe    *nhlfe = NULL;
+	struct mpls_ilm     *ilm = NULL;
+	unsigned short op = 0;
+	int  labelspace, key;
+
+	MPLS_ENTER;
+	labelspace = req->mx_in.ml_index;
+
+	/* Hold a ref to the ILM */
+	key = mpls_label2key(labelspace,&(req->mx_in));
+	ilm = mpls_get_ilm(key);
+	if (unlikely(!ilm))  {
+		MPLS_DEBUG("Node %u does not exist in radix tree\n",key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/* Hold a ref to the NHLFE */
+	key = mpls_label2key(0,&(req->mx_out));
+	nhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("Node %u does not exist in radix tree\n",key);
+		mpls_ilm_release(ilm);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	if (unlikely(!ilm->ilm_instr)) {
+		MPLS_DEBUG("No instruction Set!")
+		mpls_ilm_release(ilm);
+		mpls_nhlfe_release(nhlfe);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+
+
+	/*
+	 * Update the instructions: now, instead of "DLV"/"PEEK", now
+	 * we "FWD". The NHLFE is not released (is held by the opcode). 
+	 */
+
+	/* Lookup the last instr */
+	for (mi = ilm->ilm_instr; mi->mi_next;mi = mi->mi_next); /* nop*/
+
+	op = mi->mi_opcode;
+
+	switch (op) {
+		case MPLS_OP_DLV:
+			mi->mi_opcode = MPLS_OP_FWD;
+			mi->mi_data   = (void*)nhlfe;
+			break;
+		case MPLS_OP_FWD:
+			mpls_xc_event(MPLS_CMD_DELXC, ilm,
+				_mpls_as_nhlfe(mi->mi_data));
+			mpls_nhlfe_release(_mpls_as_nhlfe(mi->mi_data));
+			mi->mi_data   = (void*)nhlfe;
+			break;
+		case MPLS_OP_PEEK:
+			mi->mi_opcode = MPLS_OP_FWD;
+			mi->mi_data   = (void*)nhlfe;
+			break;
+	}
+	mpls_xc_event(MPLS_CMD_NEWXC, ilm, nhlfe);
+	mpls_ilm_release(ilm);
+	return 0; 
+}
+
+
+
+
+/**
+ *	mpls_dettach_in2out - Dettach a xconnect between a ILM and a NHLFE.
+ *	@req : crossconnect request. 
+ *
+ *	Dettaches a "cross-connect", a forwarding entry. Checks if the latest 
+ *	instruction is a FWD and updates it to a PEEK. Releases the
+ *	corresponding NHLFE (cf. mpls_attach_in2out).
+ *
+ *	Returns 0 on success. Process context only.
+ **/
+
+int 
+mpls_detach_in2out(struct mpls_xconnect_req *req) 
+{
+	struct mpls_instr       *mi  = NULL;
+	struct mpls_nhlfe    *nhlfe = NULL;
+	struct mpls_ilm     *ilm = NULL;
+	unsigned int     key = 0;
+	int labelspace;
+	int ret = 0;
+
+	MPLS_ENTER;
+	BUG_ON(!req);
+
+	/* Hold a ref to the ILM, The 'in' segment */ 
+	labelspace = req->mx_in.ml_index;
+	key        = mpls_label2key(labelspace,&(req->mx_in));
+	ilm = mpls_get_ilm(key);
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("Node %u does not exist in radix tree\n",key);
+		ret = -ESRCH;
+		goto err_no_ilm;
+	}
+
+	/* Check that there is an instruction set! */
+	if (unlikely(!ilm->ilm_instr)) {
+		MPLS_DEBUG("No instruction Set!")
+		ret = -ESRCH;
+		goto err_no_ilm_instr;
+	}
+
+
+	/* Fetch the last instr, make sure it is FWD*/
+	for (mi = ilm->ilm_instr; mi->mi_next;mi = mi->mi_next); /* nop*/
+
+	if (!mi   ||   mi->mi_opcode != MPLS_OP_FWD) {
+		MPLS_DEBUG("opcode not found!\n");
+		ret = -ENXIO;
+		goto err_no_fwd;
+	}
+
+	/* Get the current held nhlfe for the last in instr */
+	nhlfe = mi->mi_data;
+	key = mpls_label2key(0,&(req->mx_out));
+
+	/* Make sure it is the good nhlfe */
+	if (!nhlfe ||  key != nhlfe->nhlfe_key) {
+		/* Do not release the NHLFE, it was invalid */ 
+		MPLS_DEBUG("Invalid NHLFE  %u\n",key);
+		ret = -ENXIO;
+		goto err_no_nhlfe;
+	}
+
+	/* The new last opcode for this ILM is now peek */
+	mi->mi_opcode = MPLS_OP_PEEK;
+	/* With no data */
+	mi->mi_data   = NULL; 
+
+	/* Release the NHLFE held by the Opcode (cf. mpls_attach_in2out) */
+
+	mpls_xc_event(MPLS_CMD_DELXC, ilm, nhlfe);
+	mpls_nhlfe_release(nhlfe); 
+	ret = 0;
+err_no_nhlfe:
+err_no_fwd:
+	/* Release the ILM after use */
+	mpls_ilm_release(ilm);
+err_no_ilm_instr:
+err_no_ilm:
+	MPLS_EXIT;
+	return ret;
+}
+
+/**
+ * 	mpls_init_reserved_label - Add an ILM object for a reserved label
+ *	@label - reserved generic label value
+ *	@ilm - ILM object to used for reserved label
+ *
+ *	Returns 0 on success
+ **/
+
+int 
+mpls_add_reserved_label (int label, struct mpls_ilm* ilm)
+{
+	BUG_ON(label < 0 || label > 15);
+
+	if (mpls_reserved[label].ilm)
+		return -EEXIST;
+
+	mpls_ilm_hold(ilm);
+	mpls_reserved[label].ilm = ilm;
+
+	return 0;
+}
+
+/**
+ * 	mpls_del_reserved_label - remove the ILM object for a reserved label
+ *	@label - reserved generic label value
+ *
+ *	Return the ILM object for the user to release
+ *
+ **/
+
+struct mpls_ilm*
+mpls_del_reserved_label (int label)
+{
+	struct mpls_ilm* ilm;
+	BUG_ON(label < 0 || label > 15);
+
+	ilm = mpls_reserved[label].ilm;
+	mpls_reserved[label].ilm = NULL;
+	return ilm;
+}
+
+int __init mpls_ilm_init(void)
+{
+	ilm_dst_ops.kmem_cachep =
+		kmem_cache_create("ilm_dst_cache", sizeof(struct mpls_ilm), 0,
+				  SLAB_HWCACHE_ALIGN, NULL);
+                                                                                
+	if (!ilm_dst_ops.kmem_cachep) {
+		printk(MPLS_ERR "MPLS: failed to alloc ilm_dst_cache\n");
+		return -ENOMEM;
+	}
+        printk("MPLS_ILM_INIT PASS ........");
+	return 0;
+}
+
+void __exit mpls_ilm_exit(void)
+{
+	if (ilm_dst_ops.kmem_cachep)
+	{
+		kmem_cache_destroy(ilm_dst_ops.kmem_cachep);
+		printk("MPLS_ILM_EXIT PASS ........");
+	}
+	return;
+}
+
+EXPORT_SYMBOL(__mpls_del_in_label);
+EXPORT_SYMBOL(mpls_ilm_dst_alloc);
+EXPORT_SYMBOL(mpls_add_reserved_label);
+EXPORT_SYMBOL(mpls_del_reserved_label);
diff -Nur linux-3.14.1/net/mpls/mpls_init.c linux-3.14.1_mpls/net/mpls/mpls_init.c
--- linux-3.14.1/net/mpls/mpls_init.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_init.c	2014-04-23 09:42:36.951900266 +0530
@@ -0,0 +1,275 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ * 20031126 RCAS 
+ *      - Split netdev_event callback. 
+ * 20040116 RCAS 
+ *      - Error Checking in init function 
+ * 20040127 RCAS 
+ *      - If a down interface was referenced by a ILM/NHLFE, destroy ILM/NHLFE
+ *	instructions if interface goes down/unregged.
+ * 20050829 JLEU
+ *	- move to shim interface
+ * 20051206 JLEU
+ *	- move shim code to seperate file
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+
+/**
+ * MODULE Information and attributes
+ *
+ **/
+
+MODULE_AUTHOR("James R. Leu <jleu@mindspring.com>, Ramon Casellas <casellas@infres.enst.fr>");
+MODULE_DESCRIPTION("MultiProtocol Label Switching protocol");
+MODULE_LICENSE("GPL");
+#if 0
+MODULE_ALIAS_NETPROTO(PF_MPLS);
+#endif
+
+/*****
+ * Packet Type for MPLS Unicast Traffic register info.
+ *
+ **/
+
+static struct packet_type mpls_uc_packet_type = {
+	.type = __constant_htons(ETH_P_MPLS_UC), /* MPLS Unicast PID */
+	.dev  = NULL,                            /* All devices */
+	.func = mpls_skb_recv,
+};
+
+/*****
+ * Packet Type for MPLS Multicast Traffic register info.
+ *
+ **/
+
+static struct packet_type mpls_mc_packet_type = {
+	.type = __constant_htons(ETH_P_MPLS_MC),
+	.dev  = NULL,
+	.func = mpls_skb_recv_mc, /* MPLS multicast receive method */
+};
+
+/**
+ *	mpls_release_netdev_in_nhlfe - Release the held device if it goes down.
+ *	@dev: network device (for which the notification is sent).
+ *
+ *	NHLFE objects hold a reference to the used outgoing device in the SET op
+ *	data. When the MPLS subsystem is notified that a device is going down
+ *	or unregistered, this function destroys the instructions for those NHLFE
+ **/
+
+static int 
+mpls_release_netdev_in_nhlfe (struct mpls_interface *mif)
+{
+	struct mpls_nhlfe	*holder = NULL;
+	struct list_head        *pos    = NULL;
+	struct list_head        *tmp    = NULL;
+
+	/* Iterate all NHLFE objects present in the list_out of the interface.*/
+	list_for_each_safe(pos,tmp,&mif->list_out) {
+
+		/* Get the holder / owner NHLFE */ 
+		holder = list_entry(pos,struct mpls_nhlfe ,dev_entry);
+
+		/* Destroy the instruction list */
+		mpls_destroy_out_instrs(holder);
+	}
+	return NOTIFY_DONE;
+}
+
+
+
+/**
+ *	mpls_release_netdev_in_ilm - Release the held device if it goes down.
+ *	@dev: network device (for which the notification is sent).
+ *
+ *	ILM objects hold a reference to the 'faked' incoming device (SET_RX op)
+ *	data. When the MPLS subsystem is notified that a device is going down
+ *	or unregistered, this function destroys the instructions for those ILM 
+ **/
+
+static int 
+mpls_release_netdev_in_ilm (struct mpls_interface *mif)
+{
+	struct mpls_ilm         *holder = NULL;
+	struct list_head        *pos    = NULL;
+	struct list_head        *tmp    = NULL;
+
+	/* Iterate all ILM objects present in the list_in of the interface.*/
+	list_for_each_safe(pos,tmp,&mif->list_in) {
+		holder = list_entry(pos, struct mpls_ilm,dev_entry);
+
+		/* Destroy the instruction list */
+		mpls_destroy_in_instrs(holder);
+	}
+	return NOTIFY_DONE;
+}
+
+/**
+ *	mpls_netdev_event - Netdevice notifier callback.
+ *	@this: block notifier used.
+ *	@event:  UP/DOWN, REGISTER/UNREGISTER... 
+ *	@ptr: (struct net_device*)
+ *	Receives events for the interfaces
+ *
+ *	RCAS 20031126: 
+ *		o Split
+ **/
+
+static int 
+mpls_netdev_event (struct notifier_block *this, unsigned long event, void *ptr)
+{
+	struct net_device *dev = ptr;
+	struct mpls_interface *mif = mpls_get_if_info(dev->ifindex);
+	if (!mif)
+		return NOTIFY_DONE;
+
+	/*
+	 * Only continue for MPLS enabled interfaces 
+	 */
+	if (!mif) 
+		return NOTIFY_DONE;
+
+	switch (event) {
+		case NETDEV_UNREGISTER:
+			mpls_release_netdev_in_nhlfe(mif);
+			mpls_release_netdev_in_ilm(mif);
+			break;
+		case NETDEV_DOWN:
+		case NETDEV_CHANGEMTU:
+		case NETDEV_UP:
+		case NETDEV_CHANGE:
+			break;
+	}
+	return NOTIFY_DONE;
+}
+
+/** 
+ * Netdevice notifier callback register info
+ *
+ **/
+static struct notifier_block mpls_netdev_notifier = {
+	.notifier_call =  mpls_netdev_event,
+};
+
+/**
+ * MPLS Module entry point.
+ **/
+
+static int __init 
+mpls_init_module (void) 
+{
+	int err;
+	printk(MPLS_INF "MPLS: version %d.%d%d%d\n",
+			(MPLS_LINUX_VERSION >> 24) & 0xFF,
+			(MPLS_LINUX_VERSION >> 16) & 0xFF,
+			(MPLS_LINUX_VERSION >> 8) & 0xFF,
+			(MPLS_LINUX_VERSION) & 0xFF);
+
+	/* Init Input Radix Tree */
+	if ((err = mpls_ilm_init()))
+		return err;
+	/* Init Output Radix Tree */
+	if ((err = mpls_nhlfe_init()))
+		return err;
+	/* Init MPLS Destination Cache Management */
+	if ((err = mpls_dst_init()))
+		return err;
+#ifdef CONFIG_PROC_FS
+	/* MPLS ProcFS Subsystem */
+	if ((err = mpls_procfs_init()))
+		return err;
+#endif
+#ifdef CONFIG_SYSCTL
+	if ((err = mpls_sysctl_init()))
+		return err;
+#endif
+	/* Netlink configuration interface */
+	if ((err = mpls_netlink_init()))
+		return err;
+
+	/* register shim protocol */
+	mpls_shim_init();
+
+	/* Layer 3 protocol driver initialization */
+	mpls_proto_init();
+
+	/* packet handlers, and netdev notifier */
+	dev_add_pack(&mpls_uc_packet_type);
+	dev_add_pack(&mpls_mc_packet_type);
+	register_netdevice_notifier(&mpls_netdev_notifier);
+
+	return 0;
+}
+
+/**
+ *	mpls_exit_module - Module Exit Cleanup Routine
+ *
+ *	mpls_exit_module is called just before the module is removed
+ *	from memory.
+ **/
+
+static void __exit 
+mpls_exit_module (void)
+{
+	unregister_netdevice_notifier(&mpls_netdev_notifier);
+	dev_remove_pack(&mpls_mc_packet_type);
+	dev_remove_pack(&mpls_uc_packet_type);
+	mpls_shim_exit();
+	mpls_proto_exit();
+	mpls_netlink_exit();
+#ifdef CONFIG_SYSCTL
+	mpls_sysctl_exit();
+#endif
+#ifdef CONFIG_PROC_FS
+	mpls_procfs_exit();
+#endif
+	mpls_dst_exit();
+	mpls_nhlfe_exit();
+	mpls_ilm_exit();
+
+	synchronize_net();
+
+	printk("MPLS: version %d.%d%d%d exiting\n",
+		(MPLS_LINUX_VERSION >> 24) & 0xFF,
+		(MPLS_LINUX_VERSION >> 16) & 0xFF,
+		(MPLS_LINUX_VERSION >> 8) & 0xFF,
+		(MPLS_LINUX_VERSION & 0xFF));
+}
+
+/**
+ *
+ * variables controled via sysctl
+ *
+ **/
+int sysctl_mpls_debug = 0;
+int sysctl_mpls_default_ttl = 255;
+
+module_init(mpls_init_module);
+module_exit(mpls_exit_module);
+
+EXPORT_SYMBOL(sysctl_mpls_debug);
+EXPORT_SYMBOL(sysctl_mpls_default_ttl);
diff -Nur linux-3.14.1/net/mpls/mpls_input.c linux-3.14.1_mpls/net/mpls/mpls_input.c
--- linux-3.14.1/net/mpls/mpls_input.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_input.c	2014-04-23 09:53:08.019966666 +0530
@@ -0,0 +1,305 @@
+/*****************************************************************************
+ *	MPLS
+ *	     An implementation of the MPLS (MultiProtocol Label
+ *	     Switching Architecture) for Linux.
+ *
+ *	Authors:
+ *	         James Leu        <jleu@mindspring.com>
+ *	         Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	  (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *	  (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	     This program is free software; you can redistribute it and/or
+ *	     modify it under the terms of the GNU General Public License
+ *	     as published by the Free Software Foundation; either version
+ *	     2 of the License, or (at your option) any later version.
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/if_ether.h>
+#include <linux/if_vlan.h>
+#include <linux/if_arp.h>
+#include <linux/kobject.h>
+#include <net/ip.h>
+#include <net/icmp.h>
+#ifdef CONFIG_IPV6
+#include <net/ipv6.h>
+#endif
+#include <net/mpls.h>
+
+
+/**
+ *	mpls_input - Begin labelled packet processing.
+ *	@skb:        socket buffer, containing the good stuff.
+ *	@dev:        device that receives the packet.
+ *	@pt:         packet type (handler) structure.
+ *	@label:      label value + metadata (type)
+ *	@labelspace: incoming labelspace.
+ **/
+
+static int 
+mpls_input (struct sk_buff        *skb, struct net_device *dev,
+            struct packet_type    *pt, struct mpls_label *label,
+	    int labelspace) 
+{
+	MPLS_IN_OPCODE_PROTOTYPE(*func);   /* Function Pointer for Opcodes */
+	struct mpls_prot_driver *prot = NULL;
+	struct mpls_nhlfe *nhlfe = NULL;  /* Current NHLFE                  */
+	struct mpls_ilm  *ilm = NULL;  /* Current ILM                  */
+	struct mpls_instr    *mi  = NULL;
+	void *data = NULL;                 /* current data for opcode      */
+	int  opcode = 0;                   /* Current opcode to execute    */
+	char *msg = NULL;                  /* Human readable desc. opcode  */
+	int retval;
+
+	MPLS_ENTER;
+
+mpls_input_start:
+
+	if (ilm) {
+		/* we only hit this case when we have a recursive label
+		 * lookup.  drop the previous protocol driver, and ilm
+		 */
+		mpls_proto_release(MPLSCB(skb)->prot);
+		mpls_ilm_release(ilm);
+	}
+
+	MPLS_DEBUG("labelspace=%d,label=%d,exp=%01x,B.O.S=%d,TTL=%d\n",
+		labelspace, MPLSCB(skb)->label, MPLSCB(skb)->exp,
+		MPLSCB(skb)->bos, MPLSCB(skb)->ttl);
+
+	/* GET a reference to the ilm given this label value/labelspace*/
+	ilm = mpls_get_ilm_by_label (label, labelspace, MPLSCB(skb)->bos);
+	if (unlikely(!ilm)) {
+		MPLS_DEBUG("unknown incoming label, dropping\n");
+		goto mpls_input_drop;
+	}
+
+	mpls_proto_hold(ilm->ilm_proto);
+	MPLSCB(skb)->prot = ilm->ilm_proto;
+
+	ilm->ilm_stats.packets++;
+	ilm->ilm_stats.bytes += skb->len;
+
+	/* Iterate all the opcodes for this ILM */
+	for (mi = ilm->ilm_instr; mi; mi = mi->mi_next) {
+		data   = mi->mi_data;
+		opcode = mi->mi_opcode;
+		msg    = mpls_ops[opcode].msg;
+		func   = mpls_ops[opcode].in;
+
+		MPLS_DEBUG("opcode %s\n",msg);
+		if (!func) {
+			MPLS_DEBUG("invalid opcode for input: %s\n",msg);
+			goto mpls_input_drop;
+		}
+
+		switch (func(&skb,ilm,&nhlfe,data)) {
+			case MPLS_RESULT_RECURSE:
+				label->ml_type = MPLS_LABEL_GEN;
+				label->u.ml_gen = MPLSCB(skb)->label;
+				goto mpls_input_start;
+			case MPLS_RESULT_DLV:
+				goto mpls_input_dlv;
+			case MPLS_RESULT_FWD:
+				goto mpls_input_fwd;
+			case MPLS_RESULT_DROP:
+				mpls_proto_release(MPLSCB(skb)->prot);
+				goto mpls_input_drop;
+			case MPLS_RESULT_SUCCESS:
+				break;
+		}
+	}
+	MPLS_DEBUG("finished executing in label program without DLV or FWD\n");
+	mpls_proto_release(MPLSCB(skb)->prot);
+
+	/* fall through to drop */
+
+mpls_input_drop:
+
+	/* proto driver isn't held yet, no need to release it */
+	if (ilm) {
+		ilm->ilm_drops++;
+		mpls_ilm_release(ilm);
+	}
+	MPLS_DEBUG("dropped\n");
+	return NET_RX_DROP;
+
+mpls_input_dlv:
+
+	dst_hold(&ilm->u.dst);
+	skb_dst_set(skb, &ilm->u.dst);
+
+	/*
+	 * clean up the packet so that protocols like DHCP
+	 * will work across a LSP
+	 */
+	if (ilm->ilm_fix_hh) {
+		if (mpls_finish(skb) == NULL) {
+			MPLS_DEBUG("unable to finish skb\n");
+			return NET_RX_DROP;
+		}
+	}
+
+	mpls_ilm_release(ilm);
+
+	/* ala Cisco, take the lesser of the TTLs
+	 * -if propogate TTL was done at the ingress LER, then the
+	 *  shim TTL will be less the the header TTL
+	 * -if no propogate TTL was done as the ingress LER, a
+	 *  default TTL was placed in the shim, which makes the
+	 *  entire length of the LSP look like one hop to traceroute.
+	 *  As long as the default value placed in the shim is
+	 *  significantly larger then the TTL in the header, then
+	 *  traceroute will work fine.  If not, then traceroute
+	 *  will continualy show the egress of the LSP as the
+	 *  next hop in the path.
+	 */
+	
+	if (MPLSCB(skb)->ttl < MPLSCB(skb)->prot->get_ttl(skb)) {
+		MPLSCB(skb)->prot->set_ttl(skb, MPLSCB(skb)->ttl);
+	}
+
+	/* we're done with the PDU, it now goes to another layer for handling
+	 * it is safe to release the protocol driver now
+	 */
+	mpls_proto_release(MPLSCB(skb)->prot);
+
+	MPLS_DEBUG("delivering\n");
+
+	return 0;
+
+mpls_input_fwd:
+
+	mpls_ilm_release (ilm);
+
+	if (MPLSCB(skb)->ttl <= 1) {
+		printk("TTL exceeded\n");
+
+		prot = MPLSCB(skb)->prot;
+		retval = prot->ttl_expired(&skb);
+		mpls_proto_release(prot);
+
+		if (retval)
+			return retval;
+
+		/* otherwise prot->ttl_expired() must have modified the
+		 * skb and want it to be forwarded down the LSP
+		 */
+	}
+	
+	(MPLSCB(skb)->ttl)--;
+
+	dst_hold(&nhlfe->u.dst);
+	skb_dst_set(skb, &nhlfe->u.dst);
+
+	/* mpls_switch() does a mpls_proto_release() */
+
+	MPLS_DEBUG("switching\n");
+
+	return 0;
+}
+
+/**
+ *	mpls_skb_recv - Main MPLS packet receive function.
+ *	@skb : socket buffer, containing the good stuff.
+ *	@dev : device that receives the packet.
+ *	@pt  : packet type handler.
+ **/
+
+int 
+mpls_skb_recv (
+	struct sk_buff     *skb, 
+	struct net_device  *dev,
+	struct packet_type *pt,
+	struct net_device  *orig)
+{
+	int labelspace;
+	int result = NET_RX_DROP;
+	struct mpls_label label;
+	struct mpls_interface *mip = mpls_get_if_info(dev->ifindex);
+
+	MPLS_ENTER;
+	MPLS_DEBUG_CALL(mpls_skb_dump(skb));
+
+	if (skb->pkt_type == PACKET_OTHERHOST)
+		goto mpls_rcv_drop;
+
+	if (!(skb = skb_share_check (skb, GFP_ATOMIC)))
+		goto mpls_rcv_out;
+
+	if (!pskb_may_pull (skb, MPLS_SHIM_SIZE))
+		goto mpls_rcv_err;
+
+	labelspace = mip ? mip->labelspace : -1;
+	if (unlikely(labelspace < 0)) {
+		MPLS_DEBUG("unicast packet recv on if. w/o labelspace (%s) - packet dropped\n",dev->name);
+		goto mpls_rcv_drop;
+	}
+
+	memset(MPLSCB(skb), 0, sizeof(*MPLSCB(skb)));
+	memset(&label, 0, sizeof(label));
+	MPLSCB(skb)->top_of_stack = skb->data;
+
+	mpls_opcode_peek (skb);
+
+	/* we need the label struct for when we support ATM and FR */
+	switch(dev->type) {
+		case ARPHRD_ETHER:
+		case ARPHRD_FDDI:
+		case ARPHRD_IEEE802:
+		case ARPHRD_PPP:
+		case ARPHRD_LOOPBACK:
+		case ARPHRD_HDLC:
+		case ARPHRD_IPGRE:
+			label.ml_type  = MPLS_LABEL_GEN;
+			label.u.ml_gen = MPLSCB(skb)->label;
+			break;
+		default:
+			printk("Unknown IfType(%08x) for MPLS\n",dev->type);
+			goto mpls_rcv_err;
+	}
+
+	if (mpls_input (skb,dev,pt,&label,labelspace))
+		goto mpls_rcv_drop;
+
+	result = dst_input(skb);
+
+	MPLS_DEBUG("exit(%d)\n",result);
+	return result;
+
+mpls_rcv_err:
+	/* increment some err counter */
+mpls_rcv_drop:
+	kfree_skb (skb);
+mpls_rcv_out:
+	MPLS_DEBUG("exit(DROP)\n");
+	return NET_RX_DROP;
+}
+
+
+
+
+
+/**
+ *	mpls_skb_recv_mc - Main Multicast MPLS packet receive function.
+ *	@skb : socket buffer, containing the good stuff.
+ *	@dev : device that receives the packet.
+ *	@pt  : packet handler. (MPLS UC)
+ **/
+
+int mpls_skb_recv_mc (
+	struct sk_buff     *skb,
+	struct net_device  *dev,
+	struct packet_type *pt,
+	struct net_device  *orig)
+{
+	kfree_skb(skb);
+	MPLS_DEBUG("Not implemented\n");
+	return NET_RX_DROP;
+}
diff -Nur linux-3.14.1/net/mpls/mpls_instr.c linux-3.14.1_mpls/net/mpls/mpls_instr.c
--- linux-3.14.1/net/mpls/mpls_instr.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_instr.c	2014-04-23 09:56:00.497798326 +0530
@@ -0,0 +1,207 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	      It implements:
+ *	      -instruction maintainace
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes
+ *	JLEU: convert rt_cache_flush() to mpls_proto_cache_flush_all()
+ *
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <net/neighbour.h>
+#include <net/route.h>
+#include <net/mpls.h>
+
+
+/**
+ *	mpls_instr_alloc - Allocate a mpls_instruction object
+ *	@opcode: opcode num.
+ **/
+
+struct mpls_instr*
+mpls_instr_alloc (unsigned short opcode)
+{
+	struct mpls_instr  *mi;
+
+	mi = kmalloc(sizeof(struct mpls_instr), GFP_ATOMIC);
+	if (likely(mi)) {
+		memset (mi, 0, sizeof(struct mpls_instr));
+		mi->mi_opcode = opcode;
+	}
+	return mi;
+}
+
+/**
+ *	mpls_instr_release - destructor for mpls instruction.
+ *	@mi: this instruction
+ *
+ **/
+
+void 
+mpls_instr_release (struct mpls_instr *mi)
+{
+	unsigned short op	= mi->mi_opcode;
+	void *data		= mi->mi_data;
+	void *parent		= mi->mi_parent;
+	enum mpls_dir dir	= mi->mi_dir;
+
+	MPLS_ENTER;
+
+	if ((mpls_ops[op].cleanup) && data) 
+		mpls_ops[op].cleanup (data, parent, dir);
+
+	/* Poisson */
+	memset(mi,0xae,sizeof(struct mpls_instr));
+	kfree (mi);
+	MPLS_EXIT;
+}
+
+
+/**
+ *	mpls_instrs_free - free an instruction set. 
+ *	@instr:       Instruction list 
+ *
+ **/
+ 
+void
+mpls_instrs_free (struct mpls_instr *list)
+{
+	struct mpls_instr* mi  = list;
+	struct mpls_instr *tmp = NULL;
+
+	MPLS_ENTER;
+	while (mi) {
+		tmp = mi->mi_next;
+		mpls_instr_release (mi);
+		mi = tmp;
+	}
+	MPLS_EXIT;
+}
+
+/**
+ *	mpls_instrs_build - build up an instruction set. 
+ *	@mie:	 Instruction Element array 
+ *	@instr:       Instruction list [OUT]
+ *	@length:      Number of valid entries in the array
+ *	@dir:	 MPLS_IN for ILMs (ILM) or MPLS_OUT for NHLFEs (NHLFE).
+ *	@parent:      ILM/NHLFE "parent object".
+ *
+ *	This function constructs a "instr/operation set", the set of 
+ *	opcodes to execute with the corresponding data for a given ILM/NHLFE
+ *	object.
+ *
+ *	Returns the number of valid entries.
+ **/
+ 
+int 
+mpls_instrs_build (struct mpls_instr_elem *mie, struct mpls_instr **instr, 
+	int length, enum mpls_dir  dir,   void *parent) 
+{
+	
+	struct mpls_instr **pmi = instr;  /* Instruction List */
+	unsigned short opcode = 0;	  /* Opcode interator */
+	unsigned short i = 0;		  /* Element iterator */
+	int num_push  = 0;		  /* Total # of pushes */
+	int last_able = 0;		  /* This must be true at end */
+	MPLS_BUILD_OPCODE_PROTOTYPE(*f);  /* Build Operation */
+	struct mpls_instr  *mi;		  /* MPLS Instruction Iterator */
+	void *data;
+	int ret       = -ENXIO;
+
+	MPLS_ASSERT(*instr == NULL);
+
+	/* Iterate the instr set */
+	for (i = 0; i < length; i++) {
+		opcode  = mie[i].mir_opcode;
+		f       = mpls_ops[opcode].build;
+		if (unlikely(!f))
+			goto rollback; 
+
+		mi      = mpls_instr_alloc(opcode); 
+		if (unlikely(!mi))
+			goto rollback;	
+
+		data    = NULL;
+		*pmi = mi;
+
+		/* Build the opcode.
+		 * Input : parent ILM/NHLFE, elem & direcion.
+		 * Output: cumul pushes for this ILM/NHLFE,last?, data */
+		ret = f(&mie[i],dir,parent,&data,&last_able,&num_push);
+		if (ret)
+			goto rollback; 
+
+		mi->mi_data   = data;
+		mi->mi_parent = parent;
+		mi->mi_dir    = dir;
+		pmi = &mi->mi_next;
+	}
+
+	/* Make sure the last one was valid */
+	if (!last_able) {
+		printk (KERN_ERR "MPLS: invalid last op %s, len = %d(%d)\n",
+			mpls_ops[opcode].msg, i, length);
+		goto rollback;
+	}
+
+	MPLS_ASSERT(*instr);
+
+	/*
+	 * it is possible that the MTU of a NHLFE may have changed.
+	 * to be paranoid, flush the layer 3 caches
+	 */
+	mpls_proto_cache_flush_all(&init_net);
+
+	return i;
+
+rollback:
+	mi  = *instr;
+	mpls_instrs_free(mi);
+	*instr = NULL;
+	return 0;
+}
+
+void
+mpls_instrs_unbuild(struct mpls_instr *instr, struct mpls_instr_req *req)
+{
+        MPLS_UNBUILD_OPCODE_PROTOTYPE(*func);
+        struct mpls_instr *mi;
+        int c = 0;
+
+        MPLS_ENTER;
+
+        for (mi = instr;mi;mi = mi->mi_next) {
+                req->mir_instr[c].mir_opcode = mi->mi_opcode;
+                func = mpls_ops[mi->mi_opcode].unbuild;
+
+                if (func)
+                        func(&req->mir_instr[c],mi->mi_data);
+                c++;
+        }
+
+        req->mir_instr_length = c;
+
+        MPLS_EXIT;
+}
+
+EXPORT_SYMBOL(mpls_instrs_build);
+EXPORT_SYMBOL(mpls_instrs_unbuild);
+EXPORT_SYMBOL(mpls_instrs_free);
diff -Nur linux-3.14.1/net/mpls/mpls_netlink.c linux-3.14.1_mpls/net/mpls/mpls_netlink.c
--- linux-3.14.1/net/mpls/mpls_netlink.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_netlink.c	2014-04-23 22:02:11.014042757 +0530
@@ -0,0 +1,880 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ *      NetLink Interface for MPLS subsystem
+ *
+ * Authors:
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2005   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	20051116 - jleu - convert to genetlink
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ *****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/netdevice.h>
+#include <net/arp.h>
+#include <net/sock.h>
+#include <net/mpls.h>
+#include <linux/netlink.h>
+#include <net/genetlink.h>
+#include <linux/gen_stats.h>
+#include <net/net_namespace.h>
+
+extern struct list_head mpls_ilm_list;
+extern struct list_head mpls_nhlfe_list;
+
+static struct genl_family genl_mpls = {
+	.id = PF_MPLS,
+	.name = "nlmpls",
+	.version = 0x1,
+	.maxattr = MPLS_ATTR_MAX,
+};
+
+/* ILM netlink support */
+
+static int mpls_fill_ilm(struct sk_buff *skb, struct mpls_ilm *ilm,
+	 u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_in_label_req mil;
+	struct gnet_stats_basic stats;
+	struct mpls_instr_req *instr;
+	void *hdr;
+
+	MPLS_ENTER;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	instr = kmalloc(sizeof(*instr), GFP_KERNEL);
+	if (unlikely(!instr))
+		goto nla_put_failure;
+
+	mil.mil_proto = ilm->ilm_proto->family;
+	memcpy(&mil.mil_label, &ilm->ilm_label, sizeof (struct mpls_label));
+	mpls_instrs_unbuild(ilm->ilm_instr, instr);
+	instr->mir_direction = MPLS_IN;
+	memcpy(&stats, &ilm->ilm_stats, sizeof(stats));
+	/* need to add drops here some how */
+
+	nla_put(skb, MPLS_ATTR_ILM, sizeof(mil), &mil);
+	nla_put(skb, MPLS_ATTR_INSTR, sizeof(*instr), instr);
+	nla_put(skb, MPLS_ATTR_STATS, sizeof(stats), &stats);
+
+	kfree(instr);
+
+	MPLS_EXIT;
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	if (instr)
+		kfree(instr);
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_ilm_event(int event, struct mpls_ilm *ilm)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_ilm(skb, ilm, 0, 0, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(ilm->ilm_proto->family, skb, 0, MPLS_GRP_ILM, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_ilm_new(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_in_label_req *mil;
+	struct mpls_instr_req *instr = NULL;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	if (!info->attrs[MPLS_ATTR_ILM])
+		return -EINVAL;
+
+	if (info->attrs[MPLS_ATTR_INSTR]) {
+		instr = nla_data(info->attrs[MPLS_ATTR_INSTR]);
+	}
+
+	mil = nla_data(info->attrs[MPLS_ATTR_ILM]);
+
+	if (info->nlhdr->nlmsg_flags&NLM_F_CREATE)
+		retval = mpls_add_in_label(mil);
+	else
+		retval = 0;
+
+	if ((!retval) && instr &&
+		mil->mil_change_flag & MPLS_CHANGE_INSTR) {
+		memcpy(&instr->mir_label, &mil->mil_label,
+			sizeof(struct mpls_label));
+		retval = mpls_set_in_label_instrs(instr);
+
+		/* JLEU: should revert to old instr on failure */
+		if (retval)
+			mpls_del_in_label(mil);
+	}
+
+	if ((!retval) && mil->mil_change_flag & MPLS_CHANGE_PROTO)
+		retval = mpls_set_in_label_proto(mil);
+
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_ilm_del(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_in_label_req *mil;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	mil = nla_data(info->attrs[MPLS_ATTR_ILM]);
+	retval = mpls_del_in_label(mil);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_ilm_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_in_label_req *mil;
+	struct mpls_ilm *ilm;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_ILM])
+		goto err;
+
+	mil = nla_data(info->attrs[MPLS_ATTR_ILM]);
+
+	if (mil->mil_label.ml_type == MPLS_LABEL_KEY)
+		goto err;
+
+	ilm = mpls_get_ilm(mpls_label2key(mil->mil_label.ml_index,
+		&mil->mil_label));
+	if (!ilm) {
+		retval = -ESRCH;
+	} else {
+		if (mpls_fill_ilm(skb, ilm, info->snd_portid, info->snd_seq,
+			0, MPLS_CMD_NEWILM) < 0)
+			retval = -EINVAL;
+
+		mpls_ilm_release (ilm);
+	}
+	retval = genlmsg_unicast(&init_net, skb, info->snd_portid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_ilm_dump(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	struct mpls_ilm *ilm;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	rcu_read_lock();
+	list_for_each_entry_rcu(ilm, &mpls_ilm_list, global) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		if (entry_count >= entries_to_skip) {
+			if (mpls_fill_ilm(skb, ilm, NETLINK_CB(cb->skb).portid,
+				cb->nlh->nlmsg_seq, NLM_F_MULTI,
+				MPLS_CMD_NEWILM) < 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	rcu_read_unlock();
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+/* NHLFE netlink support */
+
+static int mpls_fill_nhlfe(struct sk_buff *skb, struct mpls_nhlfe *nhlfe,
+	u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_out_label_req mol;
+	struct gnet_stats_basic stats;
+	struct mpls_instr_req *instr;
+	void *hdr;
+
+	MPLS_ENTER;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	instr = kmalloc(sizeof(*instr), GFP_KERNEL);
+	if (unlikely(!instr))
+		goto nla_put_failure;
+
+	mol.mol_label.ml_type = MPLS_LABEL_KEY;
+	mol.mol_label.u.ml_key = nhlfe->nhlfe_key;
+	mol.mol_mtu = nhlfe->nhlfe_mtu;
+	mol.mol_propagate_ttl = nhlfe->nhlfe_propagate_ttl;
+	mpls_instrs_unbuild(nhlfe->nhlfe_instr, instr);
+	instr->mir_direction = MPLS_OUT;
+	memcpy(&stats, &nhlfe->nhlfe_stats, sizeof(stats));
+	/* need to get drops added here some how */
+
+	nla_put(skb, MPLS_ATTR_NHLFE, sizeof(mol), &mol);
+	nla_put(skb, MPLS_ATTR_INSTR, sizeof(*instr), instr);
+	nla_put(skb, MPLS_ATTR_STATS, sizeof(stats), &stats);
+
+	kfree(instr);
+
+	MPLS_EXIT;
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	if (instr)
+		kfree(instr);
+
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_nhlfe_event(int event, struct mpls_nhlfe *nhlfe, int seq, int pid)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_nhlfe(skb, nhlfe, pid, seq, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(PF_MPLS, skb, 0, MPLS_GRP_NHLFE, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_nhlfe_new(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_out_label_req *mol;
+	struct mpls_instr_req *instr = NULL;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	if (!info->attrs[MPLS_ATTR_NHLFE])
+		return -EINVAL;
+
+	if (info->attrs[MPLS_ATTR_INSTR]) {
+		instr = nla_data(info->attrs[MPLS_ATTR_INSTR]);
+	}
+
+	mol = nla_data(info->attrs[MPLS_ATTR_NHLFE]);
+
+	if (info->nlhdr->nlmsg_flags&NLM_F_CREATE) {
+		if (mol->mol_label.ml_type != MPLS_LABEL_KEY ||
+		    mol->mol_label.u.ml_key)
+			retval = -EINVAL;
+		else {
+			retval = mpls_add_out_label(mol, info->snd_seq,
+				info->snd_portid);
+		}
+	} else {
+		retval = 0;
+	}
+
+	if ((!retval) && instr &&
+		mol->mol_change_flag & MPLS_CHANGE_INSTR) {
+		memcpy(&instr->mir_label, &mol->mol_label,
+			sizeof(struct mpls_label));
+		retval = mpls_set_out_label_instrs(instr);
+		/* JLEU: should revert to old instr on failure */
+	}
+
+	if ((!retval) &&  mol->mol_change_flag & MPLS_CHANGE_MTU)
+		retval = mpls_set_out_label_mtu(mol);
+
+	if ((!retval) && mol->mol_change_flag & MPLS_CHANGE_PROP_TTL)
+		retval = mpls_set_out_label_propagate_ttl(mol);
+
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_nhlfe_del(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_out_label_req *mol;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	mol = nla_data(info->attrs[MPLS_ATTR_NHLFE]);
+	retval = mpls_del_out_label(mol);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_nhlfe_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_out_label_req *mol;
+	struct mpls_nhlfe *nhlfe;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_NHLFE])
+		goto err;
+
+	mol = nla_data(info->attrs[MPLS_ATTR_NHLFE]);
+
+	if (mol->mol_label.ml_type != MPLS_LABEL_KEY)
+		goto err;
+
+	nhlfe = mpls_get_nhlfe(mol->mol_label.u.ml_key);
+	if (!nhlfe) {
+		retval = -ESRCH;
+	} else {
+		if (mpls_fill_nhlfe(skb, nhlfe, info->snd_portid, info->snd_seq,
+			0, MPLS_CMD_NEWNHLFE) < 0)
+			retval = -EINVAL;
+
+		mpls_nhlfe_release (nhlfe);
+	}
+	retval = genlmsg_unicast(&init_net, skb, info->snd_portid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_nhlfe_dump(struct sk_buff *skb,
+	struct netlink_callback *cb)
+{
+	struct mpls_nhlfe *nhlfe;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	rcu_read_lock();
+	list_for_each_entry_rcu(nhlfe, &mpls_nhlfe_list, global) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		if (entry_count >= entries_to_skip) {
+			if (mpls_fill_nhlfe(skb, nhlfe, NETLINK_CB(cb->skb).portid,
+				cb->nlh->nlmsg_seq, NLM_F_MULTI,
+				MPLS_CMD_NEWNHLFE) <= 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	rcu_read_unlock();
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+/* XC netlink support */
+
+static int mpls_fill_xc(struct sk_buff *skb, struct mpls_ilm *ilm,
+	struct mpls_nhlfe *nhlfe, u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_xconnect_req xc;
+	void *hdr;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	memcpy(&xc.mx_in, &ilm->ilm_label, sizeof (struct mpls_label));
+	xc.mx_out.ml_type = MPLS_LABEL_KEY;
+	xc.mx_out.u.ml_key = nhlfe->nhlfe_key;
+
+	nla_put(skb, MPLS_ATTR_XC, sizeof(xc), &xc);
+
+	MPLS_DEBUG("Exit: length\n");
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_xc_event(int event, struct mpls_ilm *ilm,
+	struct mpls_nhlfe *nhlfe)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_xc(skb, ilm, nhlfe, 0, 0, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(ilm->ilm_proto->family, skb, 0, MPLS_GRP_XC, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_xc_new(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_xconnect_req *xc;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	if (!info->attrs[MPLS_ATTR_XC])
+		return -EINVAL;
+
+	xc = nla_data(info->attrs[MPLS_ATTR_XC]);
+
+	if (!(info->nlhdr->nlmsg_flags&NLM_F_CREATE))
+		retval = -EINVAL;
+	else
+		retval = mpls_attach_in2out(xc);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_xc_del(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_xconnect_req *xc;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+
+	xc = nla_data(info->attrs[MPLS_ATTR_XC]);
+	retval = mpls_detach_in2out(xc);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_xc_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_xconnect_req *xc;
+	struct mpls_ilm *ilm;
+	struct mpls_nhlfe *nhlfe;
+	struct mpls_instr *mi;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_XC])
+		goto err;
+
+	xc = nla_data(info->attrs[MPLS_ATTR_XC]);
+
+	if (xc->mx_in.ml_type == MPLS_LABEL_KEY) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	ilm = mpls_get_ilm(mpls_label2key(xc->mx_in.ml_index,
+		&xc->mx_in));
+	if (!ilm) {
+		retval = -ESRCH;
+	} else {
+		/* Fetch the last instr, make sure it is FWD */
+		for (mi = ilm->ilm_instr;
+		     mi->mi_next;mi = mi->mi_next); /* noop */
+
+		if (!mi || mi->mi_opcode != MPLS_OP_FWD) {
+			retval = -ENXIO;
+		} else {
+			nhlfe = mi->mi_data;
+
+			if (mpls_fill_xc(skb, ilm, nhlfe, info->snd_portid,
+				info->snd_seq, 0, MPLS_CMD_NEWXC) < 0)
+				retval = -EINVAL;
+		}
+		mpls_ilm_release (ilm);
+	}
+	retval = genlmsg_unicast(&init_net, skb, info->snd_portid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_xc_dump(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	struct mpls_ilm *ilm;
+	struct mpls_nhlfe *nhlfe;
+	struct mpls_instr *mi;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	rcu_read_lock();
+	list_for_each_entry_rcu(ilm, &mpls_ilm_list, global) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		if (entry_count >= entries_to_skip) {
+			/* Fetch the last instr, make sure it is FWD */
+			for (mi = ilm->ilm_instr;
+			     mi->mi_next;mi = mi->mi_next); /* noop */
+
+			if (!mi || mi->mi_opcode != MPLS_OP_FWD)
+				continue;
+
+			nhlfe = mi->mi_data;
+
+			if (mpls_fill_xc(skb, ilm, nhlfe,
+				NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,
+				NLM_F_MULTI, MPLS_CMD_NEWXC) < 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	rcu_read_unlock();
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+/* LABELSPACE netlink support */
+
+static int mpls_fill_labelspace(struct sk_buff *skb, struct net_device *dev,
+	    u32 pid, u32 seq, int flag, int event)
+{
+	struct mpls_labelspace_req ls;
+	void *hdr;
+
+	hdr = genlmsg_put(skb, pid, seq, &genl_mpls, flag, event);
+
+	ls.mls_ifindex = dev->ifindex;
+	ls.mls_labelspace = mpls_get_labelspace_by_index(dev->ifindex);
+
+	nla_put(skb, MPLS_ATTR_LABELSPACE, sizeof(ls), &ls);
+
+	MPLS_DEBUG("Exit: length\n");
+	return genlmsg_end(skb, hdr);
+
+nla_put_failure:
+	genlmsg_cancel(skb, hdr);
+	MPLS_DEBUG("Exit: -1\n");
+	return -ENOMEM;
+}
+
+void mpls_labelspace_event(int event, struct net_device *dev)
+{
+	struct sk_buff *skb;
+	int err;
+
+	MPLS_ENTER;
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+	if (skb == NULL) {
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+
+	err = mpls_fill_labelspace(skb, dev, 0, 0, 0, event);
+	if (err < 0) {
+		nlmsg_free(skb);
+		MPLS_DEBUG("Exit: EINVAL\n");
+		return;
+	}
+	genlmsg_multicast(PF_MPLS, skb, 0, MPLS_GRP_LABELSPACE, GFP_KERNEL);
+	MPLS_EXIT;
+}
+
+static int genl_mpls_labelspace_set(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_labelspace_req *ls;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	ls = nla_data(info->attrs[MPLS_ATTR_LABELSPACE]);
+	retval = mpls_set_labelspace(ls);
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_labelspace_get(struct sk_buff *skb, struct genl_info *info)
+{
+	struct mpls_labelspace_req *ls;
+	struct net_device *dev;
+	int retval = -EINVAL;
+
+	MPLS_ENTER;
+	if (!info->attrs[MPLS_ATTR_LABELSPACE])
+		goto err;
+
+	ls = nla_data(info->attrs[MPLS_ATTR_LABELSPACE]);
+	dev = dev_get_by_index(&init_net, ls->mls_ifindex);
+	if (!dev) {
+		retval = -ESRCH;
+	} else {
+		if (mpls_fill_labelspace(skb, dev, info->snd_portid,
+			info->snd_seq, 0, MPLS_CMD_SETLABELSPACE) < 0)
+			retval = -EINVAL;
+		dev_put (dev);
+	}
+	retval = genlmsg_unicast(&init_net, skb, info->snd_portid);
+err:
+	MPLS_DEBUG("Exit: %d\n", retval);
+	return retval;
+}
+
+static int genl_mpls_labelspace_dump(struct sk_buff *skb,
+	struct netlink_callback *cb)
+{
+	struct net_device *dev;
+	int entries_to_skip;
+	int entry_count;
+
+	entries_to_skip = cb->args[0];
+	entry_count = 0;
+
+	MPLS_DEBUG("Enter: entry %d\n", entries_to_skip);
+	read_lock(&dev_base_lock);
+	for_each_netdev(&init_net, dev) {
+		MPLS_DEBUG("Dump: entry %d\n", entry_count);
+		if (entry_count >= entries_to_skip) {
+			if (mpls_fill_labelspace(skb, dev,
+				NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,
+				NLM_F_MULTI, MPLS_CMD_SETLABELSPACE) < 0) {
+				break;
+			}
+		}
+		entry_count++;
+	}
+	read_unlock(&dev_base_lock);
+	cb->args[0] = entry_count;
+
+	MPLS_DEBUG("Exit: entry %d\n", entry_count);
+	return skb->len;
+}
+
+static struct nla_policy genl_mpls_policy[MPLS_ATTR_MAX+1] __read_mostly = {
+	[MPLS_ATTR_ILM] = { .len = sizeof(struct mpls_in_label_req) },
+	[MPLS_ATTR_NHLFE] = { .len = sizeof(struct mpls_out_label_req) },
+	[MPLS_ATTR_XC] = { .len = sizeof(struct mpls_xconnect_req) },
+	[MPLS_ATTR_LABELSPACE] = {.len = sizeof(struct mpls_labelspace_req)},
+	[MPLS_ATTR_INSTR] = { .len = sizeof(struct mpls_instr_req) },
+	[MPLS_ATTR_STATS] = { .len = sizeof(struct gnet_stats_basic) },
+};
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+static struct genl_ops genl_mpls_ilm_new_ops = {
+	.cmd		= MPLS_CMD_NEWILM,
+	.doit		= genl_mpls_ilm_new,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_ilm_del_ops = {
+	.cmd		= MPLS_CMD_DELILM,
+	.doit		= genl_mpls_ilm_del,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_ilm_get_ops = {
+	.cmd		= MPLS_CMD_GETILM,
+	.doit		= genl_mpls_ilm_get,
+	.dumpit		= genl_mpls_ilm_dump,
+	.policy		= genl_mpls_policy,
+};
+
+static struct genl_ops genl_mpls_nhlfe_new_ops = {
+	.cmd		= MPLS_CMD_NEWNHLFE,
+	.doit		= genl_mpls_nhlfe_new,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_nhlfe_del_ops = {
+	.cmd		= MPLS_CMD_DELNHLFE,
+	.doit		= genl_mpls_nhlfe_del,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_nhlfe_get_ops = {
+	.cmd		= MPLS_CMD_GETNHLFE,
+	.doit		= genl_mpls_nhlfe_get,
+	.dumpit		= genl_mpls_nhlfe_dump,
+	.policy		= genl_mpls_policy,
+};
+
+static struct genl_ops genl_mpls_xc_new_ops = {
+	.cmd		= MPLS_CMD_NEWXC,
+	.doit		= genl_mpls_xc_new,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_xc_del_ops = {
+	.cmd		= MPLS_CMD_DELXC,
+	.doit		= genl_mpls_xc_del,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_xc_get_ops = {
+	.cmd		= MPLS_CMD_GETXC,
+	.doit		= genl_mpls_xc_get,
+	.dumpit		= genl_mpls_xc_dump,
+	.policy		= genl_mpls_policy,
+};
+
+static struct genl_ops genl_mpls_labelspace_set_ops = {
+	.cmd		= MPLS_CMD_SETLABELSPACE,
+	.doit		= genl_mpls_labelspace_set,
+	.policy		= genl_mpls_policy,
+};
+static struct genl_ops genl_mpls_labelspace_get_ops = {
+	.cmd		= MPLS_CMD_GETLABELSPACE,
+	.doit		= genl_mpls_labelspace_get,
+	.dumpit		= genl_mpls_labelspace_dump,
+	.policy		= genl_mpls_policy,
+};
+#else
+#endif
+static const struct genl_ops genl_mpls_new_ops[] = {
+{
+	.cmd		= MPLS_CMD_NEWILM,
+	.doit		= genl_mpls_ilm_new,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_DELILM,
+	.doit		= genl_mpls_ilm_del,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_GETILM,
+	.doit		= genl_mpls_ilm_get,
+	.dumpit		= genl_mpls_ilm_dump,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_NEWNHLFE,
+	.doit		= genl_mpls_nhlfe_new,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_DELNHLFE,
+	.doit		= genl_mpls_nhlfe_del,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_GETNHLFE,
+	.doit		= genl_mpls_nhlfe_get,
+	.dumpit		= genl_mpls_nhlfe_dump,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_NEWXC,
+	.doit		= genl_mpls_xc_new,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_DELXC,
+	.doit		= genl_mpls_xc_del,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_GETXC,
+	.doit		= genl_mpls_xc_get,
+	.dumpit		= genl_mpls_xc_dump,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_SETLABELSPACE,
+	.doit		= genl_mpls_labelspace_set,
+	.policy		= genl_mpls_policy,
+},
+{
+	.cmd		= MPLS_CMD_GETLABELSPACE,
+	.doit		= genl_mpls_labelspace_get,
+	.dumpit		= genl_mpls_labelspace_dump,
+	.policy		= genl_mpls_policy,
+},
+};
+
+int __init mpls_netlink_init(void)
+{
+	int err;
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	err = genl_register_family(&genl_mpls);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_ilm_new_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_ilm_del_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_ilm_get_ops);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_nhlfe_new_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_nhlfe_del_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_nhlfe_get_ops);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_xc_new_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_xc_del_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_xc_get_ops);
+
+	err += genl_register_ops(&genl_mpls, &genl_mpls_labelspace_set_ops);
+	err += genl_register_ops(&genl_mpls, &genl_mpls_labelspace_get_ops);
+
+#else
+	err += genl_register_family_with_ops(&genl_mpls, genl_mpls_new_ops);
+#endif
+	if (err) {
+		printk(MPLS_ERR "MPLS: failed to register with genetlink\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void __exit mpls_netlink_exit(void)
+{
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	genl_unregister_ops(&genl_mpls, &genl_mpls_labelspace_get_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_labelspace_set_ops);
+
+	genl_unregister_ops(&genl_mpls, &genl_mpls_xc_del_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_xc_new_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_xc_get_ops);
+
+	genl_unregister_ops(&genl_mpls, &genl_mpls_nhlfe_del_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_nhlfe_new_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_nhlfe_get_ops);
+
+	genl_unregister_ops(&genl_mpls, &genl_mpls_ilm_del_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_ilm_new_ops);
+	genl_unregister_ops(&genl_mpls, &genl_mpls_ilm_get_ops);
+
+#else
+#endif
+	genl_unregister_family(&genl_mpls);
+}
diff -Nur linux-3.14.1/net/mpls/mpls_nhlfe.c linux-3.14.1_mpls/net/mpls/mpls_nhlfe.c
--- linux-3.14.1/net/mpls/mpls_nhlfe.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_nhlfe.c	2014-04-29 20:28:13.640436451 +0530
@@ -0,0 +1,631 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *
+ *	      It implements:
+ *	      -add/get/del/flush for the out label tree
+ *	      -binding of FEC to out label
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ *	20040102 RCAS: Commented, and clean up. 
+ *		- nhlfe_list lacks proper management. This list
+ *		should be updated when a NHLFE object is deleted. 
+ *		A possible approach would be to modify nhlfe_release.
+ *
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <net/mpls.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <net/dst.h>
+#include <linux/rtnetlink.h>
+#include <linux/in.h>		/* must be before route.h */
+#include <linux/ip.h>		/* must be before route.h */
+#include <linux/inetdevice.h>	/* must be before route.h */
+#include <net/route.h>		/* must be before ip_fib.h */
+#include <net/ip_fib.h>
+#include <linux/genetlink.h>
+#include <net/net_namespace.h>
+
+LIST_HEAD(mpls_nhlfe_list);
+
+/* forward declarations */
+static struct dst_entry *nhlfe_dst_check(struct dst_entry *dst, u32 cookie);
+static void              nhlfe_dst_destroy(struct dst_entry *dst);
+static struct dst_entry *nhlfe_dst_negative_advice(struct dst_entry *dst);
+static void              nhlfe_dst_link_failure(struct sk_buff *skb);
+static void              nhlfe_dst_update_pmtu(struct dst_entry *dst, u32 mtu);
+static int               nhlfe_dst_gc(struct dst_ops *ops);
+
+struct dst_ops nhlfe_dst_ops = {
+	.family		 =  AF_MPLS,
+	.protocol	 = __constant_htons(ETH_P_MPLS_UC),
+	.gc		 = nhlfe_dst_gc,
+	.check		 = nhlfe_dst_check,
+	.destroy	 = nhlfe_dst_destroy,
+	.negative_advice = nhlfe_dst_negative_advice,
+	.link_failure	 = nhlfe_dst_link_failure,
+	.update_pmtu	 = nhlfe_dst_update_pmtu,
+#if 0 /* Ported from linux 2.6.35 which is not present in latest*/
+	.entries	 = ATOMIC_INIT(0)
+#else
+#endif
+};
+
+static struct dst_entry *
+nhlfe_dst_check (struct dst_entry *dst, u32 cookie)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+/**
+ *      nhlfe_dst_destroy - cleanup for a MPLS dst_entry
+ *      @dst: 'this', object that is being destroyed.
+ *
+ *      The object ends life here. Perform the necessary
+ *      clean up, but do not call dst_free(..) etc.
+ **/
+
+static void
+nhlfe_dst_destroy (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static struct dst_entry *
+nhlfe_dst_negative_advice (struct dst_entry *dst)
+{
+	MPLS_ENTER;
+	dst_release(dst);
+	MPLS_EXIT;
+	return NULL;
+}
+
+static void
+nhlfe_dst_link_failure (struct sk_buff *skb)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static void
+nhlfe_dst_update_pmtu (struct dst_entry *dst, u32 mtu)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+}
+
+static int
+nhlfe_dst_gc (struct dst_ops *ops)
+{
+	MPLS_ENTER;
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ *      nhlfe_dst_alloc - construct a mpls_nhlfe entry.
+ *
+ **/
+
+struct mpls_nhlfe*
+nhlfe_dst_alloc(unsigned int key)
+{
+	struct mpls_nhlfe *nhlfe;
+
+	MPLS_ENTER;
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	nhlfe = dst_alloc (&nhlfe_dst_ops);
+#else
+	nhlfe = dst_alloc (&nhlfe_dst_ops, init_net.loopback_dev, 0, 0, 0);
+#endif
+
+	if (unlikely(!nhlfe))
+		goto nhlfe_dst_alloc_0;
+
+	nhlfe->u.dst.dev	= init_net.loopback_dev;
+	nhlfe->u.dst.input	= mpls_switch;
+	nhlfe->u.dst.output	= mpls_output;
+
+	INIT_LIST_HEAD(&nhlfe->list_out);
+	INIT_LIST_HEAD(&nhlfe->list_in);
+	INIT_LIST_HEAD(&nhlfe->nhlfe_entry);
+	INIT_LIST_HEAD(&nhlfe->dev_entry);
+	INIT_LIST_HEAD(&nhlfe->global);
+
+	nhlfe->nhlfe_instr		= NULL;
+	nhlfe->nhlfe_propagate_ttl	= 1;
+	nhlfe->nhlfe_age		= jiffies;
+	nhlfe->nhlfe_key		= key;
+
+	MPLS_EXIT;
+	return nhlfe;
+
+/* Error Path */
+nhlfe_dst_alloc_0:
+	MPLS_EXIT;
+	return NULL;
+}
+
+
+/**
+ * mpls_nhlfe_tree: Radix Tree to hold NHLFE objects
+ **/
+RADIX_TREE(mpls_nhlfe_tree,GFP_ATOMIC);
+
+/**
+ * mpls_nhlfe_lock: lock for tree access.
+ **/
+DEFINE_SPINLOCK(mpls_nhlfe_lock);
+
+
+/**
+ * mpls_insert_nhlfe - Inserts the given NHLFE object in the MPLS
+ *   Output Information Radix Tree using the given key.
+ * @key : key to use
+ * @nhlfe : nhlfe object.
+ *
+ * Returns 0 on success, or:
+ *     -ENOMEM : unable to allocate node in the radix tree.
+ *
+ * Caller must hold mpls_nhlfe_lock
+ *
+ **/
+
+int 
+mpls_insert_nhlfe (unsigned int key, struct mpls_nhlfe *nhlfe) 
+{
+	int retval = 0;
+	retval = radix_tree_insert (&mpls_nhlfe_tree, key, nhlfe);
+	if (unlikely(retval))
+		retval = -ENOMEM;
+
+	list_add_rcu(&nhlfe->global, &mpls_nhlfe_list);
+
+	/* hold it for being in the tree */
+	mpls_nhlfe_hold (nhlfe);
+	return retval;
+}
+
+
+/**
+ *	mpls_remove_nhlfe - Remove the node given the key from the MPLS
+ *	Output Information Radix Tree.
+ *	@key : key to use
+ *
+ *	Must be called while holding a write lock on mpls_nhlfe_lock
+ *
+ *	This function deletes the NHLFE object from the Radix Tree, but please
+ *	also note that the object is not freed, and that the caller is
+ *	responsible for	decreasing the refcount if necessary.
+ *
+ *	Returns the node removed from the tree (which still needs to be
+ *	released) or NULL if no such key/element exists in the tree.
+ *
+ **/
+
+struct mpls_nhlfe* 
+mpls_remove_nhlfe (unsigned int key)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+
+	MPLS_ENTER;
+
+	nhlfe = radix_tree_delete(&mpls_nhlfe_tree, key);
+	if (!nhlfe)
+		MPLS_DEBUG("NHLFE node with key %u not found.\n",key);
+
+	list_del_rcu(&nhlfe->global);
+
+	/* release the refcnt for the tree hold it */
+	mpls_nhlfe_release (nhlfe);
+
+	MPLS_EXIT;
+	return nhlfe;
+}
+
+
+/**
+ *	mpls_get_nhlfe - Get a reference to a NHLFE object.
+ *	@key : key to look for in the NHLFE Radix Tree.
+ *
+ *	This function can be used to get a reference to a NHLFE object
+ *	given a key.
+ *	Returns a pointer to the NHLFE object, NULL on error.
+ *
+ *	Remark: this function increases the refcount of the NHLFE object, since it
+ *	calls to mpls_nhlfe_hold. Caller is responsible to release the object
+ *	when it is no longer needed (by using "mpls_nhlfe_release").
+ **/
+
+struct mpls_nhlfe*  
+mpls_get_nhlfe (unsigned int key) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+
+	rcu_read_lock();
+	nhlfe = radix_tree_lookup (&mpls_nhlfe_tree, key);
+	smp_read_barrier_depends();
+	if (likely(nhlfe)) {
+		mpls_nhlfe_hold(nhlfe);
+	}
+	rcu_read_unlock();
+
+	return nhlfe;
+}
+
+/**
+ *	mpls_get_out_key - generate a key for out tree.
+ *
+ *	Returns an unused unique key to insert a NHLFE in the output
+ *	radix tree. 0 is not allowed (has special semantics).
+ *	Called in User context.
+ **/
+ 
+unsigned int 
+mpls_get_out_key(void) 
+{
+	static int new_key = 1;
+	struct mpls_nhlfe* dummy = NULL;
+
+	rcu_read_lock();
+	for (;;) {
+		if (++new_key <= 0)
+			new_key = 1;
+		dummy = radix_tree_lookup (&mpls_nhlfe_tree, new_key);
+		if (!dummy)
+			goto out;	
+	}
+out:
+	rcu_read_unlock();
+	return new_key;
+}
+
+/**
+ *	mpls_destroy_out_instrs - Destroy NHLFE instruction list. 
+ *	@nhlfe:	NHLFE object
+ *
+ *      This function completely destroys the instruction list for this
+ *      NHLFE object.
+ *
+ *      nhlfe_instr is set to NULL.
+ **/
+
+void
+mpls_destroy_out_instrs (struct mpls_nhlfe *nhlfe)
+{
+	MPLS_ENTER;
+	mpls_instrs_free (nhlfe->nhlfe_instr);
+	nhlfe->nhlfe_instr = NULL;
+	MPLS_EXIT;
+}
+
+int
+mpls_set_out_instrs (struct mpls_instr_elem *mie, int length,
+		struct mpls_nhlfe *nhlfe)
+{
+	struct mpls_instr *instr = NULL;
+	
+	/* Build temporary opcode set from mie */
+	if (!mpls_instrs_build(mie, &instr, length, MPLS_OUT, nhlfe))
+		return -1;
+
+	/* Commit the new ones */
+	if (nhlfe->nhlfe_instr)
+		mpls_instrs_free(nhlfe->nhlfe_instr);
+	nhlfe->nhlfe_instr = instr;
+	
+	return 0;
+}
+
+/**
+ *	mpls_set_out_label_instrs - program the opcodes for this NHLFE
+ *	@mir: request detailing the list of opcodes and data.
+ *
+ *	Update the NHLFE object (using the key in the request) with the passed
+ *	instrs/opcodes. Typically, once this function finishes for a PUSH/SET
+ *	Instruction Set, the refcount of a newly created NHLFE object is 2:
+ **/
+ 
+int 
+mpls_set_out_label_instrs (struct mpls_instr_req *mir)
+{
+	struct mpls_label *ml     = &mir->mir_label;
+	unsigned int key	  = mpls_label2key(0,ml);
+	struct mpls_nhlfe *nhlfe = mpls_get_nhlfe(key);
+	int ret;
+
+	if (unlikely(!nhlfe)) 
+		return -ESRCH;
+
+	ret = mpls_set_out_instrs (mir->mir_instr,mir->mir_instr_length, nhlfe);
+	mpls_nhlfe_release(nhlfe);
+	return ret;
+}
+
+/**
+ *	mpls_set_out_label_propagate_ttl - set the propagate_ttl status
+ *	@mol: request with the NHLFE key and desired propagate_ttl status
+ *
+ *	Update the NHLFE object (using the key in the request) with the
+ *	propagate_ttl from the request
+ **/
+ 
+int
+mpls_set_out_label_propagate_ttl(struct mpls_out_label_req *mol)
+{
+	unsigned int key	  = mpls_label2key(0,&mol->mol_label);
+	struct mpls_nhlfe *nhlfe = mpls_get_nhlfe(key);
+	if (!nhlfe)
+		return -ESRCH;
+
+	nhlfe->nhlfe_propagate_ttl = mol->mol_propagate_ttl;
+
+	mpls_nhlfe_release(nhlfe);
+	return 0;
+}
+
+/**
+ *	mpls_add_out_label - Add a new outgoing label to the database.
+ *	@out:request containing the label
+ *
+ *	Adds a new outgoing label to the outgoing tree. We first obtain
+ *	a unique unused key, check that the entry does not exist, 
+ *	allocate a new NHLFE object and reset it.
+ **/
+
+int 
+mpls_add_out_label (struct mpls_out_label_req *out, int seq, int pid) 
+{
+	struct mpls_nhlfe *nhlfe = NULL; 
+	unsigned int key	  = 0;
+	int retval		  = 0;
+
+	MPLS_ENTER;
+	BUG_ON(!out);
+
+	/* Create a new key */
+	key = mpls_get_out_key();
+
+	/* 
+	 * Check if the NHLFE is already in the tree. 
+	 * It should not exist. In fact, it is impossible :) 
+	 */
+	nhlfe = mpls_get_nhlfe (key);
+
+	if (unlikely(nhlfe)) {
+		MPLS_DEBUG("Node %u already exists in radix tree\n",key);
+
+		/* release the refcnt held by mpls_get_nhlfe */
+		mpls_nhlfe_release (nhlfe);
+		retval = -EEXIST;
+		goto error;
+	}
+
+	/* 
+	 * Allocate a new Output Information/Label,
+	 */
+	nhlfe = nhlfe_dst_alloc (key);
+	if (unlikely(!nhlfe)) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	/* Insert into NHLFE tree */
+	spin_lock_bh (&mpls_nhlfe_lock);
+	if (unlikely(mpls_insert_nhlfe (key,nhlfe))) {
+		spin_unlock_bh (&mpls_nhlfe_lock);
+		nhlfe->u.dst.obsolete = 1;
+		dst_free (&nhlfe->u.dst);
+		goto error;
+	}
+
+	/* make sure that the dst system doesn't delete this until we're
+	 * done with it
+	 */
+	dst_hold(&nhlfe->u.dst);
+
+	mpls_nhlfe_hold(nhlfe);
+	spin_unlock_bh (&mpls_nhlfe_lock);
+
+	/* we need to hold a ref to the nhlfe while calling
+	 * mpls_nhlfe_event so it can't disappear
+	 */
+	mpls_nhlfe_event(MPLS_CMD_NEWNHLFE, nhlfe, seq, pid);
+	mpls_nhlfe_release(nhlfe);
+
+	out->mol_label.ml_type  = MPLS_LABEL_KEY;
+	out->mol_label.u.ml_key = key;
+
+error:
+	MPLS_EXIT;
+
+	return retval; 
+}
+
+/** 
+ *	mpls_del_out_label - Remove a NHLFE from the tree
+ *	@out: request.
+ **/
+
+int 
+mpls_del_out_label(struct mpls_out_label_req *out) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	unsigned int key;
+
+	MPLS_ENTER;
+
+	key = mpls_label2key(0,&out->mol_label);
+
+        nhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("Node %u was not in tree\n",key);
+		MPLS_EXIT;
+		return  -ESRCH;
+	}
+
+	spin_lock_bh (&mpls_nhlfe_lock);
+
+	/* at this point a NHLFE that can be deleted will have a refcnt
+	 * of 2, one from mpls_get_nhlfe() we just executed and the
+	 * other that from when it was added to the tree
+	 */
+	if (atomic_read(&nhlfe->__refcnt) > 2) {
+		/* someone else is hold a refcnt, we can't delete */
+
+		/* release the refcnt we aquired in mpls_get_nhlfe() */
+		mpls_nhlfe_release (nhlfe);
+		spin_unlock_bh (&mpls_nhlfe_lock);
+
+		MPLS_DEBUG("Node %u is being used\n",key);
+		MPLS_EXIT;
+		return -EBUSY;
+	}
+
+	/*
+	 *	This code starts the process of removing a NHLFE from the
+	 *	system.  The first thing we we do it remove it from the tree
+	 *	so no one else can get a reference to it.  Then we notify the
+	 *	higher layer protocols that they should give up thier references
+	 *	soon (does not need to happen immediatly, the dst system allows
+	 *	for this.  Finally we schedule the RCU system to call
+	 *	dst_rcu_free() which waits until all CPUs have finished
+	 *	thier current work and then calls dst_rcu_free() which
+	 *	kicks the dst system into action once the dst system knows
+	 *	everyone is done using this "dst" it calls mpls_dst_destroy().
+	 */
+
+	/* remove the NHLFE from the tree (which decs the refcnt we held when
+	 * it was added to the tree)
+	 */
+	mpls_remove_nhlfe(nhlfe->nhlfe_key);
+	spin_unlock_bh (&mpls_nhlfe_lock);
+
+	mpls_nhlfe_event(MPLS_CMD_DELNHLFE, nhlfe, 0, 0);
+
+	/* destrory the instructions on this nhlfe, so as to no longer
+	 * hold refs to interfaces and other NHLFEs.
+	 *
+	 * Remember NHLFEs may stick around in the dst system even
+	 * after we've removed it from the tree.  So this will result
+	 * in traffic using the NHLFE to be dropped
+	 */
+	mpls_destroy_out_instrs (nhlfe);
+
+	/* let the dst system know we're done with this NHLFE and
+	 * schedule all higher layer protocol to give up their references */
+	dst_release(&nhlfe->u.dst);
+	nhlfe->u.dst.obsolete = 1;
+	mpls_proto_cache_flush_all(&init_net);
+
+	/* since high layer protocols may still be using us in there caches
+	 * we need to use call_rcu() and dst_rcu_free() to take care
+	 * of actually cleaning up NHLFE
+	 */
+	call_rcu(&nhlfe->u.dst.rcu_head, dst_rcu_free);
+
+	/* release the refcnt we aquired in mpls_get_nhlfe() */
+	mpls_nhlfe_release (nhlfe);
+
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ * mpls_set_out_label_mtu - change the MTU for this NHLFE.
+ * @out: Request containing the new MTU.
+ *
+ * Update the NHLFE object (using the key in the request) with the passed
+ * MTU.
+ **/
+
+int mpls_set_out_label_mtu(struct mpls_out_label_req *out)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	int retval = 0;
+	unsigned int key;
+
+	BUG_ON(!out);
+	MPLS_ENTER;
+
+	key = out->mol_label.u.ml_key;
+
+	nhlfe = mpls_get_nhlfe(key);
+
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("Node %u does not exists in radix tree\n", key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/* Update the MTU if possible */
+	if (nhlfe->nhlfe_mtu_limit >= out->mol_mtu) {
+		nhlfe->nhlfe_mtu = out->mol_mtu;
+	} else {
+		MPLS_DEBUG("MTU is larger than lower layer (%d > %d)\n",
+			out->mol_mtu, nhlfe->nhlfe_mtu_limit);
+
+		/* release the refcnt held by mpls_get_nhlfe */
+		mpls_nhlfe_release(nhlfe);
+		return -EINVAL;
+	}
+
+	/* release the refcnt held by mpls_get_nhlfe */
+	mpls_nhlfe_release(nhlfe);
+
+	/* force the layer 3 protocols to re-find and dsts (NHLFEs),
+	 * thus picking up the new MTU
+	 */
+	mpls_proto_cache_flush_all(&init_net);
+
+	MPLS_EXIT;
+	return retval;
+}
+
+int __init mpls_nhlfe_init(void)
+{
+	nhlfe_dst_ops.kmem_cachep = kmem_cache_create("nhlfe_dst_cache",
+		sizeof(struct mpls_nhlfe), 0, SLAB_HWCACHE_ALIGN, NULL);
+
+	if (!nhlfe_dst_ops.kmem_cachep) {
+		printk(MPLS_ERR "MPLS: failed to alloc nhlfe_dst_cache\n");
+		return -ENOMEM;
+	}
+
+        printk ("MPLS_NHLFE_INIT PASS ...");
+
+	return 0;
+}
+
+void __exit mpls_nhlfe_exit(void)
+{
+	if (nhlfe_dst_ops.kmem_cachep)
+	{
+		kmem_cache_destroy(nhlfe_dst_ops.kmem_cachep);
+		printk ("MPLS_NHLFE_EXIT PASS ...");
+	}
+	return;
+}
+
+EXPORT_SYMBOL(mpls_get_nhlfe);
diff -Nur linux-3.14.1/net/mpls/mpls_opcode.c linux-3.14.1_mpls/net/mpls/mpls_opcode.c
--- linux-3.14.1/net/mpls/mpls_opcode.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_opcode.c	2014-04-23 10:08:19.832503630 +0530
@@ -0,0 +1,1886 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ *       20031218 JLEU:
+ *              Moved per instruction code into mpls_ops
+ *	20040120 RCAS:
+ *		Formatted and commented opcodes. Changed key access.
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <net/dst.h>
+#include <net/mpls.h>
+#include <linux/socket.h>
+#include <linux/inetdevice.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <net/arp.h>
+#include <net/route.h>
+#include <linux/rtnetlink.h>
+#include <net/ip_fib.h>
+#include <linux/inet.h>
+#include <net/net_namespace.h>
+
+/**
+ * mpls_finish - Leave the socket buffer in a known (coherent) state.
+ * @skb: Socket buffer.
+ *
+ * In order to optimize socket buffer management, the MPLS implementation
+ * manages a "gap", so the common POP-PUSH chain is optimized. This function
+ * leaves the socket buffer in a coherent state so things like DHCP
+ * will work across a LSP
+ **/
+ 
+struct sk_buff *mpls_finish(struct sk_buff *skb) 
+{
+	unsigned int diff = MPLSCB(skb)->gap;
+	MPLS_ENTER;
+	if(diff > 0) {
+		if (skb_linearize_cow(skb) == 0) {
+			memmove(skb->mac_header + diff, skb->mac_header, skb->len);
+			skb->mac_header += diff;
+			MPLSCB(skb)->gap = 0;
+		} else {
+			skb = NULL;
+		}
+	}
+	MPLS_EXIT;
+	return skb;
+}
+
+
+/**
+ * mpls_opcode_peek - Peek the topmost label entry from the stack.
+ * @skb: Socket buffer.
+ *
+ * RCAS: this function should be renamed to mpls_label_entry_peek
+ **/
+ 
+int mpls_opcode_peek(struct sk_buff *skb) 
+{
+	u32 shim;
+
+#define CAN_WE_ASSUME_32BIT_ALIGNED 0
+#if CAN_WE_ASSUME_32BIT_ALIGNED
+	shim = ntohl(*((u32 *)&skb_network_header(skb)));
+#else
+	memcpy(&shim, skb_network_header(skb), MPLS_SHIM_SIZE);
+	shim = ntohl(shim);
+#endif
+
+	if (!(MPLSCB(skb)->flag)) {
+		MPLSCB(skb)->ttl  = shim & 0xFF;
+		MPLSCB(skb)->flag = 1;
+	}
+	MPLSCB(skb)->bos   = (shim >> 8 ) & 0x1;
+	MPLSCB(skb)->exp   = (shim >> 9 ) & 0x7;
+	MPLSCB(skb)->label = (shim >> 12) & 0xFFFFF;
+
+	return MPLS_RESULT_RECURSE;
+}
+
+/**
+ * mpls_push - push a label entry.
+ * @skb: Socket buffer.
+ * @ml: label value to push.
+ *
+ **/
+ 
+int mpls_push (struct sk_buff **skb, struct mpls_label *ml) 
+{
+	struct sk_buff *o = NULL; 
+	struct sk_buff *n = NULL;
+	unsigned int label = 0;
+	u32 shim;
+
+	MPLS_ENTER;
+	o = *skb;
+	if (unlikely(!ml)) {
+		MPLS_DEBUG("no outgoing label\n");
+		return MPLS_RESULT_DROP;
+	}
+
+try_again:
+	if(likely((MPLSCB(o)->gap >= MPLS_SHIM_SIZE) || (o->data - o->head >= MPLS_SHIM_SIZE))) {
+		/*
+		 * if we have room between data and end of mac_header
+		 * just shift the data,transport_header,network_header pointers and use the room
+		 * this would happen if we had a pop previous to this
+		 */
+		MPLS_DEBUG("using gap\n");
+		skb_push(o,MPLS_SHIM_SIZE);
+		o->transport_header -= MPLS_SHIM_SIZE;
+		o->network_header -= MPLS_SHIM_SIZE;
+		MPLSCB(o)->gap -= MPLS_SHIM_SIZE;
+		if (MPLSCB(o)->gap < 0) {
+			MPLSCB(o)->gap = 0;
+		}
+	} else {
+		/*
+		 * we have no room in the inn, go ahead and create a new sk_buff
+		 * with enough extra room for one shim
+		 */
+		MPLS_DEBUG("creating larger packet\n");
+		
+		if(!(n = skb_realloc_headroom(o, 32))) {
+			return MPLS_RESULT_DROP;
+		}
+
+		MPLSCB(n)->gap = 0;
+
+		MPLS_DEBUG("dump old packet\n");
+		MPLS_DEBUG_CALL(mpls_skb_dump(o));
+		kfree_skb(o);
+
+		MPLS_DEBUG("dump new packet\n");
+		MPLS_DEBUG_CALL(mpls_skb_dump(n));
+
+		o = *skb = n;
+
+		goto try_again;
+	}
+
+	switch(ml->ml_type) {
+		case MPLS_LABEL_GEN:
+			label = ml->u.ml_gen;
+			break;
+		default:
+			MPLS_DEBUG("invalid label type(%d)\n",ml->ml_type);
+			goto push_end;
+	}
+
+	/*
+	 * no matter what layer 2 we are on, we need the shim! (mpls-encap RFC)
+	 */
+	shim = htonl(((label & 0xFFFFF) << 12) |
+		     ((MPLSCB(o)->exp & 0x7) << 9) |
+		     ((MPLSCB(o)->bos & 0x1) << 8) |
+		      (MPLSCB(o)->ttl & 0xFF));
+	memmove(o->data,&shim,MPLS_SHIM_SIZE);
+	MPLSCB(o)->label = label;
+	MPLSCB(o)->bos = 0;
+	MPLSCB(o)->popped_bos = 0;
+
+push_end:
+	MPLS_EXIT;
+	return MPLS_RESULT_SUCCESS;;
+}
+
+
+/*
+ * Helper functions
+ */
+ 
+static inline void 
+mpls_list_del_init (struct list_head *entry)
+{
+	if (!list_empty(entry))
+		list_del_init(entry);
+}
+										
+static inline void 
+mpls_nhlfe_release_safe (struct mpls_nhlfe *nhlfe)
+{
+	if (nhlfe)
+		mpls_nhlfe_release (nhlfe);
+}
+
+/* 
+ * Generic function pointer to use when the opcode just
+ * needs to free the data pointer
+ */
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_generic) 
+{
+	kfree(data);
+}
+
+
+/*********************************************************************
+ * MPLS_OP_NOP
+ * DESC   : "No operation".
+ * EXEC   : mpls_op_nop
+ * INPUT  : true
+ * OUTPUT : true 
+ * DATA   : NULL 
+ * LAST   : true 
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_nop)
+{
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_POP
+ * DESC   : "Pop label from stack"
+ * EXEC   : mpls_in_op_pop
+ * BUILD  : mpls_build_opcode_pop
+ * UNBUILD: NULL
+ * INPUT  : true
+ * OUTPUT : false 
+ * DATA   : NULL 
+ * LAST   : false 
+ *********************************************************************/
+ 
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_pop)
+{
+	/*
+	 * Check that we have not popped the last label and
+	 * make sure that we can pull
+	 */
+	if (MPLSCB(*skb)->popped_bos || (((*skb)->data + MPLS_SHIM_SIZE) >= skb_tail_pointer(*skb))) {
+		return MPLS_RESULT_DROP;
+	}
+
+	/*
+	 * Is this the last entry in the stack? then flag it
+	 */
+	if (MPLSCB(*skb)->bos) {
+		MPLSCB(*skb)->popped_bos = 1;
+	}
+
+	skb_pull(*skb, MPLS_SHIM_SIZE);
+	(*skb)->transport_header     += MPLS_SHIM_SIZE;
+	(*skb)->network_header    += MPLS_SHIM_SIZE;
+	MPLSCB(*skb)->gap += MPLS_SHIM_SIZE;
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_pop) 
+{
+	*data = NULL;
+	if (direction != MPLS_IN) {
+		MPLS_DEBUG("POP only valid for incoming labels\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_PEEK
+ * DESC   : "Peek the contents of the next label entry, no popping"
+ * EXEC   : mpls_in_opcode_peek
+ * BUILD  : mpls_build_opcode_peek
+ * UNBUILD: NULL
+ * INPUT  : true
+ * OUTPUT : false 
+ * DATA   : NULL 
+ * LAST   : true 
+ *********************************************************************/
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_peek)
+{
+	if (MPLSCB(*skb)->bos) {
+		return MPLS_RESULT_DLV;
+	}
+	mpls_opcode_peek(*skb);
+	return MPLS_RESULT_RECURSE;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_peek) 
+{
+	*data = NULL;
+	if (direction != MPLS_IN) {
+		MPLS_DEBUG("PEEK only valid for incoming labels\n");
+		return -EINVAL;
+	}
+	*last_able = 1;
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_PUSH
+ * DESC   : "Push a label entry"
+ * EXEC   : mpls_op_push
+ * BUILD  : mpls_build_opcode_push
+ * UNBUILD: mpls_unbuild_opcode_push
+ * CLEAN  : mpls_clean_opcode_push
+ * INPUT  : ? 
+ * OUTPUT : true 
+ * DATA   : Reference to label to push (struct mpls_label*)
+ * LAST   : false 
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_push)
+{
+	BUG_ON(!data);
+	return mpls_push(skb,(struct mpls_label*)data);
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_push) 
+{
+	struct mpls_label *ml = NULL;
+
+	MPLS_ENTER;
+	*data = kmalloc(sizeof(*ml), GFP_ATOMIC);
+	if (unlikely(!(*data))) {
+		MPLS_DEBUG("error building PUSH label instruction\n");
+		MPLS_EXIT;
+		return -ENOMEM;
+	} 
+
+	ml = _mpls_as_label(*data);
+	memcpy(ml,&instr->mir_push, sizeof(*ml));
+	(*num_push)++;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_push) 
+{
+	struct mpls_label *ml = NULL;
+	MPLS_ENTER;
+
+	ml = data;
+	memcpy(&instr->mir_push, ml, sizeof(*ml));
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_push) 
+{
+	MPLS_ENTER;
+	kfree(data);
+	MPLS_EXIT;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_DLV
+ * DESC   : "Deliver to the upper layers, set skb protocol to ILM's"
+ *          "Incoming L3 protocol"
+ * EXEC   : mpls_in_opcode_dlv
+ * BUILD  : mpls_build_opcode_dlv
+ * UNBUILD: NULL
+ * INPUT  : true
+ * OUTPUT : false 
+ * DATA   : NULL 
+ * LAST   : true 
+ *********************************************************************/
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_dlv)
+{
+	return MPLS_RESULT_DLV;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_dlv) 
+{
+	*data = NULL;
+	if (unlikely(direction != MPLS_IN)) {
+		MPLS_DEBUG("DLV only valid for incoming labels\n");
+		return -EINVAL;
+	}
+	*last_able = 1;
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_FWD
+ * DESC   : "Forward packet, applying a given NHLFE"
+ * EXEC   : mpls_op_fwd
+ * BUILD  : mpls_build_opcode_fwd
+ * UNBUILD: mpls_unbuild_opcode_fwd
+ * CLEAN  : mpls_clean_opcode_fwd
+ * INPUT  : true
+ * OUTPUT : true
+ * DATA   : Reference to NHLFE object to apply
+ * LAST   : true
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_fwd)
+{
+	BUG_ON(!data);
+	*nhlfe = (struct mpls_nhlfe*)data;
+	return MPLS_RESULT_FWD;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_fwd) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	unsigned int key = 0;
+
+	MPLS_ENTER;
+	*data      = NULL; 
+	/* 
+	 * Get NHLFE to apply given key
+	 */
+	key   = mpls_label2key(0, &instr->mir_fwd);
+	nhlfe   = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_DEBUG("FWD: NHLFE key %08x not found\n", key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = nhlfe->nhlfe_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+		/* Add parent NHLFE to this NHLFE list */
+		list_add(&pnhlfe->nhlfe_entry, &nhlfe->list_out);
+	} else {
+		struct mpls_ilm *pilm = _mpls_as_ilm(parent);
+		/* Add parent ILM to this NHLFE list */
+		list_add(&pilm->nhlfe_entry, &nhlfe->list_in);
+	}
+
+	*data      = nhlfe; 
+	*last_able = 1;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_fwd)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+
+	MPLS_ENTER;
+
+	nhlfe = data;
+	instr->mir_fwd.ml_type = MPLS_LABEL_KEY;
+	instr->mir_fwd.u.ml_key = nhlfe->nhlfe_key;
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_fwd) 
+{
+	if (direction == MPLS_IN)
+		/* Remove parent NHLFE from this NHLFE list */
+		mpls_list_del_init(&_mpls_as_ilm(parent)->nhlfe_entry);
+	else
+		/* Remove parent NHLFE from this NHLFE list */
+		mpls_list_del_init(&_mpls_as_nhlfe(parent)->nhlfe_entry);
+
+	mpls_nhlfe_release(_mpls_as_nhlfe(data)); 
+}
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_NF_FWD
+ * DESC   : "Forward packet, applying the NHLFE defined by skbuff mark"
+ * EXEC   : mpls_op_nf_fwd
+ * BUILD  : mpls_build_opcode_nf_fwd
+ * UNBUILD: mpls_unbuild_opcode_nf_fwd
+ * CLEAN  : mpls_clean_opcode_nf_fwd
+ * INPUT  : false 
+ * OUTPUT : true
+ * DATA   : NFI object (struct mpls_nfmark_fwd_info*)
+ *	o Each nfi_nhlfe element holds a ref to a NHLFE object
+ * LAST   : true
+ *********************************************************************/
+
+#ifdef CONFIG_NETFILTER
+
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_nf_fwd)
+{
+	struct mpls_nfmark_fwd_info *nfi =  data;
+	*nhlfe = nfi->nfi_nhlfe[(*skb)->mark & nfi->nfi_mask];
+	if (unlikely(!(*nhlfe)))
+		return MPLS_RESULT_DROP;
+	return MPLS_RESULT_FWD;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_nf_fwd) 
+{
+	struct mpls_nfmark_fwd_info *nfi = NULL;
+	struct mpls_nhlfe        *nhlfe = NULL;
+	unsigned int min_mtu = 0xFFFFFFFF;
+	unsigned int key     = 0;
+	int j = 0;
+
+	*data = NULL;
+	
+	/* Allocate NFI object to store in data */
+	nfi = kmalloc(sizeof(*nfi),GFP_ATOMIC);
+	if (unlikely(!nfi)) {
+		MPLS_DEBUG("NF_FWD error building NFMARK info\n");
+		return -ENOMEM;
+	}
+	memset(nfi,0,sizeof(*nfi));
+
+	
+	/* Set up NHLFE objects for each mark given the keys */
+	nfi->nfi_mask = instr->mir_nf_fwd.nf_mask;
+	if (nfi->nfi_mask >= MPLS_NFMARK_NUM) {
+		MPLS_DEBUG("NF_FWD mask(%02x) allows too large of values\n",
+			nfi->nfi_mask);
+		kfree (nfi);
+		return -EINVAL;
+	}
+
+	for (j=0; j<MPLS_NFMARK_NUM; j++) {
+		key = instr->mir_nf_fwd.nf_key[j];
+		if (!key) {
+			continue;
+		}
+		nhlfe = mpls_get_nhlfe(key);
+		if (unlikely(!nhlfe)) {
+			MPLS_DEBUG("NF_FWD: NHLFE - key %08x not found\n", key);
+			kfree (nfi);
+			return -ESRCH;
+		}
+		if (nhlfe->nhlfe_mtu < min_mtu) {
+			min_mtu = nhlfe->nhlfe_mtu;
+		}
+		nfi->nfi_nhlfe[j] = nhlfe;
+	}
+
+	/* 
+	 * Set the MTU according to the number of pushes. 
+	 * RCAS :If the opcode is only allowed in output the "if"  should be 
+	 * removed, and a check added at the beginning 
+	 */
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = min_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+	}
+	*data = (void*)nfi;
+	*last_able = 1;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_nf_fwd) 
+{
+	struct mpls_nfmark_fwd_info *nfi;
+	struct mpls_nhlfe *nhlfe;
+	unsigned int key;
+	int j;
+
+	MPLS_ENTER;
+	
+	nfi = _mpls_as_nfi(data);
+	instr->mir_nf_fwd.nf_mask = nfi->nfi_mask;
+
+	for(j=0;j<MPLS_NFMARK_NUM;j++) {
+		nhlfe = nfi->nfi_nhlfe[j];
+
+		key = (nhlfe) ? nhlfe->nhlfe_key : 0;
+		instr->mir_nf_fwd.nf_key[j] = key;
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_nf_fwd) 
+{
+	int i;
+	for (i=0;i<MPLS_NFMARK_NUM;i++) 
+		mpls_nhlfe_release_safe(_mpls_as_nfi(data)->nfi_nhlfe[i]);
+	kfree(data);
+}
+#endif
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_DS_FWD
+ * DESC   : "Forward packet, applying the NHLFE defined by DS field in the"
+ *          "encapsulated IPv4/IPv6 packet"
+ * EXEC   : mpls_op_ds_fwd
+ * BUILD  : mpls_build_opcode_ds_fwd
+ * UNBUILD: mpls_unbuild_opcode_ds_fwd
+ * CLEAN  : mpls_clean_opcode_ds_fwd
+ * INPUT  : false 
+ * OUTPUT : true
+ * DATA   : DFI object (struct mpls_dsmark_fwd_info*)
+ *	o Each dfi_nhlfe element holds a ref to a NHLFE object
+ * LAST   : true
+ *********************************************************************/
+
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_ds_fwd)
+{
+	struct mpls_dsmark_fwd_info *dfi = data;
+	unsigned char ds;
+
+	ds = MPLSCB(*skb)->prot->get_dsfield(*skb);
+
+	*nhlfe = dfi->dfi_nhlfe[ds];
+	if (unlikely(NULL == *nhlfe))
+		return MPLS_RESULT_DROP;
+
+	return MPLS_RESULT_FWD;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_ds_fwd) 
+{
+	struct mpls_dsmark_fwd_info *dfi = NULL;
+	struct mpls_nhlfe        *nhlfe = NULL;
+	unsigned int min_mtu = 0xFFFFFFFF;
+	unsigned int key     = 0;
+	
+	int j = 0;
+
+	*data = NULL;
+	/* Allocate DFI object to store in data */
+	dfi = kmalloc(sizeof(*dfi),GFP_ATOMIC);
+	if (unlikely(!dfi)) {
+		MPLS_DEBUG("DS_FWD error building DSMARK info\n");
+		return -ENOMEM;
+	}
+	memset(dfi,0,sizeof(*dfi));
+	
+	
+	/* Set up NHLFE objects for each mark given the keys */
+	dfi->dfi_mask = instr->mir_ds_fwd.df_mask;
+	if (dfi->dfi_mask >= MPLS_DSMARK_NUM) {
+		MPLS_DEBUG("DS_FWD mask(%02x) allows too large of values\n",
+			dfi->dfi_mask);
+		kfree(dfi);
+		return -EINVAL;
+	}
+
+	for (j=0; j<MPLS_DSMARK_NUM; j++) {
+		key = instr->mir_ds_fwd.df_key[j];
+		if (!key) {
+			continue;
+		}
+		nhlfe = mpls_get_nhlfe(key);
+		if (unlikely(!nhlfe)) {
+			MPLS_DEBUG("DS_FWD: NHLFE key %08x not found\n", key);
+			kfree(dfi);
+			return -ESRCH;
+		}
+		if (nhlfe->nhlfe_mtu < min_mtu) {
+			min_mtu = nhlfe->nhlfe_mtu;
+		}
+		dfi->dfi_nhlfe[j] = nhlfe;
+	}
+
+	/* 
+	 * Set the MTU according to the number of pushes. 
+	 * RCAS :If the opcode is only allowed in output the "if"  should be 
+	 * removed, and a check added at the beginning 
+	 */
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = min_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+	}
+	*data = (void*)dfi;
+	*last_able = 1;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_ds_fwd) 
+{
+	struct mpls_dsmark_fwd_info *dfi;
+	struct mpls_nhlfe *nhlfe;
+	unsigned int key;
+	int j;
+
+	MPLS_ENTER;
+	
+	dfi = _mpls_as_dfi(data);
+	instr->mir_ds_fwd.df_mask = dfi->dfi_mask;
+
+	for(j=0;j<MPLS_DSMARK_NUM;j++) {
+		nhlfe = dfi->dfi_nhlfe[j];
+
+		key = (nhlfe) ? nhlfe->nhlfe_key : 0;
+		instr->mir_ds_fwd.df_key[j] = key;
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_ds_fwd) 
+{
+	int i;
+	for (i=0;i<MPLS_DSMARK_NUM;i++) 
+		mpls_nhlfe_release_safe(_mpls_as_dfi(data)->dfi_nhlfe[i]);
+	kfree(data);
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_EXP_FWD
+ * DESC   : "Forward packet, applying the NHLFE defined by DS the 3 EXP"
+ *          "bits in lable entry"
+ * EXEC   : mpls_op_exp_fwd
+ * BUILD  : mpls_build_opcode_exp_fwd
+ * UNBUILD: mpls_unbuild_opcode_exp_fwd
+ * CLEAN  : mpls_clean_opcode_exp_fwd
+ * INPUT  : true 
+ * OUTPUT : true
+ * DATA   : EFI object (struct mpls_exp_fwd_info*)
+ *	o Each efi_nhlfe element holds a ref to a NHLFE object
+ * LAST   : true
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_exp_fwd)
+{
+	struct mpls_exp_fwd_info *efi = data;
+	/*
+	 * Apply the NHLFE defined by the  given 3 EXP bits in label entry
+	 */
+	*nhlfe = efi->efi_nhlfe[MPLSCB(*skb)->exp & 0x7];
+	if (unlikely(NULL == *nhlfe))
+		return MPLS_RESULT_DROP;
+	return MPLS_RESULT_FWD;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_exp_fwd) 
+{
+	struct mpls_exp_fwd_info *efi = NULL;
+	struct mpls_nhlfe     *nhlfe = NULL;
+	unsigned int min_mtu = 0xFFFFFFFF;
+	unsigned int key     = 0;
+	int j = 0;
+
+	*data = NULL;
+	/* Allocate EFI object to store in data */
+	efi = kmalloc(sizeof(*efi),GFP_ATOMIC);
+	if (unlikely(!efi)) {
+		MPLS_DEBUG("EXP_FWD error building EXP info\n");
+		return -ENOMEM;
+	}
+	memset(efi,0,sizeof(*efi));
+
+	/* Set up NHLFE objects for each EXP value, given the keys */
+	for (j=0; j<MPLS_EXP_NUM; j++) {
+		key = instr->mir_exp_fwd.ef_key[j];
+		if (!key) {
+			continue;
+		}
+		nhlfe = mpls_get_nhlfe(key);
+		if (unlikely(!nhlfe)) {
+			MPLS_DEBUG("EXP_FWD: NHLFE key %08x not found\n", key);
+			kfree(efi);
+			return -ESRCH;
+		}
+		if (nhlfe->nhlfe_mtu < min_mtu) {
+			min_mtu = nhlfe->nhlfe_mtu;
+		}
+		efi->efi_nhlfe[j] = nhlfe;
+	}
+
+	/* 
+	 * Set the MTU according to the number of pushes. 
+	 */
+	if (direction == MPLS_OUT) {
+		struct mpls_nhlfe *pnhlfe = _mpls_as_nhlfe(parent);
+		pnhlfe->nhlfe_mtu = min_mtu - (4 * (*num_push));
+		pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+	}
+	*data = (void*)efi;
+	*last_able = 1;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_exp_fwd) 
+{
+	struct mpls_exp_fwd_info *efi;
+	struct mpls_nhlfe *nhlfe;
+	unsigned int key;
+	int j;
+
+	MPLS_ENTER;
+	
+	efi = _mpls_as_efi(data);
+
+	for(j=0;j<MPLS_EXP_NUM;j++) {
+		nhlfe = efi->efi_nhlfe[j];
+
+		key = (nhlfe) ? nhlfe->nhlfe_key : 0;
+		instr->mir_exp_fwd.ef_key[j] = key;
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_exp_fwd) 
+{
+	int i;
+	struct mpls_exp_fwd_info *efi = NULL;
+	
+	efi = _mpls_as_efi(data);
+
+	/* Release all NHLFEs held in efi (data) */
+	for (i=0;i<MPLS_EXP_NUM;i++) 
+		mpls_nhlfe_release_safe(efi->efi_nhlfe[i]);
+
+	/* Free the EFI (data) */
+	kfree(efi);
+}
+
+
+/*********************************************************************
+ * MPLS_OP_SET_RX
+ * DESC   : "Artificially change the incoming network device"
+ * EXEC   : mpls_in_op_set_rx
+ * BUILD  : mpls_build_opcode_set_rx
+ * UNBUILD: mpls_unbuild_opcode_set_rx
+ * CLEAN  : mpls_clean_opcode_set_rx
+ * INPUT  : true 
+ * OUTPUT : false 
+ * DATA   : Reference to a net_device (struct net_device*)
+ * LAST   : false
+ * 
+ * Remark : If the interface goes down/unregistered, mpls_netdev_event
+ *          (cf. mpls_init.c) will change this opcode.
+ *********************************************************************/
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_set_rx)
+{
+	/* 
+	 * Change the incoming net_device for the socket buffer
+	 */
+	(*skb)->dev = (struct net_device*)data;
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+/* 
+ * Changes: 
+ *	20040120 RCAS: The device must be MPLS enabled and its labelspace != -1
+ */
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_rx) 
+{
+	struct mpls_interface *mpls_if = NULL; 
+	struct mpls_ilm       *pilm    = NULL; 
+	struct net_device     *dev     = NULL;
+	unsigned int if_index          = 0; /* Incoming If Index */
+
+	MPLS_ENTER;
+	*data = NULL;
+	if (direction != MPLS_IN) {
+		MPLS_DEBUG("SET_RX only valid for incoming labels\n");
+		MPLS_EXIT;
+		return -EINVAL;
+	}
+
+	pilm = _mpls_as_ilm(parent);
+	/*
+	 * Get a reference to the device given the interface index
+	 */
+	
+	if_index = instr->mir_set_rx;
+	dev = dev_get_by_index(&init_net, if_index);
+	if (unlikely(!dev)) {
+		MPLS_DEBUG("SET_RX if_index %d unknown\n", if_index);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/*
+	 * Check Interface to see if its MPLS enabled
+	 */
+	mpls_if = mpls_get_if_info(if_index);
+
+	if ( (!mpls_if) || (mpls_if->labelspace == -1)) {
+		MPLS_DEBUG("SET_RX if_index %d MPLS disabled\n", if_index);
+		dev_put (dev);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+	
+	*data = (void*)dev;
+
+	/* 
+	 * Add to the device list of ILMs (list_in) 
+	 * NOTE: we're still holding a ref to dev.
+	 * 
+	 */
+	list_add(&pilm->dev_entry, &(mpls_if->list_in));
+	MPLS_EXIT;
+	return 0;
+}
+
+/* Get the ifIndex of the device and returns it */
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_rx)
+{
+	struct net_device *dev;
+
+	MPLS_ENTER;
+	dev = _mpls_as_netdev(data);
+	instr->mir_set_rx = dev->ifindex;
+	MPLS_EXIT;
+	return 0;
+}
+
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_set_rx) 
+{
+	struct net_device *dev   = NULL;
+	/* dev is already being held */
+	dev = _mpls_as_netdev(data); 
+	mpls_list_del_init(& _mpls_as_ilm(parent)->dev_entry);
+	dev_put(dev);
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_SET
+ * DESC   : "Define the outgoing interface and next hop"
+ * EXEC   : mpls_out_op_set
+ * BUILD  : mpls_build_opcode_set
+ * UNBUILD: mpls_unbuild_opcode_set
+ * CLEAN  : mpls_clean_opcode_set
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : Reference to MPLS destination cache entry (struct mpls_dst*) 
+ * LAST   : true 
+ * 
+ * Remark : If the interface goes down/unregistered, mpls_netdev_event
+ *          (cf. mpls_init.c) will change this opcode.
+ *********************************************************************/
+ 
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_set)
+{
+	struct mpls_dst *md = data;
+
+	MPLS_ENTER;
+
+	/* Release the current dst in the socket buffer */
+	if (skb_dst(*skb)) {
+		dst_release(skb_dst(*skb));
+	}
+
+	/*
+	 * Update the dst field of the skbuffer in "real time" 
+	 */
+	dst_hold(&md->u.dst);
+	skb_dst_set(*skb, &md->u.dst);
+	
+
+	/* don't hold the dev we place in skb->dev, the dst is already */
+	/* holding it for us */
+
+	(*skb)->dev = md->u.dst.dev;
+
+	MPLS_EXIT;
+
+	return MPLS_RESULT_SUCCESS;
+}
+
+/*
+ * JLEU: Are there cases where we do not want to assign a labelspace (which
+ * creates the mpls_if) and still originate MPLS traffic?
+ */
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set) 
+{
+	struct mpls_interface *mpls_if = NULL; 
+	struct mpls_nhlfe  *pnhlfe    = NULL; 
+	struct net_device     *dev     = NULL;
+	struct mpls_dst       *md      = NULL;
+	unsigned int if_index          = 0; /* Outgoing interface index */
+
+	MPLS_ENTER;
+
+	*data = NULL;
+	if (direction != MPLS_OUT) {
+		MPLS_DEBUG("SET only valid for outgoing labels\n");
+		MPLS_EXIT;
+		return -EINVAL;
+	}
+
+	if_index = instr->mir_set.mni_if;
+	dev = dev_get_by_index(&init_net, if_index);
+	
+	if (unlikely(!dev)) {
+		MPLS_DEBUG("SET if_index %d unknown\n", if_index);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	mpls_if = mpls_get_if_info(dev->ifindex);
+	if (!mpls_if) {
+		MPLS_DEBUG("SET not an MPLS interface %d unknown\n", if_index);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/* 
+	 * This opcode will use the passed NHLFE 
+	 */
+	pnhlfe = _mpls_as_nhlfe(parent);
+	WARN_ON(!pnhlfe);
+	
+	/* 
+	 * NOTE: mpls_dst_alloc holds the dev,
+	 * so release the hold from dev lookup
+	 * mpls_dst_alloc calls dst_hold
+	 */
+	md = mpls_dst_alloc(dev, &instr->mir_set.mni_addr);
+	dev_put(dev);
+
+	if (unlikely(!md)) {
+		MPLS_DEBUG("SET error building DST info\n");
+		*data = NULL;
+		MPLS_EXIT;
+		return -ENOMEM;
+	}
+
+
+	/* 
+	 * Update the NHLFE MTU according to the number of pushes. 
+	 */
+	pnhlfe->nhlfe_mtu = dev->mtu - (4 * (*num_push));
+	pnhlfe->nhlfe_mtu_limit = pnhlfe->nhlfe_mtu;
+
+	/* 
+	 * Add to the device list of NHLFEs (list_out) 
+	 * 
+	 */
+	list_add(&pnhlfe->dev_entry, &mpls_if->list_out);
+	*data      = (void*)md;
+	*last_able = 1;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set)
+{
+        struct mpls_dst *md;
+
+        MPLS_ENTER;
+
+	md = data;
+        memcpy(&instr->mir_set.mni_addr, &md->md_nh, sizeof(struct sockaddr));
+        instr->mir_set.mni_if = md->u.dst.dev->ifindex;
+
+        MPLS_EXIT;
+
+        return 0;
+}
+
+
+
+/*
+ *	Clean tasks: 
+ *	- release the mpls_dst (opcode data)
+ *	- remove this nhlfe from the device's list.
+ * 	JLEU: hold device so mpls_dst_release doesn't delete it 
+ *	RCAS: Why do we need to hold the dev ? 
+ */
+MPLS_CLEAN_OPCODE_PROTOTYPE(mpls_clean_opcode_set) 
+{
+	struct mpls_dst   *mdst  = data;
+	struct net_device *dev   = NULL;
+
+	MPLS_ENTER;
+	dev  = mdst->u.dst.dev;
+	dev_hold(dev);
+	mpls_dst_release (mdst);
+	mpls_list_del_init (&_mpls_as_nhlfe(parent)->dev_entry);
+	dev_put(dev);
+	MPLS_EXIT;
+}
+
+
+/*********************************************************************
+ * MPLS_OP_SET_TC
+ * DESC   : "Define the socket buffer (IN/OUT) tc index" 
+ * EXEC   : mpls_out_op_set_tc
+ * BUILD  : mpls_build_opcode_set_tc
+ * UNBUILD: mpls_unbuild_opcode_set_tc
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : true 
+ * DATA   : TC index to apply to skb. (unsigned short *) 
+ * LAST   : false 
+ *********************************************************************/
+#ifdef CONFIG_NET_SCHED
+MPLS_OPCODE_PROTOTYPE(mpls_op_set_tc)
+{
+	unsigned short *tc = NULL;
+	tc = data;
+	(*skb)->tc_index = *tc;
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_tc) 
+{
+	unsigned short *tc = NULL;
+
+	*data = NULL;
+	tc = kmalloc(sizeof(*tc),GFP_ATOMIC);
+	if (unlikely(!tc)) {
+		MPLS_DEBUG("SET_TC error building TC info\n");
+		return -ENOMEM;
+	}
+	*tc   = instr->mir_set_tc;
+	*data = (void*)tc;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_tc)
+{
+	MPLS_ENTER;
+	instr->mir_set_tc = *(unsigned short *)data;
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_SET_DS
+ * DESC   : "Changes the DS field of the IPv4/IPv6 packet"
+ * EXEC   : mpls_in_op_set_ds
+ * BUILD  : mpls_build_opcode_set_ds
+ * UNBUILD: mpls_unbuild_opcode_set_ds
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : false 
+ * DATA   : DS field (unsigned short *) 
+ * LAST   : false 
+ *********************************************************************/
+#ifdef CONFIG_NET_SCHED
+
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_set_ds)
+{
+	unsigned short *ds = data;
+
+	if (!MPLSCB(*skb)->bos) {
+		MPLS_DEBUG("SET_DS and not BOS\n");
+		return MPLS_RESULT_DROP;
+	}
+	MPLSCB(*skb)->prot->change_dsfield(*skb, (*ds));
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_ds) 
+{
+	unsigned char  *ds = NULL;
+	*data = NULL;
+	ds = kmalloc(sizeof(*ds),GFP_ATOMIC);
+	if (unlikely(!ds)) {
+		MPLS_DEBUG("SET_DS error building DS info\n");
+		return -ENOMEM;
+	}
+	*ds = instr->mir_set_ds;
+	if (*ds > 0x3f) {
+		MPLS_DEBUG("SET_DS DS(%02x) too big\n",*ds);
+		return -EINVAL;
+	}
+	*data = (void*)ds;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_ds)
+{
+	MPLS_ENTER;
+	instr->mir_set_ds = *(unsigned short *)data;
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+/*********************************************************************
+ * MPLS_OP_SET_EXP
+ * DESC   : "Changes the 3 EXP bits of the label entry"
+ * EXEC   : mpls_op_set_exp
+ * BUILD  : mpls_build_opcode_set_exp
+ * UNBUILD: mpls_unbuild_opcode_set_exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : true 
+ * DATA   : EXP value (binary 000-111) (unsigned char *) 
+ * LAST   : false 
+ *********************************************************************/
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_set_exp)
+{
+	unsigned char *exp = data;
+	MPLSCB(*skb)->exp = *exp;
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_set_exp) 
+{
+	unsigned char  *exp = NULL;
+	*data = NULL;
+	exp = kmalloc(sizeof(*exp),GFP_ATOMIC);
+	if (unlikely(!exp)) {
+		MPLS_DEBUG("SET_EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+	*exp = instr->mir_set_exp;
+	if (*exp >= MPLS_EXP_NUM) {
+		MPLS_DEBUG("SET_EXP EXP(%d) too big\n",*exp);
+		kfree(exp);
+		return -EINVAL;
+	}
+	*data = (void*)exp;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_set_exp)
+{
+	MPLS_ENTER;
+	instr->mir_set_exp = *(unsigned char *)data;
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+/*********************************************************************
+ * MPLS_OP_EXP2TC
+ * DESC   : "Changes the TC index of the socket buffer according to"
+ *          "the EXP bits in label entry"
+ * EXEC   : mpls_op_exp2tc
+ * BUILD  : mpls_build_opcode_exp2tc
+ * UNBUILD: mpls_unbuild_opcode_exp2tc
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : true 
+ * DATA   : e2ti (struct mpls_exp2tcindex_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+
+#ifdef CONFIG_NET_SCHED
+
+MPLS_OPCODE_PROTOTYPE(mpls_op_exp2tc)
+{
+	struct mpls_exp2tcindex_info *e2ti = NULL;
+
+	BUG_ON(!data);
+	BUG_ON(!(*skb));
+	e2ti = data;
+	if (e2ti->e2t[MPLSCB(*skb)->exp & 0x7] != 0xffff) {
+		(*skb)->tc_index = e2ti->e2t[MPLSCB(*skb)->exp & 0x7];
+	}
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_exp2tc) 
+{
+	struct mpls_exp2tcindex_info *e2ti = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate e2ti object 
+	 */
+	e2ti = kmalloc(sizeof(*e2ti),GFP_ATOMIC);
+	if (unlikely(!e2ti)) {
+		MPLS_DEBUG("EXP2TC error building TC info\n");
+		return -ENOMEM;
+	}
+	/*
+	 * Define (as per instruction) how to map EXP values
+	 * to TC indexes
+	 */
+	for (j = 0;j<MPLS_EXP_NUM; j++) {
+		e2ti->e2t[j] = instr->mir_exp2tc.e2t[j];
+	}
+
+	*data = (void*)e2ti;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_exp2tc)
+{
+	struct mpls_exp2tcindex_info *e2ti = data;
+	int j;
+
+	MPLS_ENTER;
+
+	for(j=0;j<MPLS_EXP_NUM;j++) {
+		instr->mir_exp2tc.e2t[j] = e2ti->e2t[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_EXP2DS
+ * DESC   : "Changes the DS field of the IPv4/IPv6 packet according to"
+ *          "the EXP bits in label entry"
+ * EXEC   : mpls_op_exp2ds
+ * BUILD  : mpls_build_opcode_exp2ds
+ * UNBUILD: mpls_unbuild_opcode_exp2ds
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : true 
+ * OUTPUT : false 
+ * DATA   : e2di (struct mpls_exp2dsmark_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+MPLS_IN_OPCODE_PROTOTYPE(mpls_in_op_exp2ds)
+{
+	struct mpls_exp2dsmark_info *e2di = data;
+
+	if (e2di->e2d[MPLSCB(*skb)->exp & 0x7] == 0xff)
+		return MPLS_RESULT_SUCCESS;
+
+	MPLSCB(*skb)->prot->change_dsfield(*skb, e2di->e2d[MPLSCB(*skb)->exp & 0x7]);
+
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_exp2ds) 
+{
+	struct mpls_exp2dsmark_info *e2di  = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate e2di object 
+	 */
+	e2di = kmalloc(sizeof(*e2di),GFP_ATOMIC);
+	if (unlikely(!e2di)) {
+		MPLS_DEBUG("error building DSMARK info\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Define (as per instruction) how to map EXP values
+	 * to DS fields. 
+	 */
+	for (j = 0; j<MPLS_EXP_NUM; j++) {
+		e2di->e2d[j] = instr->mir_exp2ds.e2d[j];
+	}
+	*data = (void*)e2di;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_exp2ds)
+{
+	struct mpls_exp2dsmark_info *e2di = data;
+	int j;
+
+	MPLS_ENTER;
+
+	for(j=0;j<MPLS_EXP_NUM;j++) {
+		instr->mir_exp2ds.e2d[j] = e2di->e2d[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+/*********************************************************************
+ * MPLS_OP_TC2EXP
+ * DESC   : "Changes the EXP bits of the topmost label entry according"
+ *          "to the TC index in skb & mask"
+ * EXEC   : mpls_op_tc2exp
+ * BUILD  : mpls_build_opcode_tc2exp
+ * UNBUILD: mpls_unbuild_opcode_tc2exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : t2ei (struct mpls_tcindex2exp_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+#ifdef CONFIG_NET_SCHED
+
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_tc2exp)
+{
+	struct mpls_tcindex2exp_info *t2ei = data;
+	unsigned short tc;
+
+	tc = (*skb)->tc_index & t2ei->t2e_mask;
+	if (t2ei->t2e[tc] != 0xFF) {
+		MPLSCB(*skb)->exp = t2ei->t2e[tc];
+	}
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_tc2exp) 
+{
+	struct mpls_tcindex2exp_info *t2ei = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate t2ei object 
+	 */
+	t2ei = kmalloc(sizeof(*t2ei),GFP_ATOMIC);
+	if (unlikely(!t2ei)) {
+		MPLS_DEBUG("TC2EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+	
+	/*
+	 * Define (as per instruction) the mask to apply
+	 */
+	t2ei->t2e_mask = instr->mir_tc2exp.t2e_mask;
+	if (t2ei->t2e_mask >= MPLS_TCINDEX_NUM) {
+		MPLS_DEBUG("TC2EXP mask(%02x) too large\n", t2ei->t2e_mask);
+		kfree (t2ei);
+		return -EINVAL;
+	}
+
+	/*
+	 * Define (as per instruction) how to map TC indexes
+	 * to EXP bits 
+	 */
+	for (j = 0; j<MPLS_TCINDEX_NUM; j++) {
+		t2ei->t2e[j] = instr->mir_tc2exp.t2e[j];
+	}
+	*data = (void*)t2ei;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_tc2exp) 
+{
+	struct mpls_tcindex2exp_info *t2ei = data;
+	int j;
+
+	MPLS_ENTER;
+
+	instr->mir_tc2exp.t2e_mask = t2ei->t2e_mask;
+
+	for (j=0;j<MPLS_TCINDEX_NUM;j++) {
+		instr->mir_tc2exp.t2e[j] = t2ei->t2e[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+#endif
+
+
+
+/*********************************************************************
+ * MPLS_OP_DS2EXP
+ * DESC   : "Changes the EXP bits of the topmost label entry according"
+ *          "to the DS field of the IPv4/IPv6 packet"
+ * EXEC   : mpls_op_ds2exp
+ * BUILD  : mpls_build_opcode_ds2exp
+ * UNBUILD: mpls_unbuild_opcode_ds2exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : d2ei (struct mpls_dsmark2exp_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_ds2exp)
+{
+	struct mpls_dsmark2exp_info *d2ei = data;
+	unsigned char ds;
+
+	ds = MPLSCB(*skb)->prot->get_dsfield(*skb);
+
+	if (d2ei->d2e[ds] != 0xFF) {
+		MPLSCB(*skb)->exp = d2ei->d2e[ds];
+	}
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_ds2exp) 
+{
+	struct mpls_dsmark2exp_info *d2ei  = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate d2ei object 
+	 */
+	d2ei = kmalloc(sizeof(*d2ei),GFP_ATOMIC);
+	if (unlikely(!d2ei)) {
+		MPLS_DEBUG("DS2EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Define (as per instruction) the mask to apply
+	 */
+	d2ei->d2e_mask = instr->mir_ds2exp.d2e_mask;
+	if (d2ei->d2e_mask >= MPLS_DSMARK_NUM) {
+		MPLS_DEBUG("DS2EXP mask(%02x) too large\n", d2ei->d2e_mask);
+		kfree(d2ei);
+		return -EINVAL;
+	}
+
+	/*
+	 * Define (as per instruction) how to map DS marks 
+	 * to EXP bits 
+	 */
+	for (j = 0; j<MPLS_DSMARK_NUM; j++) {
+		d2ei->d2e[j] = instr->mir_ds2exp.d2e[j];
+	}
+	*data = (void*)d2ei;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_ds2exp) 
+{
+	struct mpls_dsmark2exp_info *d2ei = data;
+	int j;
+
+	MPLS_ENTER;
+
+	instr->mir_ds2exp.d2e_mask = d2ei->d2e_mask;
+
+	for (j=0;j<MPLS_DSMARK_NUM;j++) {
+		instr->mir_ds2exp.d2e[j] = d2ei->d2e[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+
+
+
+
+/*********************************************************************
+ * MPLS_OP_NF2EXP
+ * DESC   : "Changes the EXP bits of the topmost label entry according"
+ *          "to the NF mark of the socket buffer". 
+ * EXEC   : mpls_op_nf2exp
+ * BUILD  : mpls_build_opcode_nf2exp
+ * UNBUILD: mpls_build_opcode_nf2exp
+ * CLEAN  : mpls_clean_opcode_generic 
+ * INPUT  : false 
+ * OUTPUT : true 
+ * DATA   : n2ei (struct mpls_nfmark2exp_info*) - No ILM/NHLFE are held. 
+ * LAST   : false 
+ *********************************************************************/
+
+#ifdef CONFIG_NETFILTER
+MPLS_OUT_OPCODE_PROTOTYPE(mpls_out_op_nf2exp)
+{
+	struct mpls_nfmark2exp_info *n2ei = NULL;
+	unsigned short nf = 0;
+
+	BUG_ON(NULL == data);
+	BUG_ON(NULL == *skb);
+	n2ei = data;
+	nf   = (*skb)->mark & n2ei->n2e_mask;
+	if (n2ei->n2e[nf] != 0xFF) {
+		MPLSCB(*skb)->exp = n2ei->n2e[nf];
+	}
+
+	return MPLS_RESULT_SUCCESS;
+}
+
+
+MPLS_BUILD_OPCODE_PROTOTYPE(mpls_build_opcode_nf2exp)
+{
+	struct mpls_nfmark2exp_info *n2ei  = NULL;
+	int j;
+
+	*data = NULL;
+	/*
+	 * Allocate d2ei object 
+	 */
+	n2ei = kmalloc(sizeof(*n2ei),GFP_ATOMIC);
+	if(unlikely(!n2ei)) {
+		MPLS_DEBUG("NF2EXP error building EXP info\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Define (as per instruction) the mask to apply
+	 */
+	n2ei->n2e_mask = instr->mir_nf2exp.n2e_mask;
+	if (n2ei->n2e_mask >= MPLS_NFMARK_NUM) {
+		MPLS_DEBUG("NF2EXP mask(%02x) too large\n", n2ei->n2e_mask);
+		kfree(n2ei);
+		return -EINVAL;
+	}
+
+	/*
+	 * Define (as per instruction) how to map NF marks 
+	 * to EXP bits 
+	 */
+	for (j = 0; j<MPLS_NFMARK_NUM; j++) {
+		n2ei->n2e[j] = instr->mir_nf2exp.n2e[j];
+	}
+	*data = (void*)n2ei;
+	return 0;
+}
+
+MPLS_UNBUILD_OPCODE_PROTOTYPE(mpls_unbuild_opcode_nf2exp)
+{
+	struct mpls_nfmark2exp_info *n2ei = data;
+	int j;
+
+	MPLS_ENTER;
+
+	instr->mir_nf2exp.n2e_mask = n2ei->n2e_mask;
+
+	for(j=0;j<MPLS_NFMARK_NUM;j++) {
+		instr->mir_nf2exp.n2e[j] = n2ei->n2e[j];
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+#endif
+
+
+
+
+
+
+
+
+/*********************************************************************
+ * Main data type to hold metainformation on opcodes
+ * IN      : Function pointer to execute in ILM object
+ * OUT     : Function pointer to execute in NHLFE object
+ * BUILD   : Function pointer to build the opcode 
+ * CLEANUP : Function pointer to clean the opcode 
+ * EXTRA   : Ready to transmit (SET)
+ * MSG     : Human readable format
+ *********************************************************************/
+
+struct mpls_ops mpls_ops[MPLS_OP_MAX] = {
+	[MPLS_OP_NOP] = {
+		.in      = mpls_op_nop,
+		.out     = mpls_op_nop,
+		.build   = NULL,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "NOP",
+	},
+	[MPLS_OP_POP] = {
+		.in      = mpls_in_op_pop,
+		.out     = NULL,
+		.build   = mpls_build_opcode_pop,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "POP",
+	},
+	[MPLS_OP_PEEK] = {
+		.in      = mpls_in_op_peek,
+		.out     = NULL,
+		.build   = mpls_build_opcode_peek,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "PEEK",
+	},
+	[MPLS_OP_PUSH] = {
+		.in      = mpls_op_push,
+		.out     = mpls_op_push,
+		.build   = mpls_build_opcode_push,
+		.unbuild = mpls_unbuild_opcode_push,
+		.cleanup = mpls_clean_opcode_push,
+		.extra   = 0,
+		.msg     = "PUSH",
+	},
+	[MPLS_OP_DLV] = {
+		.in      = mpls_in_op_dlv,
+		.out     = NULL,
+		.build   = mpls_build_opcode_dlv,
+		.unbuild = NULL,
+		.cleanup = NULL,
+		.extra   = 0,
+		.msg     = "DLV",
+	},
+	[MPLS_OP_FWD] = {
+		.in      = mpls_op_fwd,
+		.out     = mpls_op_fwd,
+		.build   = mpls_build_opcode_fwd,
+		.unbuild = mpls_unbuild_opcode_fwd,
+		.cleanup = mpls_clean_opcode_fwd,
+		.extra   = 0,
+		.msg     = "FWD",
+	},
+#ifdef CONFIG_NETFILTER
+	[MPLS_OP_NF_FWD] = {
+		.in      = NULL,
+		.out     = mpls_out_op_nf_fwd,
+		.build   = mpls_build_opcode_nf_fwd,
+		.unbuild = mpls_unbuild_opcode_nf_fwd,
+		.cleanup = mpls_clean_opcode_nf_fwd,
+		.extra   = 0,
+		.msg     = "NF_FWD",
+	},
+#endif
+	[MPLS_OP_DS_FWD] = {
+		.in      = NULL,
+		.out     = mpls_out_op_ds_fwd,
+		.build   = mpls_build_opcode_ds_fwd,
+		.unbuild = mpls_unbuild_opcode_ds_fwd,
+		.cleanup = mpls_clean_opcode_ds_fwd,
+		.extra   = 0,
+		.msg     = "DS_FWD",
+	},
+	[MPLS_OP_EXP_FWD] = {
+		.in      = mpls_op_exp_fwd,
+		.out     = mpls_op_exp_fwd,
+		.build   = mpls_build_opcode_exp_fwd,
+		.unbuild = mpls_unbuild_opcode_exp_fwd,
+		.cleanup = mpls_clean_opcode_exp_fwd,
+		.extra   = 0,
+		.msg     = "EXP_FWD",
+	},
+	[MPLS_OP_SET_RX] = {
+		.in      = mpls_in_op_set_rx,
+		.out     = NULL,
+		.build   = mpls_build_opcode_set_rx,
+		.unbuild = mpls_unbuild_opcode_set_rx,
+		.cleanup = mpls_clean_opcode_set_rx,
+		.extra   = 0,
+		.msg     = "SET_RX",
+	},
+	[MPLS_OP_SET] = {
+		.in      = NULL,
+		.out     = mpls_out_op_set,
+		.build   = mpls_build_opcode_set,
+		.unbuild = mpls_unbuild_opcode_set,
+		.cleanup = mpls_clean_opcode_set,
+		.extra   = 1,
+		.msg     = "SET",
+	},
+#ifdef CONFIG_NET_SCHED
+	[MPLS_OP_SET_TC] = {
+		.in      = mpls_op_set_tc,
+		.out     = mpls_op_set_tc,
+		.build   = mpls_build_opcode_set_tc,
+		.unbuild = mpls_unbuild_opcode_set_tc,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "SET_TC",
+	},
+	[MPLS_OP_SET_DS] = {
+		.in      = mpls_in_op_set_ds,
+		.out     = NULL,
+		.build   = mpls_build_opcode_set_ds,
+		.unbuild = mpls_unbuild_opcode_set_ds,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "SET_DS",
+	},
+#endif
+	[MPLS_OP_SET_EXP] = {
+		.in      = mpls_op_set_exp,
+		.out     = mpls_op_set_exp,
+		.build   = mpls_build_opcode_set_exp,
+		.unbuild = mpls_unbuild_opcode_set_exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "SET_EXP",
+	},
+#ifdef CONFIG_NET_SCHED
+	[MPLS_OP_EXP2TC] = {
+		.in      = mpls_op_exp2tc,
+		.out     = mpls_op_exp2tc,
+		.build   = mpls_build_opcode_exp2tc,
+		.unbuild = mpls_unbuild_opcode_exp2tc,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "EXP2TC",
+	},
+#endif
+	[MPLS_OP_EXP2DS] = {
+		.in      = mpls_in_op_exp2ds,
+		.out     = NULL,
+		.build   = mpls_build_opcode_exp2ds,
+		.unbuild = mpls_unbuild_opcode_exp2ds,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "EXP2DS",
+	},
+#ifdef CONFIG_NET_SCHED
+	[MPLS_OP_TC2EXP] = {
+		.in      = NULL,
+		.out     = mpls_out_op_tc2exp,
+		.build   = mpls_build_opcode_tc2exp,
+		.unbuild = mpls_unbuild_opcode_tc2exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "TC2EXP",
+	},
+#endif
+	[MPLS_OP_DS2EXP] = {
+		.in      = NULL,
+		.out     = mpls_out_op_ds2exp,
+		.build   = mpls_build_opcode_ds2exp,
+		.unbuild = mpls_unbuild_opcode_ds2exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "DS2EXP",
+	},
+#ifdef CONFIG_NETFILTER
+	[MPLS_OP_NF2EXP] = {
+		.in      = NULL,
+		.out     = mpls_out_op_nf2exp,
+		.build   = mpls_build_opcode_nf2exp,
+		.unbuild = mpls_unbuild_opcode_nf2exp,
+		.cleanup = mpls_clean_opcode_generic,
+		.extra   = 0,
+		.msg     = "NF2EXP",
+	},
+#endif
+};
diff -Nur linux-3.14.1/net/mpls/mpls_output.c linux-3.14.1_mpls/net/mpls/mpls_output.c
--- linux-3.14.1/net/mpls/mpls_output.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_output.c	2014-04-23 18:21:55.144188741 +0530
@@ -0,0 +1,393 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <net/ip.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/dst.h>
+#include <net/ip_fib.h>
+#include <net/mpls.h>
+#include <linux/ip.h>
+#include <net/dsfield.h>
+
+/**
+ *	mpls_send - Send a labelled packet.
+ *	@skb: Ready to go socket buffer.
+ *	@mtu: MTU of the NHLFE that got us here.
+ *
+ *	Send the socket buffer to the next hop. It assumes that everything has
+ *	been properly set up. In order to forward/send the packet, there are two 
+ *	methods, using either:
+ *	a) hh->hh_output(skb);
+ *	b) skb->dst->neighbour->output(skb);
+ *
+ *	Please note that this function is only called from mpls_output2, and  
+ *	even in the case of a transmission error, the sbk is not freed (it will 
+ *	be freed by the caller).
+ *	Returns: MPLS_RESULT_SUCCESS or MPLS_RESULT_DROP
+ **/
+
+static int 
+mpls_send (struct sk_buff *skb, int mtu) 
+{
+	int retval = MPLS_RESULT_SUCCESS;
+	struct mpls_prot_driver *prot = MPLSCB(skb)->prot;
+#if 0 /* Added new for this kernel alone */ 
+#else
+       struct neighbour *neighbour; 
+#endif
+
+	if (MPLSCB(skb)->popped_bos) {
+		if (MPLSCB(skb)->ttl < MPLSCB(skb)->prot->get_ttl(skb)) {
+			prot->set_ttl(skb, MPLSCB(skb)->ttl);
+		}
+		switch(prot->family) {
+			case AF_INET:
+				skb->protocol = htons(ETH_P_IP);
+				break;
+			case AF_INET6:
+				skb->protocol = htons(ETH_P_IPV6);
+				break;
+			case AF_PACKET:
+				skb->protocol = 0;
+				skb->mac_header = skb->network_header;
+				break;
+			default:
+				MPLS_ASSERT(0);
+		}
+	} else {
+		skb->protocol = htons(ETH_P_MPLS_UC);
+	}
+
+	MPLS_DEBUG("output device = %s\n",skb->dev->name);
+
+#ifdef WE_NEED_TO_FIX_HH_HEADER_BEFORE_SENDING
+	mpls_finish(skb);
+#endif
+	MPLS_DEBUG_CALL(mpls_skb_dump(skb));
+
+	if (skb->len > skb_dst(skb)->dev->mtu) {
+
+		printk("MPLS: packet exceeded MTU %d > %d (%d)\n", skb->len,
+		    skb->dev->mtu, mtu);
+
+		retval = prot->mtu_exceeded(&skb, mtu);
+
+		if (retval)
+			goto mpls_send_exit;
+
+		/* otherwise prot->mtu_exceeded() has returned a
+		 * modified skb that it wants to be forwarded
+		 * down the LSP
+		 */
+	}
+
+        if (unlikely(skb->protocol &&
+		(skb_headroom(skb) < LL_RESERVED_SPACE(skb_dst(skb)->dev)) &&
+		skb_dst(skb)->dev->header_ops)) {
+		struct sk_buff *skb2;
+
+		MPLS_DEBUG("alloc'ing more headroom\n");
+		if (!(skb2 = skb_realloc_headroom(skb,
+			LL_RESERVED_SPACE(skb_dst(skb)->dev)))) {
+			retval = MPLS_RESULT_DROP;
+			goto mpls_send_exit;
+                }
+		if (skb->sk)
+			skb_set_owner_w(skb2, skb->sk);
+		kfree_skb(skb);
+		skb = skb2;
+        }
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest*/
+	if(skb_dst(skb)->neighbour) {
+		MPLS_DEBUG("using neighbour (%p)\n",skb);
+		skb_dst(skb)->neighbour->output(skb);
+#else
+        neighbour = dst_neigh_lookup_skb(skb_dst(skb), skb);  
+	if(neighbour) {
+		MPLS_DEBUG("using neighbour (%p)\n",skb);
+		neighbour->output(neighbour, skb);
+#endif
+	} else {
+
+		MPLS_DEBUG("no hh no neighbor!?\n");
+		retval = MPLS_RESULT_DROP;
+	}
+mpls_send_exit:
+	MPLS_DEBUG("mpls_send result %d\n",retval);
+	return retval;
+}
+
+/**
+ *	mpls_output2 - Apply out segment to socket buffer 
+ *	@sbk: Socket buffer.
+ *	@nhlfe: NHLFE object containint the list of opcodes to apply.
+ *
+ *	This function is either called by mpls_input or mpls_output, and 
+ *	iterates the set of output opcodes that are configured for this nhlfe.
+ **/
+
+int mpls_output2 (struct sk_buff *skb,struct mpls_nhlfe *nhlfe)
+{
+	struct mpls_instr *mi;
+	int result = 0;
+	int ready_to_tx = 0;
+	int mtu = nhlfe->nhlfe_mtu;
+
+	MPLS_OUT_OPCODE_PROTOTYPE(*func);
+
+	MPLS_ENTER;
+
+	/*
+	 * about to mangle skb, prepare it for writing and
+	 * make sure headroom has space for mac header and shim
+	 *
+	 * ideally we would know how many shims we will add
+	 * and what the eventual tx interface link layer header
+	 * size will be
+	 *
+	 * maybe look at nhlfe_mtu?
+	 */
+	if (skb_cow(skb, SKB_DATA_ALIGN(skb->mac_len + 4))) {
+		goto mpls_output2_drop;
+	}
+
+/* Support of rec. output */
+mpls_output2_start:
+	ready_to_tx = 0;
+	nhlfe->nhlfe_stats.packets++;
+	nhlfe->nhlfe_stats.bytes += skb->len;
+
+	/* Iterate all the opcodes for this NHLFE */
+	for (mi = nhlfe->nhlfe_instr; mi; mi = mi->mi_next) {
+		int opcode = mi->mi_opcode;
+		void* data = mi->mi_data;
+		char* msg  = mpls_ops[opcode].msg;
+		MPLS_DEBUG("opcode %s\n",msg);
+
+		if (mpls_ops[opcode].extra) 
+			ready_to_tx = 1;
+
+		if ((func = mpls_ops[opcode].out)) {
+			switch ( func (&skb,NULL,&nhlfe,data)) {
+				case MPLS_RESULT_RECURSE:
+				case MPLS_RESULT_DLV:
+				case MPLS_RESULT_DROP:
+					goto mpls_output2_drop;
+				case MPLS_RESULT_FWD:
+					goto mpls_output2_start;
+				case MPLS_RESULT_SUCCESS:
+					break;
+			}
+		}
+	}
+
+	/* 
+	 * The control plane should have let the opcodes in a coherent
+	 * state. The last one should have enabled tx. 
+	 */
+	if (!ready_to_tx) 
+		goto mpls_output2_drop;
+
+	/*
+	 * Actually do the forwarding
+	 */
+	result = mpls_send (skb, mtu);
+	
+	if (result != MPLS_RESULT_SUCCESS)
+		goto mpls_output2_drop;
+
+	MPLS_EXIT;
+	return NET_XMIT_SUCCESS;
+
+mpls_output2_drop:
+	MPLS_DEBUG("FWD F'ed up instruction!\n");
+	if (nhlfe) 
+		nhlfe->nhlfe_drops++;
+	kfree_skb(skb);
+	MPLS_EXIT;
+	return NET_XMIT_DROP;
+}
+
+/**
+ *	mpls_output_shim - Push a label entry and send the packet.
+ *	@skb: socket buffer.
+ *	@nhlfe: NHLFE object to apply.
+ *
+ *	This function is *only* called by mpls_output, and calls 
+ *	mpls_output2 with a MPLS "push data" struct filled up 
+ *	with default values. The "bottom of stack" flag is asserted.
+ **/
+
+int mpls_output_shim (struct sk_buff *skb, struct mpls_nhlfe *nhlfe)
+{
+	struct mpls_prot_driver *prot;
+	int retval = 0;
+	int ttl;
+
+	prot = mpls_proto_find_by_ethertype(skb->protocol);
+	if (unlikely(!prot)) {
+		printk("MPLS: unable to find a protocol driver(%d)\n",
+			htons(skb->protocol));
+		goto mpls_output_error;
+	}
+
+	/*
+	 * JLEU: we only propagate the TTL if the SKB came from
+	 * IP[46] _and_ nhlfe_propagate_ttl is set to 1, otherwise we
+	 * set the TTL sysctl_mpls_default_ttl
+	 */
+	ttl = sysctl_mpls_default_ttl;
+	if (nhlfe->nhlfe_propagate_ttl) {
+		ttl = prot->get_ttl(skb);
+	}
+
+	MPLSCB(skb)->prot = prot;
+	MPLSCB(skb)->label = 0;
+	MPLSCB(skb)->ttl = ttl;
+	MPLSCB(skb)->exp = 0;
+	MPLSCB(skb)->bos = 1;
+	MPLSCB(skb)->flag = 0;
+	MPLSCB(skb)->popped_bos = 1;
+	MPLSCB(skb)->gap = 0;
+
+	retval = mpls_output2(skb,nhlfe);
+	/* release since we held above and the packet is now gone */
+	mpls_proto_release(prot);
+	return retval;
+
+mpls_output_error:
+	kfree_skb(skb);
+	return NET_XMIT_DROP;
+}
+
+
+
+/**
+ *	mpls_output - Send a packet using MPLS forwarding.
+ *	@skb: socket buffer containing the packet to send.
+ *
+ *	This function is called by the upper layers, in order to 
+ *	forward a data packet using MPLS. It assumes that the buffer
+ *	is ready, most notably, that skb_dst(skb) field is valid and
+ *	is part of a valid NHLFE. After some error checking, calls 
+ *	mpls_output_shim. 
+ *
+ *	NOTE: Please note that we *push* a label. A cross-connect (SWAP)
+ *	is a ILM/POP + NHLFE/PUSH
+ **/
+
+int mpls_output (struct sk_buff *skb) 
+{
+	struct mpls_nhlfe* nhlfe = NULL;
+
+	MPLS_ENTER;
+
+	if (unlikely(!skb_dst(skb))) {
+		printk("MPLS: No dst in skb\n");
+		goto mpls_output_drop;
+	}
+	if (unlikely(skb_dst(skb)->ops->protocol != htons(ETH_P_MPLS_UC))) {
+		printk("MPLS: Not a MPLS dst in skb\n");
+		goto mpls_output_drop;
+	}
+	nhlfe = container_of(skb_dst(skb), struct mpls_nhlfe, u.dst);
+	if (unlikely(!nhlfe)) {
+		printk("MPLS: unable to find NHLFE from dst\n");
+		goto mpls_output_drop;
+	}
+
+	/* we do the 'share' here, because, Layer 3 enters via this function,
+	 * and we only have to worry about 'sharing' when the packet came from
+	 * a layer 3 protocol
+	 */
+	skb = skb_share_check(skb, GFP_ATOMIC);
+	if (unlikely(!skb)) {
+		printk("MPLS: unable to share skb\n");
+		goto mpls_output_drop;
+	}
+
+	/*
+	 * if this packet thinks the hardware is going to do the
+	 * checksum, it had better think again.  By the time this
+	 * packet makes it to the hardware, it will be an MPLS packet
+	 * and the IP packet will mearly be the MPLS payload.
+	 * The hardware will not know how to add a checksum to the
+	 * payload of a MPLS packet ....
+	 */
+	if (skb->ip_summed == CHECKSUM_COMPLETE) {
+		if (skb_checksum_help(skb))
+			goto mpls_output_drop;
+	}
+
+	MPLS_EXIT;
+	return mpls_output_shim(skb,nhlfe);
+
+mpls_output_drop:
+	kfree_skb(skb);
+	MPLS_EXIT;
+	return NET_XMIT_DROP;
+}
+
+/**
+ *	mpls_switch - Label switch a packet coming from mpls_input
+ *	@skb: socket buffer containing the packet to send.
+ *
+ *	This function is called by mpls_input, in order to 
+ *	label switch a data packet. It assumes that the socket
+ *	is ready, most notably, that skb_dst(skb) field is valid and
+ *	is part of a valid NHLFE. After some error checking, calls 
+ *	mpls_output2. 
+ *	NOTE: Please note that we *push* a label. The current label was
+ *	already poped in mpls_input.
+ **/
+int mpls_switch (struct sk_buff *skb) 
+{
+	struct mpls_nhlfe* nhlfe = NULL;
+	struct mpls_prot_driver *prot;
+	int retval;
+
+	if (unlikely(!skb_dst(skb))) {
+		printk("MPLS: No dst in skb\n");
+		goto mpls_switch_drop;
+	}
+	if (unlikely(skb_dst(skb)->ops->protocol != htons(ETH_P_MPLS_UC))) {
+		printk("MPLS: Not a MPLS dst in skb\n");
+		goto mpls_switch_drop;
+	}
+	nhlfe = container_of(skb_dst(skb), struct mpls_nhlfe, u.dst);
+	if (unlikely(!nhlfe)) {
+		printk("MPLS: unable to find NHLFE from dst\n");
+		goto mpls_switch_drop;
+	}
+
+	prot = MPLSCB(skb)->prot;
+	retval = mpls_output2(skb,nhlfe);
+	/* mpls_input() does a mpls_proto_hold() */
+	mpls_proto_release(prot);
+	return retval;
+
+mpls_switch_drop:
+	kfree_skb(skb);
+	return NET_XMIT_DROP;
+}
+
+EXPORT_SYMBOL(mpls_output2);
+EXPORT_SYMBOL(mpls_output_shim);
diff -Nur linux-3.14.1/net/mpls/mpls_procfs.c linux-3.14.1_mpls/net/mpls/mpls_procfs.c
--- linux-3.14.1/net/mpls/mpls_procfs.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_procfs.c	2014-04-23 22:21:03.543804930 +0530
@@ -0,0 +1,149 @@
+/*
+ *      Network mpls interface for protocols that live below L3 and above L2
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *	Heavily borrowed from dev_remove_pack/dev_add_pack
+ *
+ *	Authors:	James R. Leu <jleu@mindspring.com>
+ */
+
+#include <generated/autoconf.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+#include <linux/list.h>
+#include <net/mpls.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <net/net_namespace.h>
+#include <linux/module.h>
+
+extern spinlock_t mpls_proto_lock;
+extern struct list_head mpls_proto_list;
+
+/*
+ * MODULE Information and attributes
+ */
+
+MODULE_AUTHOR("James R. Leu <jleu@mindspring.com>");
+MODULE_DESCRIPTION("net-mpls procfs module");
+MODULE_LICENSE("GPL");
+
+/*
+ * The following few functions build the content of /proc/net/mpls
+ */
+
+/* starting at mpls, find the next registered protocol */
+static struct mpls_prot_driver *mpls_skip(struct mpls_prot_driver *mpls)
+{
+	struct mpls_prot_driver *mpls1;
+	int next = 0;
+
+	if (!mpls)
+		next = 1;
+		
+	list_for_each_entry(mpls1, &mpls_proto_list, list) {
+		if (next)
+			return mpls1;
+
+		if (mpls1 == mpls)
+			next = 1;
+	}
+
+	return NULL;
+}
+
+										
+/* start read of /proc/net/mpls */
+static void *mpls_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct mpls_prot_driver *mpls;
+	loff_t i = 1;
+
+	spin_lock_bh(&mpls_proto_lock);
+
+	if (*pos == 0)
+		return SEQ_START_TOKEN;
+
+	for (mpls = mpls_skip(NULL); mpls && i < *pos;
+		mpls = mpls_skip(mpls), ++i);
+										
+	return (i == *pos) ? mpls : NULL;
+}
+
+static void *mpls_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	++*pos;
+										
+	return mpls_skip((v == SEQ_START_TOKEN)
+			    ? NULL
+			    : (struct mpls_prot_driver *)v);
+}
+										
+static void mpls_seq_stop(struct seq_file *seq, void *v)
+{
+	spin_unlock_bh(&mpls_proto_lock);
+}
+
+static int mpls_seq_show(struct seq_file *seq, void *v)
+{
+	struct mpls_prot_driver* mpls = (struct mpls_prot_driver*)v;
+	if (v != SEQ_START_TOKEN)
+		seq_printf(seq, "%s\t%d\n",
+		    mpls->name ? mpls->name : "(none)",
+		    atomic_read(&mpls->__refcnt));
+	return 0;
+}
+
+/*
+ *      Generic /proc/net/mpls file and inode operations
+ */
+										
+static struct seq_operations mpls_seq_ops = {
+	.start = mpls_seq_start,
+	.next = mpls_seq_next,
+	.stop = mpls_seq_stop,
+	.show = mpls_seq_show,
+};
+										
+static int mpls_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &mpls_seq_ops);
+}
+										
+static struct file_operations mpls_seq_fops = {
+	.owner   = THIS_MODULE,
+	.open    = mpls_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+
+int __init mpls_procfs_init(void)
+{
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	if (!proc_net_fops_create(&init_net, "mpls",  S_IRUGO,
+				  &mpls_seq_fops)) {
+#else
+	if (!proc_create( "mpls",  S_IRUGO, NULL,
+				  &mpls_seq_fops)) {
+#endif
+		printk(MPLS_ERR "MPLS: failed to register with procfs\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void __exit mpls_procfs_exit(void)
+{
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	proc_net_remove(&init_net, "mpls");
+#else
+	remove_proc_entry("mpls", NULL);
+#endif
+}
diff -Nur linux-3.14.1/net/mpls/mpls_proto.c linux-3.14.1_mpls/net/mpls/mpls_proto.c
--- linux-3.14.1/net/mpls/mpls_proto.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_proto.c	2014-04-23 10:17:34.637528786 +0530
@@ -0,0 +1,154 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * mpls_proto.c: MPLS Proto management
+ *
+ * Copyright (C) David S. Miller (davem@redhat.com),
+ *		 James R. Leu (jleu@mindspring.com)
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ *	RCAS: minor changes (formatting) and added addr
+ *	JLEU: added mpls_prot_cache_flush_all()
+ *	JLEU: rewrote most of the functions to allow for more
+ *	       families then just IPv4 and IPv6
+ *****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <linux/rculist.h>
+#include <net/mpls.h>
+
+DEFINE_SPINLOCK(mpls_proto_lock);
+LIST_HEAD(mpls_proto_list);
+
+int mpls_proto_add(struct mpls_prot_driver *proto)
+{
+        spin_lock_bh(&mpls_proto_lock);
+
+        atomic_set(&proto->__refcnt, 1);
+        list_add_rcu(&proto->list, &mpls_proto_list);
+
+        spin_unlock_bh(&mpls_proto_lock);
+	return 0;
+}
+
+int mpls_proto_remove(struct mpls_prot_driver *proto)
+{
+        struct mpls_prot_driver *proto1;
+        int retval = -EPROTONOSUPPORT;
+
+        spin_lock_bh(&mpls_proto_lock);
+
+        list_for_each_entry(proto1, &mpls_proto_list, list) {
+                if (proto == proto1) {
+                        if (atomic_read(&proto->__refcnt) != 1) {
+                                retval = -EADDRINUSE;
+                        } else {
+                                list_del_rcu(&proto->list);
+                                retval = 0;
+                        }
+                        break;
+                }
+        }
+        spin_unlock_bh(&mpls_proto_lock);
+
+        synchronize_net();
+        return retval;
+}
+
+struct mpls_prot_driver *mpls_proto_find_by_family(unsigned short fam)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+                if (fam == proto->family) {
+                        mpls_proto_hold(proto);
+                        goto out;
+                }
+        }
+        proto = NULL;
+out:
+	rcu_read_unlock();
+
+        return proto;
+}
+
+struct mpls_prot_driver *mpls_proto_find_by_ethertype(unsigned short type)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+                if (type == proto->ethertype) {
+                        mpls_proto_hold(proto);
+                        goto out;
+                }
+        }
+        proto = NULL;
+out:
+	rcu_read_unlock();
+
+        return proto;
+}
+
+struct mpls_prot_driver *mpls_proto_find_by_name(char *name)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+                if (!strncmp(name, proto->name, MPLSPROTONAMSIZ)) {
+                        mpls_proto_hold(proto);
+                        goto out;
+                }
+        }
+        proto = NULL;
+out:
+	rcu_read_unlock();
+
+        return proto;
+}
+
+void mpls_proto_cache_flush_all(struct net *net)
+{
+        struct mpls_prot_driver *proto;
+
+	rcu_read_lock();
+        list_for_each_entry_rcu(proto, &mpls_proto_list, list) {
+		proto->cache_flush(net);
+        }
+	rcu_read_unlock();
+}
+
+void __init mpls_proto_init(void)
+{
+	printk("MPLS: protocol driver interface - <jleu@mindspring.com>\n");
+}
+
+void __exit mpls_proto_exit(void)
+{
+}
+
+EXPORT_SYMBOL(mpls_proto_add);
+EXPORT_SYMBOL(mpls_proto_remove);
+EXPORT_SYMBOL(mpls_proto_find_by_family);
+EXPORT_SYMBOL(mpls_proto_find_by_ethertype);
+EXPORT_SYMBOL(mpls_proto_find_by_name);
+EXPORT_SYMBOL(mpls_proto_cache_flush_all);
+EXPORT_SYMBOL(mpls_proto_lock);
+EXPORT_SYMBOL(mpls_proto_list);
diff -Nur linux-3.14.1/net/mpls/mpls_shim.c linux-3.14.1_mpls/net/mpls/mpls_shim.c
--- linux-3.14.1/net/mpls/mpls_shim.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_shim.c	2014-04-23 22:05:39.015427825 +0530
@@ -0,0 +1,109 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *
+ *   (c) 1999-2005   James Leu        <jleu@mindspring.com>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ * 20051122 JLEU
+ *	- seperate shim code from init
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <net/shim.h>
+#include <net/mpls.h>
+
+/**
+ *	mpls_set_nexthop2
+ *	@nhlfe: the nhlfe object to apply to the dst
+ *	@dst: dst_entry 
+ *
+ *	Called from outside the MPLS subsystem. 
+ **/
+
+int mpls_set_nexthop2(struct mpls_nhlfe *nhlfe, struct dst_entry *dst)
+{
+	MPLS_ENTER;
+
+#if 0 /* Ported from linux 2.6.35 which is not present in latest */
+	dst->metrics[RTAX_MTU-1] = nhlfe->nhlfe_mtu;
+#else
+	dst->_metrics = nhlfe->nhlfe_mtu;
+#endif
+	dst->child = dst_clone(&nhlfe->u.dst);
+	MPLS_DEBUG("nhlfe: %p mtu: %d dst: %p\n", nhlfe, nhlfe->nhlfe_mtu,
+		&nhlfe->u.dst);
+
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ *	mpls_set_nexthop
+ *	@shim:holds the key to look up the NHLFE object to apply.
+ *	@dst: dst_entry 
+ *
+ *	Called from outside the MPLS subsystem. 
+ **/
+
+int mpls_set_nexthop (struct shim_blk *sblk, struct dst_entry *dst)
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	unsigned int key;
+	int ret;
+
+	MPLS_ENTER;
+
+	memcpy(&key, sblk->data, sizeof(key));
+	nhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!nhlfe)) {
+		MPLS_EXIT;
+		return -ENXIO;
+	}
+
+	ret = mpls_set_nexthop2(nhlfe, dst);
+	mpls_nhlfe_release(nhlfe);
+	MPLS_EXIT;
+ 	return ret;
+}
+
+/**
+ *	mpls_uc_shim - "SPECIAL" next hop Management for MPLS UC traffic.
+ *	@name: name of the struct.
+ *	@build: Callback used to build
+ *
+ *	e.g. for a MPLS enabled iproute2:
+ *	ip route add a.b.c.d/n via x.y.z.w shim mpls 0x2
+ *	The key (0x2) is the "data" for NHLFE lookup.
+ **/
+ 
+static struct shim mpls_uc_shim = {
+	.name = "mpls",
+	.build = mpls_set_nexthop,
+};
+
+void __init mpls_shim_init (void) 
+{
+	shim_proto_add(&mpls_uc_shim);
+}
+
+void __exit mpls_shim_exit (void)
+{
+	shim_proto_remove (&mpls_uc_shim);
+	synchronize_net();
+}
+
+EXPORT_SYMBOL(mpls_set_nexthop2);
+EXPORT_SYMBOL(mpls_set_nexthop);
diff -Nur linux-3.14.1/net/mpls/mpls_sysctl.c linux-3.14.1_mpls/net/mpls/mpls_sysctl.c
--- linux-3.14.1/net/mpls/mpls_sysctl.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_sysctl.c	2014-04-23 10:22:05.766120238 +0530
@@ -0,0 +1,45 @@
+/*
+ * sysctl_net_mpls.c: sysctl interface to net MPLS subsystem.
+ */
+
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+#include <net/mpls.h>
+
+static ctl_table mpls_table[] = {
+	{
+		.procname	= "debug",
+		.data		= &sysctl_mpls_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.procname	= "default_ttl",
+		.data		= &sysctl_mpls_default_ttl,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+};
+
+static struct ctl_path mpls_path[] = {
+	{ .procname = "net", },
+	{ .procname = "mpls", },
+	{ }
+};
+
+static struct ctl_table_header *mpls_table_header;
+
+int __init mpls_sysctl_init(void)
+{
+	mpls_table_header = register_sysctl_paths(mpls_path, mpls_table);
+	if (!mpls_table_header)
+		return -ENOMEM;
+	return 0;
+}
+
+void mpls_sysctl_exit(void)
+{
+	unregister_sysctl_table(mpls_table_header);
+}
diff -Nur linux-3.14.1/net/mpls/mpls_tunnel.c linux-3.14.1_mpls/net/mpls/mpls_tunnel.c
--- linux-3.14.1/net/mpls/mpls_tunnel.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_tunnel.c	2014-04-24 17:18:46.792365865 +0530
@@ -0,0 +1,520 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching) Architecture for Linux.
+ *
+ * mpls_tunnel.c
+ *         * Management of MPLS tunnels, virtual devices named by default
+ *           mpls%d and that can be managed using userspace tools like
+ *           ip route, ifconfig, etc. As per RFC, LSPs are unidirectional.
+ *  Usage:
+ *         Creation    : mpls_tunnel_create
+ *         Destruction : mpls_tunnel_destroy
+ *         EXPORT_SYMBOL(mpls_tunnel_create);
+ *         EXPORT_SYMBOL(mpls_tunnel_destroy);
+ *
+ * Authors:
+ *   (c) 1999-2005   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * ChangeLog
+ *	v-0.97 20040207 RCAS 
+ *		o set up netlink links. 
+ *	v-0.98 20040208 RCAS 
+ *		o remove private list. 
+ *		o fixed some MTU issues. Use dev_set_mtu
+ *	20050105 JLEU
+ *		o implement netlink interface
+ *	20050827 JLEU
+ *		o remove netlink code
+ *		o module loading creates one interface, unload deletes it
+ *		o implemented device IOCTL for setting NHLFE
+ *****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ip.h>
+#include <linux/if_tunnel.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <net/net_namespace.h>
+#include <net/mpls.h>
+#include <linux/module.h>
+
+/**
+ * MODULE Information and attributes
+ **/
+
+static struct net_device *mpls_tunnel_dev;
+static void mpls_tunnel_setup (struct net_device *dev);
+
+MODULE_AUTHOR("James R. Leu <jleu@mindspring.com>, Ramon Casellas <casellas@infres.enst.fr>");
+MODULE_DESCRIPTION("MultiProtocol Label Switching Tunnel Module");
+MODULE_LICENSE("GPL");
+
+/*  Obtain private MPLS extension for a netdevice */
+#define mpls_dev2mtp(MPLSDEV) \
+	((struct mpls_tunnel_private *)(netdev_priv(MPLSDEV)))
+
+/* Obtain mentor netdevice for a given (private) tunnel */
+#define mpls_mtp2dev(MPLSMTP) \
+	((struct net_device *)((MPLSMTP)->mtp_dev))
+
+unsigned int mpls_tunnel_key;
+
+/**
+ *	mpls_tunnel_set_nhlfe - sets the nhlfe for this virtual device.
+ *	@dev: netdevice "mpls%d" 
+ *	@key: nhlfe key. 
+ *
+ *	Sets the NHLFE for this mpls net_device according to the key: if the
+ *	key is zero, this function releases and resets the tunnel's nhlfe.
+ *	Otherwise, it holds a reference to the new nhlfe (as per key),
+ *	updates the MTU
+ *
+ *	The mtp_nhlfe member of the tunnel private structure holds a
+ *	reference to the new NHLFE object.
+ *	Returns 0 if ok.
+ *
+ *	Remarks:
+ *	     o This function increases the reference count of the NHLFE
+ *	       determined by the key if the key is non zero, since the
+ *	       NHLFE will be held by the device private part.
+ *	Changes:
+ *	     o RCAS 20040207. Use dev_set_mtu
+ **/
+
+static int mpls_tunnel_set_nhlfe (struct net_device* dev, unsigned int key) 
+{
+	struct mpls_nhlfe *nhlfe = NULL;
+	struct mpls_nhlfe *newnhlfe = NULL;
+
+	MPLS_ENTER;
+
+	/* Get previous NHLFE (it is held by mtp)  */ 
+	nhlfe = mpls_dev2mtp(dev)->mtp_nhlfe;
+
+	/* If key is zero, the nhlfe for tunnel is reset, we are done */ 
+	if (!key) {
+		if (nhlfe) {
+			MPLS_DEBUG("dropping old nhlfe %x\n", nhlfe->nhlfe_key);
+			mpls_nhlfe_release(nhlfe);
+		}
+		MPLS_DEBUG("reset nhlfe %x\n", key);
+		mpls_dev2mtp(dev)->mtp_nhlfe = NULL;
+		dev->iflink = 0;
+		MPLS_EXIT;
+		return 0; 
+	}
+
+	/* Get a reference for new NHLFE */
+	newnhlfe = mpls_get_nhlfe(key);
+	if (unlikely(!newnhlfe)) {
+		MPLS_DEBUG("error fetching new nhlfe with key %u\n",key);
+		MPLS_DEBUG("keeping old nhlfe %x\n", nhlfe->nhlfe_key);
+		MPLS_EXIT;
+		return -ESRCH;
+	}
+
+	/* Drop old NHLFE */
+	if (nhlfe) {
+		dev_close(dev);
+		MPLS_DEBUG("dropping old nhlfe %x\n", nhlfe->nhlfe_key);
+		mpls_nhlfe_release(nhlfe);
+	}
+
+	/* Commit Set new NHLFE (it is held by mtp)  */ 
+ 	mpls_dev2mtp(dev)->mtp_nhlfe = newnhlfe;
+
+	if (newnhlfe) {
+		/* Set new MTU for the tunnel device */
+		dev_set_mtu(dev,newnhlfe->nhlfe_mtu);
+		dev_open(dev);
+	}
+
+	MPLS_EXIT;
+	return 0;
+}
+
+/**
+ *	mpls_tunnel_destructor - say tunnel goodbye.
+ *	@dev: mpls tunnel
+ *
+ *	This callback gets called when the core system destroys the net_device.
+ *	Remember that it was allocated with  alloc_netdev(netdev + privdata),
+ *	and netdev_priv(dev) points to the "extension" (privdata). So we just reset to
+ *	NULL. cf. dev.c "It must be the very last action, after this 'dev' may
+ *	point to freed up memory.". the refcount of the object at this point is
+ *	zero.
+ *
+ *	Changes:
+ *	    20040118 RCAS: When destroying the tunnel, release the NHLFE
+ *	              object if it was there.
+ **/
+
+static void 
+mpls_tunnel_destructor (struct net_device *dev) 
+{
+	MPLS_ENTER;
+	mpls_tunnel_set_nhlfe (dev,0);
+	free_netdev (dev);
+	MPLS_EXIT;
+}
+
+/**
+ *	mpls_tunnel_xmit - transmit a socket buffer via the device.
+ *	@skb: data
+ *	@dev: mpls tunnel
+ *
+ *	This callback gets called when the core system wants to send a socket
+ *	buffer. the "mpls_output2" symbol will take care of it. This only
+ *	happens of course if someone set a valid NHLFE (e.g. PUSH/.../SET) for
+ *	the device
+ **/
+
+static int 
+mpls_tunnel_xmit (struct sk_buff *skb, struct net_device *dev) 
+{
+	const char *err_nonhlfe = "NHLFE was invalid";
+	int result = 0;
+
+	MPLS_ENTER;
+
+	MPLSCB(skb)->label = 0;
+	MPLSCB(skb)->ttl = 255;
+	MPLSCB(skb)->exp = 0;
+	MPLSCB(skb)->bos = (skb->protocol == htons(ETH_P_MPLS_UC)) ? 0 : 1;
+	MPLSCB(skb)->flag = 0;
+	MPLSCB(skb)->popped_bos = (MPLSCB(skb)->bos) ? 0 : 1;
+
+	dev->trans_start = jiffies;
+	if (mpls_dev2mtp(dev)->mtp_nhlfe) {
+		MPLS_DEBUG(
+		"Skb to Send\n"
+		"Device %s \n"
+		"DST %p\n"
+		"Protocol ID %04x\n",
+		skb->dev? skb->dev->name : "<>",
+		skb_dst(skb) ? skb_dst(skb) : NULL,
+		ntohs(skb->protocol)
+		);
+			
+		MPLS_DEBUG("Using NHLFE %08x\n", 
+			mpls_dev2mtp(dev)->mtp_nhlfe->nhlfe_key);
+		mpls_dev2mtp(dev)->stat.tx_packets++;
+		mpls_dev2mtp(dev)->stat.tx_bytes += skb->len;
+		MPLS_DEBUG_CALL(mpls_skb_dump(skb));
+		result = mpls_output2 (skb,mpls_dev2mtp(dev)->mtp_nhlfe);
+		MPLS_EXIT;
+		return result; 
+	}
+
+	dev_kfree_skb(skb);
+	mpls_dev2mtp(dev)->stat.tx_errors++;
+	MPLS_DEBUG("exit - %s\n", err_nonhlfe);
+	return 0;
+}
+
+/**
+ *	mpls_tunnel_get_stats - get sender statistics for this tunnel 
+ *	@dev: virtual "mpls%d" device.
+ **/
+
+static struct net_device_stats* 
+mpls_tunnel_get_stats (struct net_device *dev) 
+{
+	return &((mpls_dev2mtp(dev))->stat);
+}
+
+/**
+ *	mpls_tunnel_change_mtu - Grant new MTU value for device. 
+ *	@dev: virtual "mpls%d" device.
+ *	@new_mtu: new value 
+ *
+ *	Called by dev_set_mtu (see net/code/dev.c). May veto the new value.
+ *	Returns 0 if Ok. -EINVAL otherwise. 
+ *	dev_set_mtu(dev,new) takes care of the actual assignement.
+ **/
+
+static int 
+mpls_tunnel_change_mtu (struct net_device *dev, int new_mtu) 
+{
+	int retval = 0;
+	MPLS_ENTER;
+	if (new_mtu < 4 || new_mtu > mpls_dev2mtp(dev)->mtp_nhlfe->nhlfe_mtu)
+		retval = -EINVAL;
+	MPLS_EXIT;
+	return retval;
+}
+
+static int mpls_tunnel_alloc(struct mpls_tunnel_req *mtr) {
+	struct mpls_nhlfe *nhlfe = NULL;
+	struct net_device *dev;
+	int retval;
+
+	MPLS_ENTER;
+	retval = -ESRCH;
+	if (mtr->mt_nhlfe_key && !(nhlfe = mpls_get_nhlfe(mtr->mt_nhlfe_key)))
+		goto error;
+
+	retval = -ENOMEM;
+	snprintf(mtr->mt_ifname, IFNAMSIZ, "mpls%d", mpls_tunnel_key++);
+	if (!(dev = alloc_netdev (sizeof(struct mpls_tunnel_private),
+		mtr->mt_ifname, mpls_tunnel_setup))) {
+		mpls_nhlfe_release(nhlfe);
+		goto error;
+	}
+
+	retval = -ENOBUFS;
+	if (register_netdevice(dev)) {
+		mpls_nhlfe_release(nhlfe);
+		free_netdev(dev);
+		goto error;
+	}
+
+	mpls_dev2mtp(dev)->mtp_nhlfe = nhlfe;
+	dev_hold(dev);
+	retval = 0;
+error:
+	MPLS_EXIT;
+	return retval;
+}
+
+static struct net_device *
+mpls_tunnel_lookup(struct mpls_tunnel_req *mtr) {
+	struct net_device *dev;
+	MPLS_ENTER;
+	dev = __dev_get_by_name(&init_net, mtr->mt_ifname);
+	MPLS_EXIT;
+	return dev;
+}
+
+/**
+ *	mpls_tunnel_ioctl - callback for device private IOCTL calls
+ *	@dev: virtual "mpls%d" device.
+ *	@ifr: IOCTL request data
+ *	@cmd: IOCTL command
+ *
+ *	Called in response to a userland IOCTL call for configuring
+ *	this tunnel interface
+ *	Returns 0 if Ok. < 0 on error
+ **/
+
+static int
+mpls_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct mpls_tunnel_private *mtp = NULL;
+	struct mpls_tunnel_req mtr;
+	int retval = 0;
+
+	MPLS_ENTER;
+	switch (cmd) {
+		case SIOCGETTUNNEL:
+			retval = -EPERM;
+			if (!capable(CAP_NET_ADMIN))
+				break;
+
+			if (dev == mpls_tunnel_dev) {
+				retval = -EFAULT;
+				if (copy_from_user(&mtr, ifr->ifr_data, sizeof(mtr)))
+					break;
+
+				retval = -ENOENT;
+				if (!(dev = mpls_tunnel_lookup(&mtr)))
+					break;
+
+				retval = -EINVAL;
+				if (strncmp(mtr.mt_ifname, "mpls0", 5) == 0)
+					break;
+			}
+
+			mtp = mpls_dev2mtp(dev);
+			mtr.mt_nhlfe_key =
+			mtp->mtp_nhlfe ? mtp->mtp_nhlfe->nhlfe_key : 0;
+
+			retval = 0;
+			break;
+
+		case SIOCADDTUNNEL:
+			retval = -EPERM;
+			if (!capable(CAP_NET_ADMIN))
+				break;
+
+			retval = -EFAULT;
+			if (copy_from_user(&mtr, ifr->ifr_data, sizeof(mtr)))
+				break;
+
+			retval = -EINVAL;
+			if (mtr.mt_nhlfe_key == 0)
+				break;
+			if (dev == mpls_tunnel_dev) {
+				retval = mpls_tunnel_alloc(&mtr);
+				break;
+			}
+			retval = mpls_tunnel_set_nhlfe(mpls_mtp2dev(mtp), mtr.mt_nhlfe_key);
+			break;
+
+		case SIOCDELTUNNEL:
+			retval = -EPERM;
+			if (!capable(CAP_NET_ADMIN))
+				break;
+
+			if (dev == mpls_tunnel_dev) {
+				retval = -EFAULT;
+				if (copy_from_user(&mtr, ifr->ifr_data, sizeof(mtr)))
+					break;
+
+				retval = -ENOENT;
+				if (!(dev = mpls_tunnel_lookup(&mtr)))
+					break;
+
+				retval = -EINVAL;
+				if (strncmp(mtr.mt_ifname, "mpls0", 5) == 0)
+					break;
+			}
+			unregister_netdevice(dev);
+			retval = 0;
+			break;
+
+		default:
+			retval = -EINVAL;
+	}
+
+	if (copy_to_user(ifr->ifr_data, &mtr, sizeof(mtr)))
+		retval = -EFAULT;
+
+	MPLS_EXIT;
+	return retval;
+}
+
+static int mpls_tunnel_init(struct net_device *dev)
+{
+	struct mpls_tunnel_private *mtp =  mpls_dev2mtp(dev);
+	MPLS_ENTER;
+	mtp->mtp_dev = dev;
+	MPLS_EXIT;
+	return 0;
+}
+
+static void mpls_tunnel_uninit(struct net_device *dev)
+{
+	MPLS_ENTER;
+	dev_put(dev);
+	MPLS_EXIT;
+}
+
+static const struct net_device_ops mpls_tunnel_ndo = {
+	.ndo_open = NULL,
+	.ndo_init = mpls_tunnel_init,
+	.ndo_uninit = mpls_tunnel_uninit,
+	.ndo_do_ioctl = mpls_tunnel_ioctl,
+	.ndo_start_xmit = mpls_tunnel_xmit,
+	.ndo_get_stats = mpls_tunnel_get_stats,
+	.ndo_change_mtu = mpls_tunnel_change_mtu,
+};
+
+/**
+ *	mpls_tunnel_setup - main setup callback
+ *	@dev - mpls%d
+ *
+ *	Main setup function. Called by net/core/dev.c after a successful
+ *	netdev_alloc. We just set the function pointer table, device type and
+ *	flags. Initial MTU value is arbitrary, since the tunnel hasn't a valid
+ *	NHLFE object (NHLFE objects know the number of pushes and the MTU of the
+ *	real physical device).
+ **/
+
+static void 
+mpls_tunnel_setup (struct net_device *dev) 
+{
+	MPLS_ENTER;
+
+	/* Callbacks */
+	dev->destructor	     = mpls_tunnel_destructor;
+	dev->netdev_ops	     = &mpls_tunnel_ndo;
+
+	/* Properties of mpls%d devices */
+	dev->type            = ARPHRD_MPLS_TUNNEL;
+	dev->hard_header_len = MPLS_SHIM_SIZE;
+	dev->mtu	     = 1500;
+	dev->flags	     = IFF_NOARP|IFF_POINTOPOINT;
+	dev->iflink	     = 0;
+	dev->addr_len	     = MPLS_SHIM_SIZE;
+	MPLS_EXIT;
+}
+
+/**
+ *	mpls_tunnel_init_module - main tunnel init routine.
+ *
+ *	Init method called when the module is loaded, initiliazes the 
+ *	list of created tunnels to zero, initializes and registers the 
+ *	mpls_tunnel kset (which depends on the mpls subsystem) and creates
+ *	/proc/net/mpls/tunnel entry.
+ **/
+
+static int __init 
+mpls_tunnel_init_module (void) 
+{
+	struct mpls_tunnel_private *mtp;
+	int retval = -EINVAL;
+
+	mpls_tunnel_dev = alloc_netdev (sizeof(struct mpls_tunnel_private),
+		"mpls0", mpls_tunnel_setup);
+	if (unlikely(!mpls_tunnel_dev)) {
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	if (unlikely((retval = register_netdev(mpls_tunnel_dev)))) {
+		free_netdev(mpls_tunnel_dev);
+		goto err;
+	}
+
+	mtp = mpls_dev2mtp(mpls_tunnel_dev);
+	mtp->mtp_dev = mpls_tunnel_dev;
+	dev_hold(mpls_tunnel_dev);
+	mpls_tunnel_key = 1;
+
+	retval = 0;
+err:
+	return retval;
+}
+
+static void __exit mpls_destroy_tunnels(void)
+{
+	struct net_device *dev;
+
+	for_each_netdev(&init_net, dev) {
+		if (dev->type == ARPHRD_MPLS_TUNNEL)
+		{
+				printk ("mpls_destroy_tunnels DEV TYPE .........");
+				unregister_netdevice(dev);
+		}
+	}
+}
+
+/**
+ *	mpls_tunnel_exit_module - Module unload exit method.
+ *	
+ **/
+
+static void __exit 
+mpls_tunnel_exit_module (void) 
+{
+	rtnl_lock();
+	mpls_destroy_tunnels();
+	rtnl_unlock();
+	return;
+}
+
+module_init(mpls_tunnel_init_module);
+module_exit(mpls_tunnel_exit_module);
diff -Nur linux-3.14.1/net/mpls/mpls_utils.c linux-3.14.1_mpls/net/mpls/mpls_utils.c
--- linux-3.14.1/net/mpls/mpls_utils.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/mpls_utils.c	2014-04-23 10:28:57.312946394 +0530
@@ -0,0 +1,226 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *	  James Leu	<jleu@mindspring.com>
+ *	  Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu	<jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *	      It implements:
+ *	      -various common functions called by the rest of the MPLS
+ *	       stack
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ *
+ * RCAS BUGS: struct mpls_label should use u32, u16...
+ ****************************************************************************/
+
+#include <generated/autoconf.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/kobject.h>
+#include <net/neighbour.h>
+#include <net/route.h>
+#include <net/mpls.h>
+
+/**************
+  ATM
+   0		   1		   2		   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |Label Space(10)    |    VPI (8)    |	  VCI(16)		  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |typ|     index(8)  |	   VPI (8)    |	  VCI(16)		  |
+  +---------------------------------------------------------------+
+  |	       mark (key)				          |
+  +---------------------------------------------------------------+
+
+  Generic
+   0		   1		   2		   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |   Label Space(12)     |       Generic Label Value(20)	  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |typ|    index(10)      |		   gen(20)		  | 
+  +---------------------------------------------------------------+
+  |	       mark (key)				          |
+  +---------------------------------------------------------------+
+
+  Frame Relay
+   0		   1		   2		   3
+   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |Label Space(12)  	  |	      DLCI(20)			  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |typ|    index(10)      |		   fr(20)		  | 
+  +---------------------------------------------------------------+
+  |	       mark (key)				          |
+  +---------------------------------------------------------------+
+
+ *************/
+
+struct mpls_atm_key {
+	unsigned int type:2;
+	unsigned int index:8;
+	unsigned int vpi:8;
+	unsigned int vci:14;
+};
+
+struct mpls_gen_key {
+	unsigned int type:2;
+	unsigned int index:10;
+	unsigned int gen:20;
+};
+
+struct mpls_fr_key {
+	unsigned int type:2;
+	unsigned int index:10;
+	unsigned int fr:20;
+};
+
+struct mpls_key {
+	union {
+		struct mpls_atm_key atm;
+		struct mpls_gen_key gen;
+		struct mpls_fr_key  fr;
+		unsigned int mark:32;
+	} u;
+};
+
+
+
+/** 
+ *	mpls_label2key - Obtain a lookup key given a index or labelspace
+ *	and a label value.
+ *	@index: labelspace
+ *	@label: struct containing the label type/value.
+ *
+ *	Returns a given key that can be used to store/read objects in a 
+ *	data structure (e.g. a Radix Tree).
+ *
+ *	Bugs: RCAS: this function must be *faast* optimize!
+ **/
+
+unsigned int  
+mpls_label2key (const int index, const struct mpls_label *label) 
+{
+	struct mpls_key temp;
+
+	switch(label->ml_type) {
+		case MPLS_LABEL_GEN:
+			temp.u.gen.index = index;
+			temp.u.gen.gen   = label->u.ml_gen;
+			temp.u.gen.type  = label->ml_type;
+			break;
+		case MPLS_LABEL_ATM:
+			temp.u.atm.index = index;
+			temp.u.atm.vpi   = label->u.ml_atm.mla_vpi;
+			temp.u.atm.vci   = label->u.ml_atm.mla_vci;
+			temp.u.atm.type  = label->ml_type;
+			break;
+		case MPLS_LABEL_FR:
+			temp.u.fr.index  = index;
+			temp.u.fr.fr     = label->u.ml_fr;
+			temp.u.fr.type   = label->ml_type;
+			break;
+		case MPLS_LABEL_KEY:
+			temp.u.mark      = label->u.ml_key;
+			break;
+	}
+	return temp.u.mark;
+}
+
+/**
+ *	mpls_find_payload - find the beinging of the data under the
+ *	mpls shim
+ *	@skb - the packet to work on
+ *
+ *	assumes valid data in MPLSCB(skb)->popped_bos and that
+ *	that skb_network_header(skb) is pointing to a label in the MPLS shim
+ *	returns a unsigned char* which point to the first byte after the MPLS
+ *	shim.
+ *
+ **/
+
+char
+mpls_find_payload (struct sk_buff* skb)
+{
+	unsigned char *ptr = skb->data;
+	unsigned char count = 0;
+        u32 shim;
+
+	if (MPLSCB(skb)->popped_bos)
+		return count;
+
+try_again:
+
+	if (ptr > skb_tail_pointer(skb))
+		return -1;
+
+#define CAN_WE_ASSUME_32BIT_ALIGNED 0
+#if CAN_WE_ASSUME_32BIT_ALIGNED
+        shim = ntohl(*((u32*)ptr));
+#else
+        memcpy(&shim,ptr,MPLS_SHIM_SIZE);
+        shim = ntohl(shim);
+#endif
+
+	ptr = &ptr[MPLS_SHIM_SIZE];
+	count += MPLS_SHIM_SIZE;
+
+        if ((shim >> 8 ) & 0x1)
+	    return count;
+
+	goto try_again;
+
+        return 0;
+}
+
+/**
+ *	mpls_skb_dump - dump socket buffer to kernel log.
+ *	@sk received socket buffer
+ *	
+ *	Dumps the content of the socket buffer to the kernel log buffer. Can be 
+ *	called from anywhere, but typically it is called upon reception of a
+ *	labelled packet.
+ *
+ **/
+
+void 
+mpls_skb_dump (struct sk_buff* sk) 
+{
+	unsigned long i;
+	printk("MPLS mpls_skb_dump: from %s with len %d (%d)" 
+	       "headroom=%d tailroom=%d\n",
+			sk->dev?sk->dev->name:" net stack ",
+			sk->len,
+			sk->truesize,
+			skb_headroom(sk),
+			skb_tailroom(sk));
+
+	for (i=(unsigned long)sk->head; i<=(unsigned long)skb_tail_pointer(sk); i++) {
+		if (i == (unsigned long)sk->data)
+			printk("{"); 
+		if (i == (unsigned long)skb_transport_header(sk))
+			printk("#");
+		if (i == (unsigned long)skb_network_header(sk))
+			printk("|"); 
+		if (i == (unsigned long)skb_mac_header(sk))
+			printk("*"); 
+		printk("%02x",*((unsigned char*)i));
+		if (i == (unsigned long)skb_tail_pointer(sk))
+			printk("}"); 
+	}
+	printk("\n");
+}
+
+EXPORT_SYMBOL(mpls_label2key);
+EXPORT_SYMBOL(mpls_find_payload);
+EXPORT_SYMBOL(mpls_skb_dump);
diff -Nur linux-3.14.1/net/mpls/TODO linux-3.14.1_mpls/net/mpls/TODO
--- linux-3.14.1/net/mpls/TODO	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/mpls/TODO	2014-04-23 09:19:51.329068470 +0530
@@ -0,0 +1,20 @@
+* PRIO1 20040207
+  RCAS :Allocations in control plane use GPF_ATOMIC because we are working
+  under a spinlock. This is suboptimal. We should define a better locking
+  scheme (most MII/MOI modifications are performed in user context, after
+  a IOCTL).  We could define a better locking scheme and revert to GPF_KERNEL
+
+* RCAS : Use event management for "external" MOI/MII references: Any
+  protocol, device or module (e.g. tunnel) that holds a reference to a
+  MII/MOI should register for removal notification, and cleanup and put
+  back the reference if they receive a MOI or MII remove event.
+
+* RCAS: With the current implementation, &mpls_mii_lock and &mpls_moi_lock
+  are used to synchronize access to the input and output trees.  I think
+  that we may need to control access to individual MII/MOI objects too,
+  don't we? : Reader gets a MII pointer locking and
+  unlocking the reader lock that controls the tree, and holds the pointer. 
+  Writer locks tree and updates an object. Race? Think bout the locking 
+ scheme (per cpu, local irq dis?)
+
+* JLEU: bind instructions to name and make them a RTAs in the SHIM_INSTR RTA
diff -Nur linux-3.14.1/net/netfilter/Kconfig linux-3.14.1_mpls/net/netfilter/Kconfig
--- linux-3.14.1/net/netfilter/Kconfig	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/netfilter/Kconfig	2014-04-23 10:31:31.507007912 +0530
@@ -780,6 +780,16 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_TARGET_MPLS
+	tristate '"mpls" target support'
+	depends on NETFILTER_XTABLES
+	depends on MPLS
+	help
+	  This option adds a `mpls' target, which allows you to create rules
+	  in the `mangle' table which map packets to a MPLS LSP
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_TARGET_NFQUEUE
 	tristate '"NFQUEUE" target Support'
 	depends on NETFILTER_ADVANCED
diff -Nur linux-3.14.1/net/netfilter/Makefile linux-3.14.1_mpls/net/netfilter/Makefile
--- linux-3.14.1/net/netfilter/Makefile	2014-04-14 19:20:10.000000000 +0530
+++ linux-3.14.1_mpls/net/netfilter/Makefile	2014-04-23 10:35:16.372180974 +0530
@@ -104,6 +104,7 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_HL) += xt_HL.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_HMARK) += xt_HMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_MPLS) += xt_mpls.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_LOG) += xt_LOG.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NETMAP) += xt_NETMAP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NFLOG) += xt_NFLOG.o
diff -Nur linux-3.14.1/net/netfilter/xt_mpls.c linux-3.14.1_mpls/net/netfilter/xt_mpls.c
--- linux-3.14.1/net/netfilter/xt_mpls.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/net/netfilter/xt_mpls.c	2014-04-23 10:36:46.751044757 +0530
@@ -0,0 +1,95 @@
+/* This is a module which is used for redirecting packets into MPLS land. */
+
+/* (C) 1999-2007 James R. Leu <jleu@mindspring.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <net/route.h>
+#include <net/mpls.h>
+#include <net/checksum.h>
+
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_mpls.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("James R. Leu <jle@mindspring.com>");
+MODULE_DESCRIPTION("ip[6]tables mpls module");
+MODULE_ALIAS("ipt_mpls");
+MODULE_ALIAS("ip6t_mpls");
+
+static unsigned int
+target(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	const struct xt_mpls_target_info *mplsinfo = par->targinfo;
+	struct mpls_nhlfe *nhlfe = mplsinfo->nhlfe;
+
+	if (mpls_set_nexthop2(nhlfe, skb_dst(skb))) {
+		return NF_DROP;
+	}
+	return XT_CONTINUE;
+}
+
+static int
+checkentry(const struct xt_tgchk_param *par)
+{
+	struct xt_mpls_target_info *mplsinfo = par->targinfo;
+	mplsinfo->nhlfe = mpls_get_nhlfe(mplsinfo->key);
+	if (!mplsinfo->nhlfe) {
+		printk(KERN_WARNING "mpls: unable to find NHLFE with key %x\n",
+			mplsinfo->key);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void
+destroy(const struct xt_tgdtor_param *par)
+{
+	struct xt_mpls_target_info *mplsinfo = par->targinfo;
+	if (mplsinfo->nhlfe)
+		mpls_nhlfe_release(mplsinfo->nhlfe);
+}
+
+static struct xt_target xt_mpls_target[] = {
+	{
+		.name		= "mpls",
+		.family		= AF_INET,
+		.revision	= 0,
+		.checkentry	= checkentry,
+		.target		= target,
+		.destroy	= destroy,
+		.targetsize	= sizeof(struct xt_mpls_target_info),
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	},
+	{
+		.name		= "mpls",
+		.family		= AF_INET6,
+		.revision	= 0,
+		.checkentry	= checkentry,
+		.target		= target,
+		.destroy	= destroy,
+		.targetsize	= sizeof(struct xt_mpls_target_info),
+		.table		= "mangle",
+		.me		= THIS_MODULE,
+	},
+};
+
+static int __init xt_mpls_init(void)
+{
+	return xt_register_targets(xt_mpls_target, ARRAY_SIZE(xt_mpls_target));
+}
+
+static void __exit xt_mpls_fini(void)
+{
+	xt_unregister_targets(xt_mpls_target, ARRAY_SIZE(xt_mpls_target));
+}
+
+module_init(xt_mpls_init);
+module_exit(xt_mpls_fini);
diff -Nur linux-3.14.1/security/tomoyo/builtin-policy.h linux-3.14.1_mpls/security/tomoyo/builtin-policy.h
--- linux-3.14.1/security/tomoyo/builtin-policy.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/security/tomoyo/builtin-policy.h	2014-04-21 11:37:27.494251318 +0530
@@ -0,0 +1,12 @@
+static char tomoyo_builtin_profile[] __initdata =
+"";
+static char tomoyo_builtin_exception_policy[] __initdata =
+"initialize_domain /sbin/modprobe from any\n"
+"initialize_domain /sbin/hotplug from any\n"
+"";
+static char tomoyo_builtin_domain_policy[] __initdata =
+"";
+static char tomoyo_builtin_manager[] __initdata =
+"";
+static char tomoyo_builtin_stat[] __initdata =
+"";
diff -Nur linux-3.14.1/security/tomoyo/policy/exception_policy.conf linux-3.14.1_mpls/security/tomoyo/policy/exception_policy.conf
--- linux-3.14.1/security/tomoyo/policy/exception_policy.conf	1970-01-01 05:30:00.000000000 +0530
+++ linux-3.14.1_mpls/security/tomoyo/policy/exception_policy.conf	2014-04-21 11:37:26.930251308 +0530
@@ -0,0 +1,2 @@
+initialize_domain /sbin/modprobe from any
+initialize_domain /sbin/hotplug from any
